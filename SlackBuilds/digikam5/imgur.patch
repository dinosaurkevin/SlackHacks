From d4ca1fa62f4858cc0ce610638832fa2db4c6de7e Mon Sep 17 00:00:00 2001
From: Fabian Vogt <fabian@ritter-vogt.de>
Date: Wed, 29 Jun 2016 22:26:40 +0200
Subject: [PATCH 1/3] Add o2 library from https://github.com/pipacs/o2

- With some fixes for o2.cpp from https://github.com/Vogtinator/o2
- Remove references to QtKOAuth

Signed-off-by: Fabian Vogt <fabian@ritter-vogt.de>
---
 CMakeLists.txt                                     |   3 +-
 cmake/modules/FindQtKOAuth.cmake                   |  33 --
 common/libkipiplugins/CMakeLists.txt               |  39 +-
 common/libkipiplugins/o2/.gitignore                |   2 +
 common/libkipiplugins/o2/CHANGES.md                |  16 +
 common/libkipiplugins/o2/CMakeLists.txt            |  31 ++
 common/libkipiplugins/o2/LICENSE                   |  23 ++
 common/libkipiplugins/o2/README.md                 | 212 +++++++++++
 common/libkipiplugins/o2/acknowledgements.md       |  57 +++
 common/libkipiplugins/o2/examples/.gitignore       |   6 +
 common/libkipiplugins/o2/examples/CMakeLists.txt   |   9 +
 .../o2/examples/facebookdemo/CMakeLists.txt        |  43 +++
 .../o2/examples/facebookdemo/facebookdemo.pro      |  16 +
 .../o2/examples/facebookdemo/fbdemo.cpp            | 119 ++++++
 .../o2/examples/facebookdemo/fbdemo.h              |  35 ++
 .../o2/examples/facebookdemo/main.cpp              |  71 ++++
 .../libkipiplugins/o2/examples/sialis/.gitignore   |  73 ++++
 common/libkipiplugins/o2/examples/sialis/README.md |   5 +
 common/libkipiplugins/o2/examples/sialis/main.cpp  |  19 +
 common/libkipiplugins/o2/examples/sialis/main.qml  | 128 +++++++
 common/libkipiplugins/o2/examples/sialis/qml.qrc   |   5 +
 .../libkipiplugins/o2/examples/sialis/sialis.icns  | Bin 0 -> 32370 bytes
 .../libkipiplugins/o2/examples/sialis/sialis.pro   |  24 ++
 .../o2/examples/sialis/tweetmodel.cpp              |  40 ++
 .../libkipiplugins/o2/examples/sialis/tweetmodel.h |  38 ++
 .../o2/examples/sialis/twitterapi.cpp              |  57 +++
 .../libkipiplugins/o2/examples/sialis/twitterapi.h |  45 +++
 .../o2/examples/twitterdemo/CMakeLists.txt         |  43 +++
 .../o2/examples/twitterdemo/main.cpp               | 111 ++++++
 .../o2/examples/twitterdemo/tweeter.cpp            | 135 +++++++
 .../o2/examples/twitterdemo/tweeter.h              |  41 ++
 .../o2/examples/twitterdemo/twitterdemo.pro        |  14 +
 common/libkipiplugins/o2/src/CMakeLists.txt        | 103 +++++
 common/libkipiplugins/o2/src/o0abstractstore.h     |  22 ++
 common/libkipiplugins/o2/src/o0baseauth.cpp        | 126 +++++++
 common/libkipiplugins/o2/src/o0baseauth.h          | 120 ++++++
 common/libkipiplugins/o2/src/o0globals.h           |  61 +++
 common/libkipiplugins/o2/src/o0requestparameter.h  |  14 +
 common/libkipiplugins/o2/src/o0settingsstore.cpp   |  44 +++
 common/libkipiplugins/o2/src/o0settingsstore.h     |  42 +++
 common/libkipiplugins/o2/src/o0simplecrypt.h       | 225 +++++++++++
 common/libkipiplugins/o2/src/o1.cpp                | 379 +++++++++++++++++++
 common/libkipiplugins/o2/src/o1.h                  | 124 ++++++
 common/libkipiplugins/o2/src/o1dropbox.h           |  18 +
 common/libkipiplugins/o2/src/o1flickr.h            |  18 +
 common/libkipiplugins/o2/src/o1freshbooks.h        |  22 ++
 common/libkipiplugins/o2/src/o1requestor.cpp       |  57 +++
 common/libkipiplugins/o2/src/o1requestor.h         |  61 +++
 common/libkipiplugins/o2/src/o1timedreply.cpp      |  20 +
 common/libkipiplugins/o2/src/o1timedreply.h        |  25 ++
 common/libkipiplugins/o2/src/o1twitter.h           |  18 +
 common/libkipiplugins/o2/src/o2.cpp                | 417 +++++++++++++++++++++
 common/libkipiplugins/o2/src/o2.h                  | 170 +++++++++
 common/libkipiplugins/o2/src/o2facebook.cpp        |  90 +++++
 common/libkipiplugins/o2/src/o2facebook.h          |  18 +
 common/libkipiplugins/o2/src/o2gft.cpp             |  13 +
 common/libkipiplugins/o2/src/o2gft.h               |  14 +
 common/libkipiplugins/o2/src/o2hubic.cpp           |  17 +
 common/libkipiplugins/o2/src/o2hubic.h             |  17 +
 common/libkipiplugins/o2/src/o2reply.cpp           |  58 +++
 common/libkipiplugins/o2/src/o2reply.h             |  59 +++
 common/libkipiplugins/o2/src/o2replyserver.cpp     |  81 ++++
 common/libkipiplugins/o2/src/o2replyserver.h       |  33 ++
 common/libkipiplugins/o2/src/o2requestor.cpp       | 193 ++++++++++
 common/libkipiplugins/o2/src/o2requestor.h         |  82 ++++
 common/libkipiplugins/o2/src/o2simplecrypt.cpp     | 254 +++++++++++++
 common/libkipiplugins/o2/src/o2skydrive.cpp        | 125 ++++++
 common/libkipiplugins/o2/src/o2skydrive.h          |  18 +
 common/libkipiplugins/o2/src/o2surveymonkey.cpp    |  21 ++
 common/libkipiplugins/o2/src/o2surveymonkey.h      |  14 +
 common/libkipiplugins/o2/src/oxtwitter.cpp         |  69 ++++
 common/libkipiplugins/o2/src/oxtwitter.h           |  37 ++
 72 files changed, 4756 insertions(+), 36 deletions(-)
 delete mode 100644 cmake/modules/FindQtKOAuth.cmake
 create mode 100644 common/libkipiplugins/o2/.gitignore
 create mode 100644 common/libkipiplugins/o2/CHANGES.md
 create mode 100644 common/libkipiplugins/o2/CMakeLists.txt
 create mode 100644 common/libkipiplugins/o2/LICENSE
 create mode 100644 common/libkipiplugins/o2/README.md
 create mode 100644 common/libkipiplugins/o2/acknowledgements.md
 create mode 100644 common/libkipiplugins/o2/examples/.gitignore
 create mode 100644 common/libkipiplugins/o2/examples/CMakeLists.txt
 create mode 100644 common/libkipiplugins/o2/examples/facebookdemo/CMakeLists.txt
 create mode 100644 common/libkipiplugins/o2/examples/facebookdemo/facebookdemo.pro
 create mode 100644 common/libkipiplugins/o2/examples/facebookdemo/fbdemo.cpp
 create mode 100644 common/libkipiplugins/o2/examples/facebookdemo/fbdemo.h
 create mode 100644 common/libkipiplugins/o2/examples/facebookdemo/main.cpp
 create mode 100644 common/libkipiplugins/o2/examples/sialis/.gitignore
 create mode 100644 common/libkipiplugins/o2/examples/sialis/README.md
 create mode 100644 common/libkipiplugins/o2/examples/sialis/main.cpp
 create mode 100644 common/libkipiplugins/o2/examples/sialis/main.qml
 create mode 100644 common/libkipiplugins/o2/examples/sialis/qml.qrc
 create mode 100644 common/libkipiplugins/o2/examples/sialis/sialis.icns
 create mode 100644 common/libkipiplugins/o2/examples/sialis/sialis.pro
 create mode 100644 common/libkipiplugins/o2/examples/sialis/tweetmodel.cpp
 create mode 100644 common/libkipiplugins/o2/examples/sialis/tweetmodel.h
 create mode 100644 common/libkipiplugins/o2/examples/sialis/twitterapi.cpp
 create mode 100644 common/libkipiplugins/o2/examples/sialis/twitterapi.h
 create mode 100644 common/libkipiplugins/o2/examples/twitterdemo/CMakeLists.txt
 create mode 100644 common/libkipiplugins/o2/examples/twitterdemo/main.cpp
 create mode 100644 common/libkipiplugins/o2/examples/twitterdemo/tweeter.cpp
 create mode 100644 common/libkipiplugins/o2/examples/twitterdemo/tweeter.h
 create mode 100644 common/libkipiplugins/o2/examples/twitterdemo/twitterdemo.pro
 create mode 100644 common/libkipiplugins/o2/src/CMakeLists.txt
 create mode 100644 common/libkipiplugins/o2/src/o0abstractstore.h
 create mode 100644 common/libkipiplugins/o2/src/o0baseauth.cpp
 create mode 100644 common/libkipiplugins/o2/src/o0baseauth.h
 create mode 100644 common/libkipiplugins/o2/src/o0globals.h
 create mode 100644 common/libkipiplugins/o2/src/o0requestparameter.h
 create mode 100644 common/libkipiplugins/o2/src/o0settingsstore.cpp
 create mode 100644 common/libkipiplugins/o2/src/o0settingsstore.h
 create mode 100644 common/libkipiplugins/o2/src/o0simplecrypt.h
 create mode 100644 common/libkipiplugins/o2/src/o1.cpp
 create mode 100644 common/libkipiplugins/o2/src/o1.h
 create mode 100644 common/libkipiplugins/o2/src/o1dropbox.h
 create mode 100644 common/libkipiplugins/o2/src/o1flickr.h
 create mode 100755 common/libkipiplugins/o2/src/o1freshbooks.h
 create mode 100644 common/libkipiplugins/o2/src/o1requestor.cpp
 create mode 100644 common/libkipiplugins/o2/src/o1requestor.h
 create mode 100644 common/libkipiplugins/o2/src/o1timedreply.cpp
 create mode 100644 common/libkipiplugins/o2/src/o1timedreply.h
 create mode 100644 common/libkipiplugins/o2/src/o1twitter.h
 create mode 100644 common/libkipiplugins/o2/src/o2.cpp
 create mode 100644 common/libkipiplugins/o2/src/o2.h
 create mode 100644 common/libkipiplugins/o2/src/o2facebook.cpp
 create mode 100644 common/libkipiplugins/o2/src/o2facebook.h
 create mode 100644 common/libkipiplugins/o2/src/o2gft.cpp
 create mode 100644 common/libkipiplugins/o2/src/o2gft.h
 create mode 100644 common/libkipiplugins/o2/src/o2hubic.cpp
 create mode 100644 common/libkipiplugins/o2/src/o2hubic.h
 create mode 100644 common/libkipiplugins/o2/src/o2reply.cpp
 create mode 100644 common/libkipiplugins/o2/src/o2reply.h
 create mode 100644 common/libkipiplugins/o2/src/o2replyserver.cpp
 create mode 100644 common/libkipiplugins/o2/src/o2replyserver.h
 create mode 100644 common/libkipiplugins/o2/src/o2requestor.cpp
 create mode 100644 common/libkipiplugins/o2/src/o2requestor.h
 create mode 100644 common/libkipiplugins/o2/src/o2simplecrypt.cpp
 create mode 100644 common/libkipiplugins/o2/src/o2skydrive.cpp
 create mode 100644 common/libkipiplugins/o2/src/o2skydrive.h
 create mode 100644 common/libkipiplugins/o2/src/o2surveymonkey.cpp
 create mode 100644 common/libkipiplugins/o2/src/o2surveymonkey.h
 create mode 100644 common/libkipiplugins/o2/src/oxtwitter.cpp
 create mode 100644 common/libkipiplugins/o2/src/oxtwitter.h

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 949f586..0d3e41f 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -137,7 +137,6 @@ if(KF5Kipi_FOUND)
 
     DETECT_LIBMEDIAWIKI(5.0.0)                                                 # For Mediawiki.
     DETECT_LIBKVKONTAKTE(4.70.0)                                               # For VKontakte.
-    find_package(QtKOAuth)                                                     # For Imgur Auhtenticated API.
 
     # ==================================================================================================
     # Log messages
@@ -159,7 +158,6 @@ if(KF5Kipi_FOUND)
     PRINT_OPTIONAL_LIBRARY_STATUS("libkarchive"     "https://projects.kde.org/projects/frameworks/karchive"           "(version >= ${KF5_MIN_VERSION})"      "Kipi-plugins will be compiled without libkarchive support."     KF5Archive_FOUND)
     PRINT_OPTIONAL_LIBRARY_STATUS("libmediawiki"    "https://projects.kde.org/projects/extragear/libs/libmediawiki"   "(version >= ${KF5_MIN_VERSION})"      "Kipi-plugins will be compiled without libmediawiki support."    KF5MediaWiki_FOUND)
     PRINT_OPTIONAL_LIBRARY_STATUS("libkvkontakte"   "https://projects.kde.org/projects/extragear/libs/libkvkontakte"  "(version >= 4.70.0)"                  "Kipi-plugins will be compiled without libkvkontakte support."   KF5Vkontakte_FOUND)
-    PRINT_OPTIONAL_LIBRARY_STATUS("libqtkoauth"     "https://github.com/kypeli/kQOAuth"                               "(version >= 0.97)"                    "Kipi-plugins will be compiled without libqtkoauth support."     QTKOAUTH_FOUND)
 
     # Optional plugins results ----------------------------------------------------------------------------
 
@@ -211,6 +209,7 @@ if(KF5Kipi_FOUND)
                             ${CMAKE_CURRENT_SOURCE_DIR}/common/libkipiplugins/widgets
                             ${CMAKE_CURRENT_SOURCE_DIR}/common/libkipiplugins/tools
                             ${CMAKE_CURRENT_SOURCE_DIR}/common/libkipiplugins/tools/imageio
+                            ${CMAKE_CURRENT_SOURCE_DIR}/common/libkipiplugins/o2/src
                             ${KF5Kipi_INCLUDE_DIRS}
                         )
 
diff --git a/cmake/modules/FindQtKOAuth.cmake b/cmake/modules/FindQtKOAuth.cmake
deleted file mode 100644
index 425a8f2..0000000
--- a/cmake/modules/FindQtKOAuth.cmake
+++ /dev/null
@@ -1,33 +0,0 @@
-# - Try to find the kQOAuth library
-# Once done this will define
-#
-#  QTKOAUTH_FOUND - system has the kQOAuth library
-#  QTKOAUTH_INCLUDE_DIR - the kQOAuth include directory
-#  QTKOAUTH_LIBRARIES - Link this to use the kQOAuth
-#  QTKOAUTH_DEFINITIONS - Compiler switches required for using kQOAuth
-#
-
-if (QTKOAUTH_INCLUDE_DIR AND QTKOAUTH_LIBRARIES)
-#   in cache already
-  set(QTKOAUTH_FOUND TRUE)
-else (QTKOAUTH_INCLUDE_DIR AND QTKOAUTH_LIBRARIES)
-  if (NOT WIN32)
-    find_package(PkgConfig)
-    pkg_check_modules(PC_QTKOAUTH QUIET kqoauth)
-    set(QTKOAUTH_DEFINITIONS ${PC_QTKOAUTH_CFLAGS_OTHER})
-  endif(NOT WIN32)
-
-  find_library(QTKOAUTH_LIBRARIES NAMES kqoauth kqoauth0
-    HINTS ${PC_QTKOAUTH_LIBDIR} ${PC_QTKOAUTH_LIBRARIES_DIRS}
-  )
-
-  find_path(QTKOAUTH_INCLUDE_DIR kqoauthmanager.h
-    HINTS ${PC_QTKOAUTH_INCLUDEDIR} ${PC_QTKOAUTH_INCLUDE_DIRS}
-    PATH_SUFFIXES QtKOAuth
-  )
-
-  include(FindPackageHandleStandardArgs)
-  find_package_handle_standard_args(QtKOAuth DEFAULT_MSG QTKOAUTH_LIBRARIES QTKOAUTH_INCLUDE_DIR)
-
-  mark_as_advanced(QTKOAUTH_INCLUDE_DIR QTKOAUTH_LIBRARIES)
-endif (QTKOAUTH_INCLUDE_DIR AND QTKOAUTH_LIBRARIES)
diff --git a/common/libkipiplugins/CMakeLists.txt b/common/libkipiplugins/CMakeLists.txt
index 3858d7d..fbcdae2 100644
--- a/common/libkipiplugins/CMakeLists.txt
+++ b/common/libkipiplugins/CMakeLists.txt
@@ -31,7 +31,43 @@ set(kipiplugins_LIB_SRCS ${CMAKE_CURRENT_SOURCE_DIR}/tools/kipiplugins_debug.cpp
                          ${libkipipluginsresources_SRCS}
 )
 
-add_library(KF5kipiplugins SHARED ${kipiplugins_LIB_SRCS})
+# The o2 library does not adhere to the flags we use
+remove_definitions(
+    -DQT_NO_CAST_FROM_ASCII
+    -DQT_NO_CAST_TO_ASCII
+    -DQT_NO_URL_CAST_FROM_STRING
+    -DQT_NO_CAST_FROM_BYTEARRAY)
+# It also does not export symbols, so export all by default
+unset(CMAKE_CXX_VISIBILITY_PRESET)
+
+# Copied from o2/src/CMakeLists.txt
+set(CMAKE_AUTOMOC ON)
+set(CMAKE_INCLUDE_CURRENT_DIR ON)
+set(o2_SRCS
+    ${CMAKE_CURRENT_SOURCE_DIR}/o2/src/o2.cpp
+    ${CMAKE_CURRENT_SOURCE_DIR}/o2/src/o2reply.cpp
+    ${CMAKE_CURRENT_SOURCE_DIR}/o2/src/o2replyserver.cpp
+    ${CMAKE_CURRENT_SOURCE_DIR}/o2/src/o2requestor.cpp
+    ${CMAKE_CURRENT_SOURCE_DIR}/o2/src/o2simplecrypt.cpp
+    ${CMAKE_CURRENT_SOURCE_DIR}/o2/src/o0settingsstore.cpp
+    ${CMAKE_CURRENT_SOURCE_DIR}/o2/src/o0baseauth.cpp
+    ${CMAKE_CURRENT_SOURCE_DIR}/o2/src/o0abstractstore.h
+    ${CMAKE_CURRENT_SOURCE_DIR}/o2/src/o0globals.h
+    # Enable when needed
+    #${CMAKE_CURRENT_SOURCE_DIR}/o2/src/o1.cpp
+    #${CMAKE_CURRENT_SOURCE_DIR}/o2/src/o1requestor.cpp
+    #${CMAKE_CURRENT_SOURCE_DIR}/o2/src/o1timedreply.cpp
+    #${CMAKE_CURRENT_SOURCE_DIR}/o2/src/o1twitter.h
+    #${CMAKE_CURRENT_SOURCE_DIR}/o2/src/oxtwitter.cpp
+    #${CMAKE_CURRENT_SOURCE_DIR}/o2/src/o1dropbox.h
+    #${CMAKE_CURRENT_SOURCE_DIR}/o2/src/o2gft.cpp
+    #${CMAKE_CURRENT_SOURCE_DIR}/o2/src/o2facebook.cpp
+    #${CMAKE_CURRENT_SOURCE_DIR}/o2/src/o2skydrive.cpp
+    #${CMAKE_CURRENT_SOURCE_DIR}/o2/src/o1flickr.h
+    #${CMAKE_CURRENT_SOURCE_DIR}/o2/src/o2hubic.cpp
+)
+
+add_library(KF5kipiplugins SHARED ${kipiplugins_LIB_SRCS} ${o2_SRCS})
 add_dependencies(KF5kipiplugins kipiplugins-gitversion)
 
 generate_export_header(KF5kipiplugins BASE_NAME kipiplugins EXPORT_MACRO_NAME KIPIPLUGINS_EXPORT)
@@ -40,6 +76,7 @@ target_link_libraries(KF5kipiplugins
 
                       PUBLIC
                       Qt5::Gui
+                      Qt5::Network
 
                       PRIVATE
 
diff --git a/common/libkipiplugins/o2/.gitignore b/common/libkipiplugins/o2/.gitignore
new file mode 100644
index 0000000..f664059
--- /dev/null
+++ b/common/libkipiplugins/o2/.gitignore
@@ -0,0 +1,2 @@
+*CMakeLists.txt.user
+_build/
diff --git a/common/libkipiplugins/o2/CHANGES.md b/common/libkipiplugins/o2/CHANGES.md
new file mode 100644
index 0000000..601ed4e
--- /dev/null
+++ b/common/libkipiplugins/o2/CHANGES.md
@@ -0,0 +1,16 @@
+# Change Log
+
+## 1.0.0
+
+* O1 and O2 to share a common base class
+* Move common classes to the O0 name space
+* Cleanups and bug fixes
+
+## 0.1.0
+
+* Add Sialis, a Qt Quick Twitter demo client
+* Cleanups and bug fixes
+
+## Pre-0.1.0
+
+* Initial non-release
diff --git a/common/libkipiplugins/o2/CMakeLists.txt b/common/libkipiplugins/o2/CMakeLists.txt
new file mode 100644
index 0000000..d8a6952
--- /dev/null
+++ b/common/libkipiplugins/o2/CMakeLists.txt
@@ -0,0 +1,31 @@
+cmake_minimum_required(VERSION 2.8.11)
+
+project(o2)
+
+option(o2_WITH_QT5 "Use Qt5" ON)
+
+option(o2_SHOW_TRACE "Show debugging messages" OFF)
+if(NOT o2_SHOW_TRACE)
+  add_definitions(-DQT_NO_DEBUG_OUTPUT=1)
+endif()
+
+option(o2_WITH_TWITTER "Authenticate with Twitter" OFF)
+option(o2_WITH_DROPBOX "Authenticate with Dropbox" OFF)
+option(o2_WITH_GOOGLE "Authenticate with Google" OFF)
+option(o2_WITH_FACEBOOK "Authenticate with Facebook" OFF)
+option(o2_WITH_SKYDRIVE "Authenticate with SkyDrive" OFF)
+option(o2_WITH_FLICKR "Authenticate with Flickr" OFF)
+option(o2_WITH_HUBIC "Authenticate with Hubic" OFF)
+
+option(o2_WITH_OAUTH1 "Include OAuth1 authentication" OFF)
+if(o2_WITH_TWITTER OR o2_WITH_DROPBOX OR o2_WITH_FLICKR)
+  set(o2_WITH_OAUTH1 ON)
+endif()
+
+option(o2_BUILD_EXAMPLES "Build examples" OFF)
+
+add_subdirectory(src)
+
+if(o2_BUILD_EXAMPLES)
+  add_subdirectory(examples)
+endif(o2_BUILD_EXAMPLES)
diff --git a/common/libkipiplugins/o2/LICENSE b/common/libkipiplugins/o2/LICENSE
new file mode 100644
index 0000000..2984e7a
--- /dev/null
+++ b/common/libkipiplugins/o2/LICENSE
@@ -0,0 +1,23 @@
+Copyright (c) 2012, Akos Polster
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without 
+modification, are permitted provided that the following conditions are met:
+
+ * Redistributions of source code must retain the above copyright notice, this
+list of conditions and the following disclaimer.
+
+ * Redistributions in binary form must reproduce the above copyright notice, 
+this list of conditions and the following disclaimer in the documentation 
+and/or other materials provided with the distribution.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
+CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
+OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/common/libkipiplugins/o2/README.md b/common/libkipiplugins/o2/README.md
new file mode 100644
index 0000000..bafc14b
--- /dev/null
+++ b/common/libkipiplugins/o2/README.md
@@ -0,0 +1,212 @@
+# OAuth 1.0 and 2.0 for Qt
+
+This library encapsulates the OAuth 1.0 and 2.0 client authentication flows, and the sending of authenticated HTTP requests.
+
+The primary target is Qt Quick applications on embedded devices.
+
+Notes to contributors:
+
+   * Please follow the coding style of the existing source
+   * Code contributions are released under Simplified BSD License, as specified in LICENSE. Do not contribute if this license does not suit your code
+
+## Classes
+
+Class | Header | Purpose
+:-- | :-- | :--
+O0AbstractStore | o0abstractstore.h | Base class of persistent stores
+O0BaseAuth | o0baseauth.h | Base class of OAuth authenticators
+O0SettingsStore | o2settingsstore.h | QSettings-based persistent store
+O0SimpleCrypt | o0simplecrypt.h | Simple encryption and decryption by Andre Somers
+O1 | o1.h | Generic OAuth 1.0 authenticator
+O1Dropbox | o1dropbox.h | Dropbox OAuth specialization
+O1Flickr | o1flickr.h | Flickr OAuth specialization
+O1Freshbooks | o1freshbooks.h | Freshbooks OAuth specialization
+O1Requestor | o1requestor.h | Makes authenticated OAuth 1.0 requests: GET, POST or PUT, handles timeouts
+O1RequestParameter | o1.h | An extra request parameter participating in request signing
+O1Twitter | o1twitter.h | Twitter OAuth specialization
+O2 | o2.h | Generic OAuth 2.0 authenticator
+O2Facebook | o2facebook.h | Facebook OAuth specialization
+O2Gft | o2gft.h | Google Fusion Tables OAuth specialization
+O2Hubic | o2hubic.h | Hubic OAuth specialization
+O2Reply | o2reply.h | A network request/reply that can time out
+O2ReplyServer | o2replyserver.h | HTTP server to process authentication responses
+O2Requestor | o2requestor.h | Makes authenticated OAuth 2.0 requests (GET, POST or PUT), handles timeouts and token expiry
+O2Skydrive | o2skydrive.h | OneDrive OAuth specialization
+O2SurveyMonkey | o2surveymonkey.h | SurveyMonkey OAuth specialization
+OXTwitter | oxtwitter.h | Twitter XAuth specialization
+
+## Installation
+
+Clone the Github repository, then add all files in *src* to your Qt project, by including *src/src.pri*.
+
+## Basic Usage
+
+This example assumes a hypothetical Twitter client that will post tweets. Twitter is using OAuth 1.0.
+
+### Setup
+
+Include the required header files, and have some member variables that will be used for authentication and sending requests:
+
+    #include "o1twitter.h"
+    #include "o1requestor.h"
+    O1Twitter *o1;
+
+### Initialization
+
+Instantiate one of the authenticator classes, like O1Twitter, set your application ID and application secret, and install the signal handlers:
+
+    o1 = new O1Twitter(this);
+    o1->setClientId(MY_CLIENT_ID);
+    o1->setClientSecret(MY_CLIENT_SECRET);
+    connect(o1, SIGNAL(linkedChanged()), this, SLOT(onLinkedChanged()));
+    connect(o1, SIGNAL(linkingFailed()), this, SLOT(onLinkingFailed()));
+    connect(o1, SIGNAL(linkingSucceeded()), this, SLOT(onLinkingSucceeded()));
+    connect(o1, SIGNAL(openBrowser(QUrl)), this, SLOT(onOpenBrowser(QUrl)));
+    connect(o1, SIGNAL(closeBrowser()), this, SLOT(onCloseBrowser()));
+
+**Note:** For browserless Twitter authentication, you can use the OXTwitter specialized class which can do Twitter XAuth. You will need to additionally provide your Twitter login credentials (username & password) before calling *link()*.
+
+### Handling Signals
+
+O2 is an asynchronous library. It will send signals at various stages of authentication and request processing.
+
+To handle these signals, implement the following slots in your code:
+
+    void onLinkedChanged() {
+        // Linking (login) state has changed.
+        // Use o1->linked() to get the actual state
+    }
+
+    void onLinkingFailed() {
+        // Login has failed
+    }
+
+    void onLinkingSucceeded() {
+        // Login has succeeded
+    }
+
+    void onOpenBrowser(const QUrl *url) {
+        // Open a web browser or a web view with the given URL.
+        // The user will interact with this browser window to
+        // enter login name, password, and authorize your application
+        // to access the Twitter account
+    }
+
+    void onCloseBrowser() {
+        // Close the browser window opened in openBrowser()
+    }
+
+### Logging In
+
+To log in (e.g. to link your application to the OAuth service), call the link() method:
+
+    o1->link();
+
+This initiates the authentication sequence. Your signal handlers above will be called at various stages. Lastly, if linking succeeds, onLinkingSucceeded() will be called.
+
+### Logging Out
+
+To log out, call the unlink() method:
+
+    o1->unlink();
+
+Logging out always succeeds, and requires no user interaction.
+
+### Sending Authenticated Requests
+
+Once linked, you can start sending authenticated requests to the service. We start with a simple example of sending a text-only tweet or as it's known in Twitter docs, a 'status update'.
+
+First we need a Qt network manager and an O1 requestor object:
+
+    QNetworkAccessManager *manager = new QNetworkAccessManager(this);
+    O1Requestor *requestor = new O1Requestor(manager, o1, this);
+
+Next, create parameters for posting the update:
+
+    QByteArray paramName("status");
+    QByteArray tweetText("My first tweet!");
+
+    QList<O1RequestParameter> requestParams = QList<O1RequestParameter>();
+    requestParams << O1RequestParameter(paramName, tweetText);
+
+    QByteArray postData = O1::createQueryParams(requestParams);
+
+    // Using Twitter's REST API ver 1.1
+    QUrl url = QUrl("https://api.twitter.com/1.1/statuses/update.json");
+
+    QNetworkRequest request(url);
+    request.setHeader(QNetworkRequest::ContentTypeHeader, O2_MIME_TYPE_XFORM);
+
+Finally we authenticate and send the request using the O1 requestor object:
+
+    QNetworkReply *reply = requestor->post(request, reqestParams, postData);
+
+Continuing with the example, we will now send a tweet containing an image as well as a message.
+
+We create an HTTP request containing the image and the message, in the format specified by Twitter:
+
+    QString imagePath("/tmp/image.jpg");
+    QString message("My tweet with an image!");
+
+    QFileInfo fileInfo(imagePath);
+    QFile file(imagePath);
+    file.open(QIODevice::ReadOnly);
+
+    QString boundary("7d44e178b0439");
+    QByteArray data(QString("--" + boundary + "\r\n").toAscii());
+    data += "Content-Disposition: form-data; name=\"media[]\"; filename=\"" + fileInfo.fileName() + "\"\r\n";
+    data += "Content-Transfer-Encoding: binary\r\n";
+    data += "Content-Type: application/octet-stream\r\n\r\n";
+    data += file.readAll();
+    file.close();
+    data += QString("\r\n--") + boundary + "\r\n";
+    data += "Content-Disposition: form-data; name=\"status\"\r\n";
+    data += "Content-Transfer-Encoding: binary\r\n";
+    data += "Content-Type: text/plain; charset=utf-8\r\n\r\n";
+    data += message.toUtf8();
+    data += QString("\r\n--") + boundary + "--\r\n";
+
+    QNetworkRequest request;
+    // Using Twitter's REST API ver 1.1
+    request.setUrl(QUrl("https://api.twitter.com/1.1/statuses/update_with_media.json"));
+    request.setHeader(QNetworkRequest::ContentTypeHeader, "multipart/form-data; boundary=" + boundary);
+    request.setHeader(QNetworkRequest::ContentLengthHeader, data.length());
+
+    QNetworkReply *reply = requestor->post(request, QList<O1RequestParameter>(), data);
+
+That's it. Tweets using the O2 library!
+
+### Storing OAuth Tokens
+
+O2 provides simple storage classes for writing OAuth tokens in a peristent location. Currently, a QSettings based backing store **O2SettingsStore** is provided in O2. O2SettingsStore keeps all token values in an encrypted form. You have to specify the encryption key to use while constructing the object:
+
+    O0SettingsStore settings = new O0SettingsStore("myencryptionkey");
+    // Set the store before starting OAuth, i.e before calling link()
+    o1->setStore(settings);
+    ...
+
+You can also create it with your customized QSettings object. O2SettingsStore will then use that QSettings object for storing the tokens:
+
+    O0SettingsStore settings = new O0SettingsStore(mySettingsObject, "myencryptionkey");
+
+Once set, O2SettingsStore takes ownership of the QSettings object.
+
+**Note:** If you do not specify a storage object to use, O2 will create one by default (which QSettings based), and use it. In such a case, a default encryption key is used for encrypting the data.
+
+### Extra OAuth Tokens
+
+Some OAuth service providers provide additional information in the access token response. Eg: Twitter returns 2 additional tokens in it's access token response - *screen_name* and *user_id*.
+
+O2 provides all such tokens via the property - *extraTokens*. You can query this property after a successful OAuth exchange, i.e after the *linkingSucceeded()* signal has been emitted.
+
+## More Examples
+
+The *examples* folder contains complete example applications:
+
+Name | Description
+:-- | :--
+facebookdemo | Command line application authenticating with Facebook
+sialis | QT Quick Twitter client using OAuth 1
+twitterdemo | Command line client for authenticating with Twitter and posting status updates. Uses OAuth 1 or Twitter XAuth
+
+
diff --git a/common/libkipiplugins/o2/acknowledgements.md b/common/libkipiplugins/o2/acknowledgements.md
new file mode 100644
index 0000000..fe99b6c
--- /dev/null
+++ b/common/libkipiplugins/o2/acknowledgements.md
@@ -0,0 +1,57 @@
+# SimpleCrypt by Andre Somers
+
+Cryptographic methods for Qt.
+
+> Copyright (c) 2011, Andre Somers
+> All rights reserved.
+> 
+> Redistribution and use in source and binary forms, with or without
+> modification, are permitted provided that the following conditions are met:
+> 
+>    * Redistributions of source code must retain the above copyright
+>      notice, this list of conditions and the following disclaimer.
+>    * Redistributions in binary form must reproduce the above copyright
+>      notice, this list of conditions and the following disclaimer in the
+>      documentation and/or other materials provided with the distribution.
+>    * Neither the name of the Rathenau Instituut, Andre Somers nor the
+>      names of its contributors may be used to endorse or promote products
+>      derived from this software without specific prior written permission.
+> 
+> THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+> ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+> WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+> DISCLAIMED. IN NO EVENT SHALL ANDRE SOMERS BE LIABLE FOR ANY
+> DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+> (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+> LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+> ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+> (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+> SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+# Mandeep Sandhu <mandeepsandhu.chd@gmail.com>
+
+Configurable settings storage, Twitter XAuth specialization, new demos, cleanups.
+
+> "Hi Akos,
+> 
+> I'm writing this mail to confirm that my contributions to the O2 library, available here https://github.com/pipacs/o2, can be freely distributed according to the project's license (as shown in the LICENSE file).
+> 
+> Regards,
+> -mandeep"
+
+# Sergey Gavrushkin <https://github.com/ncux>
+
+FreshBooks specialization
+
+# Theofilos Intzoglou <https://github.com/parapente>
+
+Hubic specialization
+
+# Dimitar
+
+SurveyMonkey specialization
+
+# David Brooks <https://github.com/dbrnz>
+
+CMake related fixes and improvements.
+
diff --git a/common/libkipiplugins/o2/examples/.gitignore b/common/libkipiplugins/o2/examples/.gitignore
new file mode 100644
index 0000000..da1c502
--- /dev/null
+++ b/common/libkipiplugins/o2/examples/.gitignore
@@ -0,0 +1,6 @@
+*.pro.user
+build*
+*.o
+*.moc
+moc_*
+Makefile
diff --git a/common/libkipiplugins/o2/examples/CMakeLists.txt b/common/libkipiplugins/o2/examples/CMakeLists.txt
new file mode 100644
index 0000000..c229610
--- /dev/null
+++ b/common/libkipiplugins/o2/examples/CMakeLists.txt
@@ -0,0 +1,9 @@
+cmake_minimum_required(VERSION 2.8.11)
+
+if(o2_WITH_FACEBOOK)
+    add_subdirectory(facebookdemo)
+endif(o2_WITH_FACEBOOK)
+
+if(o2_WITH_TWITTER)
+    add_subdirectory(twitterdemo)
+endif(o2_WITH_TWITTER)
diff --git a/common/libkipiplugins/o2/examples/facebookdemo/CMakeLists.txt b/common/libkipiplugins/o2/examples/facebookdemo/CMakeLists.txt
new file mode 100644
index 0000000..afc3d27
--- /dev/null
+++ b/common/libkipiplugins/o2/examples/facebookdemo/CMakeLists.txt
@@ -0,0 +1,43 @@
+cmake_minimum_required(VERSION 2.8.11)
+
+project( fbexample )
+
+set(CMAKE_AUTOMOC ON)
+set(CMAKE_INCLUDE_CURRENT_DIR ON)
+set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall")
+
+if(o2_WITH_QT5)
+    # Qt5 packages find their own dependencies.
+    find_package(Qt5Core    REQUIRED)
+    find_package(Qt5Widgets REQUIRED)
+    find_package(Qt5Script  REQUIRED)
+    find_package(Qt5Network REQUIRED)
+else(o2_WITH_QT5)
+    set(QT_USE_QTNETWORK true)
+    set(QT_USE_QTSCRIPT true)
+    find_package(Qt4 REQUIRED)
+endif(o2_WITH_QT5)
+
+if (NOT o2_WITH_QT5)
+    include( ${QT_USE_FILE} )
+endif(NOT o2_WITH_QT5)
+
+include_directories(${CMAKE_SOURCE_DIR} ${CMAKE_BINARY_DIR} "../../src" )
+
+set(fb_SRCS
+    main.cpp
+    fbdemo.cpp
+)
+
+if(NOT o2_WITH_QT5)
+    add_definitions(${QT4_DEFINITIONS})
+endif(NOT o2_WITH_QT5)
+
+add_executable( fbexample ${fb_SRCS} )
+
+if(o2_WITH_QT5)
+    qt5_use_modules( fbexample Core Widgets Network )
+    target_link_libraries( fbexample o2 )
+else(o2_WITH_QT5)
+    target_link_libraries( fbexample ${QT_LIBRARIES} o2 )
+endif(o2_WITH_QT5)
diff --git a/common/libkipiplugins/o2/examples/facebookdemo/facebookdemo.pro b/common/libkipiplugins/o2/examples/facebookdemo/facebookdemo.pro
new file mode 100644
index 0000000..31f9437
--- /dev/null
+++ b/common/libkipiplugins/o2/examples/facebookdemo/facebookdemo.pro
@@ -0,0 +1,16 @@
+QT       += core gui
+
+greaterThan(QT_MAJOR_VERSION, 4) {
+    QT += widgets
+}
+
+include(../../src/src.pri)
+
+TARGET = facebookdemo
+TEMPLATE = app
+
+SOURCES += main.cpp \
+    fbdemo.cpp
+
+HEADERS += \
+    fbdemo.h
diff --git a/common/libkipiplugins/o2/examples/facebookdemo/fbdemo.cpp b/common/libkipiplugins/o2/examples/facebookdemo/fbdemo.cpp
new file mode 100644
index 0000000..b41ab14
--- /dev/null
+++ b/common/libkipiplugins/o2/examples/facebookdemo/fbdemo.cpp
@@ -0,0 +1,119 @@
+#include <QNetworkAccessManager>
+#include <QNetworkRequest>
+#include <QNetworkReply>
+#include <QDesktopServices>
+#include <QMetaEnum>
+#include <QDebug>
+
+#include "fbdemo.h"
+#include "o0globals.h"
+#include "o0settingsstore.h"
+
+const char FB_APP_KEY[] = "227896037359072";
+const char FB_APP_SECRET[] = "3d35b063872579cf7213e09e76b65ceb";
+
+const char FB_REQUEST_URL[] = "https://www.facebook.com/dialog/oauth";
+const char FB_DEBUG_TOKEN[] = "https://graph.facebook.com/me?fields=id&access_token=%1";
+
+const int localPort = 8888;
+
+#define QENUM_NAME(o,e,v) (o::staticMetaObject.enumerator(o::staticMetaObject.indexOfEnumerator(#e)).valueToKey((v)))
+#define GRANTFLOW_STR(v) QString(QENUM_NAME(O2, GrantFlow, v))
+
+FBDemo::FBDemo(QObject *parent) :
+    QObject(parent) {
+    o2Facebook_ = new O2Facebook(this);
+
+    o2Facebook_->setClientId(FB_APP_KEY);
+    o2Facebook_->setClientSecret(FB_APP_SECRET);
+    o2Facebook_->setLocalPort(localPort);
+    o2Facebook_->setRequestUrl(FB_REQUEST_URL);  // Use the desktop login UI
+
+    // Create a store object for writing the received tokens
+    O0SettingsStore *store = new O0SettingsStore(O2_ENCRYPTION_KEY);
+    store->setGroupKey("facebook");
+    o2Facebook_->setStore(store);
+
+    connect(o2Facebook_, SIGNAL(linkedChanged()), this, SLOT(onLinkedChanged()));
+    connect(o2Facebook_, SIGNAL(linkingFailed()), this, SIGNAL(linkingFailed()));
+    connect(o2Facebook_, SIGNAL(linkingSucceeded()), this, SLOT(onLinkingSucceeded()));
+    connect(o2Facebook_, SIGNAL(openBrowser(QUrl)), this, SLOT(onOpenBrowser(QUrl)));
+    connect(o2Facebook_, SIGNAL(closeBrowser()), this, SLOT(onCloseBrowser()));
+}
+
+void FBDemo::doOAuth(O2::GrantFlow grantFlowType) {
+    qDebug() << "Starting OAuth 2 with grant flow type" << GRANTFLOW_STR(grantFlowType) << "...";
+    o2Facebook_->setGrantFlow(grantFlowType);
+    o2Facebook_->unlink();
+    o2Facebook_->link();
+}
+
+void FBDemo::validateToken() {
+    if (!o2Facebook_->linked()) {
+        qWarning() << "ERROR: Application is not linked!";
+        emit linkingFailed();
+        return;
+    }
+
+    QString accessToken = o2Facebook_->token();
+    QString debugUrlStr = QString(FB_DEBUG_TOKEN).arg(accessToken);
+    QNetworkRequest request = QNetworkRequest(QUrl(debugUrlStr));
+    QNetworkAccessManager *mgr = new QNetworkAccessManager(this);
+    QNetworkReply *reply = mgr->get(request);
+    connect(reply, SIGNAL(finished()), this, SLOT(onFinished()));
+    qDebug() << "Validating user token. Please wait...";
+}
+
+void FBDemo::onOpenBrowser(const QUrl &url) {
+    QDesktopServices::openUrl(url);
+}
+
+void FBDemo::onCloseBrowser() {
+}
+
+void FBDemo::onLinkedChanged() {
+    qDebug() << "Link changed!";
+}
+
+void FBDemo::onLinkingSucceeded() {
+    O2Facebook *o1t = qobject_cast<O2Facebook *>(sender());
+    if (!o1t->linked()) {
+        return;
+    }
+    QVariantMap extraTokens = o1t->extraTokens();
+    if (!extraTokens.isEmpty()) {
+        emit extraTokensReady(extraTokens);
+        qDebug() << "Extra tokens in response:";
+        foreach (QString key, extraTokens.keys()) {
+            qDebug() << "\t" << key << ":" << (extraTokens.value(key).toString().left(3) + "...");
+        }
+    }
+    emit linkingSucceeded();
+}
+
+void FBDemo::onFinished() {
+    QNetworkReply *reply = qobject_cast<QNetworkReply *>(sender());
+    if (!reply) {
+        qWarning() << "NULL reply!";
+        emit linkingFailed();
+        return;
+    }
+
+    reply->deleteLater();
+    if (reply->error() != QNetworkReply::NoError) {
+        qWarning() << "Reply error:" << reply->error();
+        qWarning() << "Reason:" << reply->errorString();
+        emit linkingFailed();
+        return;
+    }
+
+    QByteArray replyData = reply->readAll();
+    bool valid = !replyData.contains("error");
+    if (valid) {
+        qDebug() << "Token is valid";
+        emit linkingSucceeded();
+    } else {
+        qDebug() << "Token is invalid";
+        emit linkingFailed();
+    }
+}
diff --git a/common/libkipiplugins/o2/examples/facebookdemo/fbdemo.h b/common/libkipiplugins/o2/examples/facebookdemo/fbdemo.h
new file mode 100644
index 0000000..054e006
--- /dev/null
+++ b/common/libkipiplugins/o2/examples/facebookdemo/fbdemo.h
@@ -0,0 +1,35 @@
+#ifndef FBDEMO_H
+#define FBDEMO_H
+
+#include <QObject>
+
+#include "o2facebook.h"
+
+class FBDemo : public QObject
+{
+    Q_OBJECT
+
+public:
+    explicit FBDemo(QObject *parent = 0);
+
+signals:
+    void extraTokensReady(const QVariantMap &extraTokens);
+    void linkingFailed();
+    void linkingSucceeded();
+
+public slots:
+    void doOAuth(O2::GrantFlow grantFlowType);
+    void validateToken();
+
+private slots:
+    void onLinkedChanged();
+    void onLinkingSucceeded();
+    void onOpenBrowser(const QUrl &url);
+    void onCloseBrowser();
+    void onFinished();
+
+private:
+    O2Facebook *o2Facebook_;
+};
+
+#endif // FBDEMO_H
diff --git a/common/libkipiplugins/o2/examples/facebookdemo/main.cpp b/common/libkipiplugins/o2/examples/facebookdemo/main.cpp
new file mode 100644
index 0000000..26f0ed1
--- /dev/null
+++ b/common/libkipiplugins/o2/examples/facebookdemo/main.cpp
@@ -0,0 +1,71 @@
+#include <QApplication>
+#include <QStringList>
+#include <QTimer>
+#include <QDebug>
+
+#include "fbdemo.h"
+
+const char OPT_OAUTH_CODE[] = "-o";
+const char OPT_VALIDATE_TOKEN[] = "-v";
+
+const char USAGE[] = "\n"
+                     "Usage: facebookdemo [OPTION]...\n"
+                     "Get OAuth2 access tokens from Facebook's OAuth service\n"
+                     "\nOptions:\n"
+                     "  %1\t\tLink with Facebook OAuth2 service using Authorization Code\n"
+                     "  %2\t\tValidate Access Token\n";
+
+
+class Helper : public QObject {
+    Q_OBJECT
+
+public:
+    Helper() : QObject(), fbdemo_(this), waitForMsg_(false), msg_(QString()) {}
+
+public slots:
+    void processArgs() {
+        QStringList argList = qApp->arguments();
+        QByteArray help = QString(USAGE).arg(OPT_OAUTH_CODE,
+                                             OPT_VALIDATE_TOKEN).toLatin1();
+        const char* helpText = help.constData();
+        connect(&fbdemo_, SIGNAL(linkingFailed()), this, SLOT(onLinkingFailed()));
+        connect(&fbdemo_, SIGNAL(linkingSucceeded()), this, SLOT(onLinkingSucceeded()));
+        if (argList.contains(OPT_OAUTH_CODE)) {
+            // Start OAuth
+            fbdemo_.doOAuth(O2::GrantFlowAuthorizationCode);
+        } else if (argList.contains(OPT_VALIDATE_TOKEN)) {
+            fbdemo_.validateToken();
+        } else {
+            qDebug() << helpText;
+            qApp->exit(1);
+        }
+    }
+
+    void onLinkingFailed() {
+        qDebug() << "Linking failed!";
+        qApp->exit(1);
+    }
+
+    void onLinkingSucceeded() {
+        qDebug() << "Linking succeeded!";
+        if (waitForMsg_) {
+            //postStatusUpdate(msg_);
+        } else {
+            qApp->quit();
+        }
+    }
+
+private:
+    FBDemo fbdemo_;
+    bool waitForMsg_;
+    QString msg_;
+};
+
+int main(int argc, char *argv[]) {
+    QApplication a(argc, argv);
+    Helper helper;
+    QTimer::singleShot(0, &helper, SLOT(processArgs()));
+    return a.exec();
+}
+
+#include "main.moc"
diff --git a/common/libkipiplugins/o2/examples/sialis/.gitignore b/common/libkipiplugins/o2/examples/sialis/.gitignore
new file mode 100644
index 0000000..fab7372
--- /dev/null
+++ b/common/libkipiplugins/o2/examples/sialis/.gitignore
@@ -0,0 +1,73 @@
+# This file is used to ignore files which are generated
+# ----------------------------------------------------------------------------
+
+*~
+*.autosave
+*.a
+*.core
+*.moc
+*.o
+*.obj
+*.orig
+*.rej
+*.so
+*.so.*
+*_pch.h.cpp
+*_resource.rc
+*.qm
+.#*
+*.*#
+core
+!core/
+tags
+.DS_Store
+.directory
+*.debug
+Makefile*
+*.prl
+*.app
+moc_*.cpp
+ui_*.h
+qrc_*.cpp
+Thumbs.db
+*.res
+*.rc
+/.qmake.cache
+/.qmake.stash
+
+# qtcreator generated files
+*.pro.user*
+
+# xemacs temporary files
+*.flc
+
+# Vim temporary files
+.*.swp
+
+# Visual Studio generated files
+*.ib_pdb_index
+*.idb
+*.ilk
+*.pdb
+*.sln
+*.suo
+*.vcproj
+*vcproj.*.*.user
+*.ncb
+*.sdf
+*.opensdf
+*.vcxproj
+*vcxproj.*
+
+# MinGW generated files
+*.Debug
+*.Release
+
+# Python byte code
+*.pyc
+
+# Binaries
+# --------
+*.dll
+*.exe
+
diff --git a/common/libkipiplugins/o2/examples/sialis/README.md b/common/libkipiplugins/o2/examples/sialis/README.md
new file mode 100644
index 0000000..892a610
--- /dev/null
+++ b/common/libkipiplugins/o2/examples/sialis/README.md
@@ -0,0 +1,5 @@
+# Sialis
+
+Twitter demo for O2, demonstrating authenticating with Twitter and signing requests in order to show tweets.
+
+
diff --git a/common/libkipiplugins/o2/examples/sialis/main.cpp b/common/libkipiplugins/o2/examples/sialis/main.cpp
new file mode 100644
index 0000000..8e3eef9
--- /dev/null
+++ b/common/libkipiplugins/o2/examples/sialis/main.cpp
@@ -0,0 +1,19 @@
+#include <QGuiApplication>
+#include <QQmlApplicationEngine>
+#include <QtQml>
+#include <QtWebView/QtWebView>
+
+#include "o1.h"
+#include "o1twitter.h"
+#include "o1requestor.h"
+#include "twitterapi.h"
+
+int main(int argc, char *argv[]) {
+    QGuiApplication app(argc, argv);
+    QtWebView::initialize();
+    qmlRegisterType<O1Twitter>("com.pipacs.o2", 1, 0, "O1Twitter");
+    qmlRegisterType<TwitterApi>("com.pipacs.o2", 1, 0, "TwitterApi");
+    QQmlApplicationEngine engine;
+    engine.load(QUrl(QStringLiteral("qrc:/main.qml")));
+    return app.exec();
+}
diff --git a/common/libkipiplugins/o2/examples/sialis/main.qml b/common/libkipiplugins/o2/examples/sialis/main.qml
new file mode 100644
index 0000000..4e3ae65
--- /dev/null
+++ b/common/libkipiplugins/o2/examples/sialis/main.qml
@@ -0,0 +1,128 @@
+import QtQuick 2.3
+import QtQuick.Controls 1.4
+import QtWebView 1.1
+import com.pipacs.o2 1.0
+
+ApplicationWindow {
+    id: app
+    visible: true
+    title: "Sialis"
+    minimumWidth: 300
+    minimumHeight: 200
+    height: 700
+
+    O1Twitter {
+        id: o1Twitter
+        clientId: "2vHeyIxjywIadjEhvbDpg"
+        clientSecret: "Xfwe195Kp3ZpcCKgkYs7RKfugTm8EfpLkQvsKfX2vvs"
+
+        onOpenBrowser: {
+            browser.url = url
+            browser.visible = true
+        }
+
+        onCloseBrowser: {
+            browser.visible = false
+        }
+
+        onLinkedChanged: {
+            loginButton.enabled = true
+            twitterApi.requestTweets()
+        }
+    }
+
+    TwitterApi {
+        id: twitterApi
+        authenticator: o1Twitter
+    }
+
+    statusBar: StatusBar {
+        Label {
+            anchors.left: parent.left
+            anchors.verticalCenter: parent.verticalCenter
+            text: o1Twitter.linked? ("Logged in as " + o1Twitter.extraTokens["screen_name"]): "Not logged in"
+        }
+
+        Button {
+            id: loginButton
+            anchors.right: parent.right
+            anchors.verticalCenter: parent.verticalCenter
+            text: o1Twitter.linked? "Logout": "Login"
+            onClicked: {
+                enabled = false
+                if (o1Twitter.linked) {
+                    o1Twitter.unlink()
+                } else {
+                    o1Twitter.link()
+                }
+            }
+        }
+
+        height: loginButton.height + 5
+    }
+
+    ListView {
+        id: listView
+        anchors.fill: parent
+        model: twitterApi.tweetModel
+        delegate: listDelegate
+        highlight: Rectangle {color: "#10000000"}
+        focus: true
+
+        Component {
+            id: listDelegate
+            Item {
+                width: parent.width
+                height: label.contentHeight + 10
+                Row {
+                    anchors.fill: parent
+                    Label {
+                        id: label
+                        anchors.centerIn: parent
+                        width: parent.width
+                        text: rawText
+                        wrapMode: Text.Wrap
+                    }
+                    Rectangle {
+                        width: parent.width
+                        height: 1
+                        color: "#10000000"
+                        border.color: "transparent"
+                    }
+                }
+                MouseArea {
+                    anchors.fill: parent
+                    onClicked: listView.currentIndex = index
+                }
+            }
+        }
+    }
+
+    ApplicationWindow {
+        id: browser
+        visible: false
+        minimumHeight: 800
+        minimumWidth: 500
+        title: "Login"
+
+        property url url: ""
+
+        WebView {
+            anchors.fill: parent
+            url: browser.url
+        }
+
+        onClosing: {
+            close.accepted = true
+            loginButton.enabled = true
+        }
+    }
+
+    Timer {
+        interval: 30000
+        repeat: true
+        running: true
+        triggeredOnStart: true
+        onTriggered: twitterApi.requestTweets()
+    }
+}
diff --git a/common/libkipiplugins/o2/examples/sialis/qml.qrc b/common/libkipiplugins/o2/examples/sialis/qml.qrc
new file mode 100644
index 0000000..5f6483a
--- /dev/null
+++ b/common/libkipiplugins/o2/examples/sialis/qml.qrc
@@ -0,0 +1,5 @@
+<RCC>
+    <qresource prefix="/">
+        <file>main.qml</file>
+    </qresource>
+</RCC>
diff --git a/common/libkipiplugins/o2/examples/sialis/sialis.icns b/common/libkipiplugins/o2/examples/sialis/sialis.icns
new file mode 100644
index 0000000000000000000000000000000000000000..907e93fabd95d669d4ed445d5b2c786dca9bfe92
GIT binary patch
literal 32370
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
U@UbW&|GxaU1^#V;c3R+n0S#((NdN!<

literal 0
HcmV?d00001

diff --git a/common/libkipiplugins/o2/examples/sialis/sialis.pro b/common/libkipiplugins/o2/examples/sialis/sialis.pro
new file mode 100644
index 0000000..dd149d7
--- /dev/null
+++ b/common/libkipiplugins/o2/examples/sialis/sialis.pro
@@ -0,0 +1,24 @@
+TARGET = Sialis
+TEMPLATE = app
+QT += qml quick webview
+CONFIG += c++11
+SOURCES += main.cpp \
+    twitterapi.cpp \
+    tweetmodel.cpp
+RESOURCES += qml.qrc
+
+# "Bird" icon by snap2objects: http://www.snap2objects.com
+ICON = sialis.icns
+
+# Additional import path used to resolve QML modules in Qt Creator's code model
+QML_IMPORT_PATH =
+
+# Default rules for deployment.
+include(deployment.pri)
+
+# Core O2
+include(../../src/src.pri)
+
+HEADERS += \
+    twitterapi.h \
+    tweetmodel.h
diff --git a/common/libkipiplugins/o2/examples/sialis/tweetmodel.cpp b/common/libkipiplugins/o2/examples/sialis/tweetmodel.cpp
new file mode 100644
index 0000000..cfd577e
--- /dev/null
+++ b/common/libkipiplugins/o2/examples/sialis/tweetmodel.cpp
@@ -0,0 +1,40 @@
+#include <QDebug>
+
+#include "tweetmodel.h"
+
+TweetModel::TweetModel(QObject *parent): QAbstractListModel(parent) {
+}
+
+QHash<int, QByteArray> TweetModel::roleNames() const {
+    QHash<int, QByteArray> roles;
+    roles[RoleText] = "rawText";
+    return roles;
+}
+
+void TweetModel::addTweet(QVariantMap tweet) {
+    beginInsertRows(QModelIndex(), rowCount(), rowCount());
+    tweets.append(tweet);
+    endInsertRows();
+}
+
+void TweetModel::clearTweets() {
+    beginRemoveRows(QModelIndex(), 0, rowCount() - 1);
+    tweets.clear();
+    endRemoveRows();
+}
+
+int TweetModel::rowCount(const QModelIndex &) const {
+    return tweets.count();
+}
+
+QVariant TweetModel::data(const QModelIndex &index, int role) const {
+    QVariant result;
+    QVariantMap tweet = tweets[index.row()];
+    switch (role) {
+    case TweetModel::RoleText:
+        result = tweet["text"];
+    default:
+        result = tweet["text"];
+    }
+    return result;
+}
diff --git a/common/libkipiplugins/o2/examples/sialis/tweetmodel.h b/common/libkipiplugins/o2/examples/sialis/tweetmodel.h
new file mode 100644
index 0000000..441bac7
--- /dev/null
+++ b/common/libkipiplugins/o2/examples/sialis/tweetmodel.h
@@ -0,0 +1,38 @@
+#ifndef TWEETMODEL_H
+#define TWEETMODEL_H
+
+#include <QAbstractListModel>
+#include <QList>
+#include <QVariantMap>
+
+/// List of tweets, suitable as a ListView model
+class TweetModel : public QAbstractListModel {
+    Q_OBJECT
+
+public:
+    enum Roles {
+        RoleText = Qt::UserRole + 1,
+    };
+
+    TweetModel(QObject *parent = 0);
+
+    /// Clear all tweets
+    void clearTweets();
+
+    /// Add a tweet
+    void addTweet(QVariantMap tweet);
+
+    /// Get number of tweets
+    int rowCount(const QModelIndex &parent = QModelIndex()) const;
+
+    /// Access a tweet
+    QVariant data(const QModelIndex & index, int role = Qt::DisplayRole) const;
+
+    /// Get role names
+    QHash<int, QByteArray>roleNames() const;
+
+protected:
+    QList<QVariantMap> tweets;
+};
+
+#endif // TWEETMODEL_H
diff --git a/common/libkipiplugins/o2/examples/sialis/twitterapi.cpp b/common/libkipiplugins/o2/examples/sialis/twitterapi.cpp
new file mode 100644
index 0000000..8083f0d
--- /dev/null
+++ b/common/libkipiplugins/o2/examples/sialis/twitterapi.cpp
@@ -0,0 +1,57 @@
+#include <QJsonArray>
+#include <QJsonDocument>
+#include <QJsonObject>
+
+#include "o1requestor.h"
+
+#include "twitterapi.h"
+
+TwitterApi::TwitterApi(QObject *parent): QObject(parent), authenticator_(0) {
+    manager_ = new QNetworkAccessManager(this);
+    tweetModel_ = new TweetModel(this);
+}
+
+TwitterApi::~TwitterApi() {
+}
+
+TweetModel *TwitterApi::tweetModel() {
+    return tweetModel_;
+}
+
+O1Twitter *TwitterApi::authenticator() const {
+    return authenticator_;
+}
+void TwitterApi::setAuthenticator(O1Twitter *v) {
+    authenticator_ = v;
+}
+
+void TwitterApi::requestTweets() {
+    if (!authenticator_ || !authenticator_->linked()) {
+        tweetModel_->clearTweets();
+        emit tweetModelChanged();
+        return;
+    }
+    O1Requestor *requestor = new O1Requestor(manager_, authenticator_, this);
+    QUrl url = QUrl("https://api.twitter.com/1.1/statuses/home_timeline.json");
+    QNetworkRequest request(url);
+    QNetworkReply *reply = requestor->get(request, QList<O0RequestParameter>());
+    connect(reply, SIGNAL(finished()), this, SLOT(tweetsReceived()));
+    connect(reply, SIGNAL(error(QNetworkReply::NetworkError)), this, SLOT(requestFailed(QNetworkReply::NetworkError)));
+}
+
+void TwitterApi::tweetsReceived() {
+    QNetworkReply *reply = qobject_cast<QNetworkReply *>(sender());
+    QJsonDocument jsonResponse = QJsonDocument::fromJson(reply->readAll());
+    tweetModel_->clearTweets();
+    QJsonArray jsonArray = jsonResponse.array();
+    foreach (const QJsonValue &v, jsonArray) {
+        QVariantMap item = v.toObject().toVariantMap();
+        tweetModel_->addTweet(item);
+    }
+    emit tweetModelChanged();
+}
+
+void TwitterApi::requestFailed(QNetworkReply::NetworkError error) {
+    QNetworkReply *reply = qobject_cast<QNetworkReply *>(sender());
+    qWarning() << "TwitterApi::requestFailed:" << (int)error << reply->errorString() << reply->readAll();
+}
diff --git a/common/libkipiplugins/o2/examples/sialis/twitterapi.h b/common/libkipiplugins/o2/examples/sialis/twitterapi.h
new file mode 100644
index 0000000..325591b
--- /dev/null
+++ b/common/libkipiplugins/o2/examples/sialis/twitterapi.h
@@ -0,0 +1,45 @@
+#ifndef TWITTERAPI_H
+#define TWITTERAPI_H
+
+#include <QAbstractListModel>
+#include <QObject>
+#include <QNetworkAccessManager>
+
+#include "o1twitter.h"
+
+#include "tweetmodel.h"
+
+/// Mini Twitter API
+class TwitterApi: public QObject {
+    Q_OBJECT
+
+public:
+    /// List of tweets
+    Q_PROPERTY(TweetModel *tweetModel READ tweetModel NOTIFY tweetModelChanged)
+    TweetModel *tweetModel() ;
+
+    /// OAuth authenticator
+    Q_PROPERTY(O1Twitter *authenticator READ authenticator WRITE setAuthenticator)
+    O1Twitter *authenticator() const;
+    void setAuthenticator(O1Twitter *v) ;
+
+    explicit TwitterApi(QObject *parent = 0);
+    virtual ~TwitterApi();
+
+public slots:
+    Q_INVOKABLE virtual void requestTweets();
+
+signals:
+    void tweetModelChanged();
+
+protected:
+    O1Twitter *authenticator_;
+    TweetModel *tweetModel_;
+    QNetworkAccessManager *manager_;
+
+protected slots:
+    void tweetsReceived();
+    void requestFailed(QNetworkReply::NetworkError error);
+};
+
+#endif // TWITTERAPI_H
diff --git a/common/libkipiplugins/o2/examples/twitterdemo/CMakeLists.txt b/common/libkipiplugins/o2/examples/twitterdemo/CMakeLists.txt
new file mode 100644
index 0000000..245026e
--- /dev/null
+++ b/common/libkipiplugins/o2/examples/twitterdemo/CMakeLists.txt
@@ -0,0 +1,43 @@
+cmake_minimum_required(VERSION 2.8.11)
+
+project( twitterexample )
+
+set(CMAKE_AUTOMOC ON)
+set(CMAKE_INCLUDE_CURRENT_DIR ON)
+set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall")
+
+if(o2_WITH_QT5)
+    # Qt5 packages find their own dependencies.
+    find_package(Qt5Core    REQUIRED)
+    find_package(Qt5Widgets REQUIRED)
+    find_package(Qt5Script  REQUIRED)
+    find_package(Qt5Network REQUIRED)
+else(o2_WITH_QT5)
+    set(QT_USE_QTNETWORK true)
+    set(QT_USE_QTSCRIPT true)
+    find_package(Qt4 REQUIRED)
+endif(o2_WITH_QT5)
+
+if (NOT o2_WITH_QT5)
+    include( ${QT_USE_FILE} )
+endif(NOT o2_WITH_QT5)
+ 
+include_directories(${CMAKE_SOURCE_DIR} ${CMAKE_BINARY_DIR} "../../src" )
+
+set(fb_SRCS
+    main.cpp
+    tweeter.cpp
+)
+
+if(NOT o2_WITH_QT5)
+    add_definitions(${QT4_DEFINITIONS})
+endif(NOT o2_WITH_QT5)
+
+add_executable( twitterexample ${fb_SRCS} )
+
+if(o2_WITH_QT5)
+    qt5_use_modules( twitterexample Core Widgets Network )
+    target_link_libraries( twitterexample o2 )
+else(o2_WITH_QT5)
+    target_link_libraries( twitterexample ${QT_LIBRARIES} o2 )
+endif(o2_WITH_QT5)
diff --git a/common/libkipiplugins/o2/examples/twitterdemo/main.cpp b/common/libkipiplugins/o2/examples/twitterdemo/main.cpp
new file mode 100644
index 0000000..a1c9a7f
--- /dev/null
+++ b/common/libkipiplugins/o2/examples/twitterdemo/main.cpp
@@ -0,0 +1,111 @@
+#include <QApplication>
+#include <QStringList>
+#include <QTimer>
+#include <QDebug>
+
+#include "tweeter.h"
+
+const char OPT_OAUTH[] = "-o";
+const char OPT_XAUTH[] = "-x";
+const char OPT_USERNAME[] = "-u";
+const char OPT_PASSWORD[] = "-p";
+const char OPT_STATUS[] = "-m";
+
+const char USAGE[] = "\n"
+                     "Usage: tweetdemo [OPTION]...\n"
+                     "Get OAuth access tokens from Twitter's OAuth service and "
+                     "(optionally) post a status update on a user's timeline\n"
+                     "\nOptions:\n"
+                     "  %1\t\tLink with Twitter OAuth service, i.e get access tokens\n"
+                     "  %2\t\tLink with Twitter XAuth service, i.e get access tokens using the XAuth protocol\n"
+                     "  %3 <username>\tTwitter username to be used while using XAuth (-x option)\n"
+                     "  %4 <password>\tTwitter password to be used while using XAuth (-x option)\n"
+                     "  %5\t\tStatus update message, enclosed in double quotes\n";
+
+
+class Helper : public QObject {
+    Q_OBJECT
+
+public:
+    Helper() : QObject(), tweeter_(this), waitForMsg_(false), msg_(QString()) {}
+
+public slots:
+    void processArgs() {
+        QStringList argList = qApp->arguments();
+        QByteArray help = QString(USAGE).arg(OPT_OAUTH,
+                                             OPT_XAUTH,
+                                             OPT_USERNAME,
+                                             OPT_PASSWORD,
+                                             OPT_STATUS).toLatin1();
+        const char *helpText = help.constData();
+        connect(&tweeter_, SIGNAL(linkingFailed()), this, SLOT(onLinkingFailed()));
+        connect(&tweeter_, SIGNAL(linkingSucceeded()), this, SLOT(onLinkingSucceeded()));
+
+        if (argList.contains(OPT_OAUTH)) {
+            if (argList.contains(OPT_STATUS)) {
+                waitForMsg_ = true;
+                msg_ = argList.at(argList.indexOf(OPT_STATUS) + 1);
+            }
+            // Start OAuth
+            tweeter_.doOAuth();
+        } else if (argList.contains(OPT_XAUTH)) {
+            if (!(argList.contains(OPT_USERNAME) && argList.contains(OPT_PASSWORD))) {
+                qDebug() << "\nError: Username or Password missing!";
+                qDebug() << helpText;
+                qApp->exit(1);
+            }
+
+            QString username = argList.at(argList.indexOf(OPT_USERNAME) + 1);
+            QString password = argList.at(argList.indexOf(OPT_PASSWORD) + 1);
+
+            if (argList.contains(OPT_STATUS)) {
+                waitForMsg_ = true;
+                msg_ = argList.at(argList.indexOf(OPT_STATUS) + 1);
+            }
+            // Start XAuth
+            tweeter_.doXAuth(username, password);
+        } else if (argList.contains(OPT_STATUS)) {
+            QString statusMessage = argList.at(argList.indexOf(OPT_STATUS) + 1);
+            postStatusUpdate(statusMessage);
+        } else {
+            qDebug() << helpText;
+            qApp->exit(1);
+        }
+    }
+
+    void onLinkingFailed() {
+        qDebug() << "Linking failed!";
+        qApp->exit(1);
+    }
+
+    void onLinkingSucceeded() {
+        qDebug() << "Linking succeeded!";
+        if (waitForMsg_) {
+            postStatusUpdate(msg_);
+        } else {
+            qApp->quit();
+        }
+    }
+
+private slots:
+    void postStatusUpdate(const QString& msg) {
+        connect(&tweeter_, SIGNAL(statusPosted()), qApp, SLOT(quit()));
+        tweeter_.postStatusUpdate(msg);
+    }
+
+private:
+    Tweeter tweeter_;
+    bool waitForMsg_;
+    QString msg_;
+};
+
+int main(int argc, char *argv[]) {
+    QApplication a(argc, argv);
+
+    Helper helper;
+    QTimer::singleShot(0, &helper, SLOT(processArgs()));
+
+    return a.exec();
+}
+
+#include "main.moc"
diff --git a/common/libkipiplugins/o2/examples/twitterdemo/tweeter.cpp b/common/libkipiplugins/o2/examples/twitterdemo/tweeter.cpp
new file mode 100644
index 0000000..4212e11
--- /dev/null
+++ b/common/libkipiplugins/o2/examples/twitterdemo/tweeter.cpp
@@ -0,0 +1,135 @@
+#include <QNetworkAccessManager>
+#include <QNetworkRequest>
+#include <QDesktopServices>
+#include <QDebug>
+
+#include "tweeter.h"
+#include "o0globals.h"
+#include "o1requestor.h"
+#include "o0settingsstore.h"
+
+const char O2_CONSUMER_KEY[] = "2vHeyIxjywIadjEhvbDpg";
+const char O2_CONSUMER_SECRET[] = "Xfwe195Kp3ZpcCKgkYs7RKfugTm8EfpLkQvsKfX2vvs";
+
+const int localPort = 8888;
+
+Tweeter::Tweeter(QObject *parent) :
+    QObject(parent) {
+}
+
+void Tweeter::doOAuth() {
+    o1Twitter_ = new O1Twitter(this);
+    o1Twitter_->setClientId(O2_CONSUMER_KEY);
+    o1Twitter_->setClientSecret(O2_CONSUMER_SECRET);
+    o1Twitter_->setLocalPort(localPort);
+
+    // Create a store object for writing the received tokens
+    O0SettingsStore *store = new O0SettingsStore(O2_ENCRYPTION_KEY);
+    store->setGroupKey("twitter");
+    o1Twitter_->setStore(store);
+
+    // Connect signals
+    connect(o1Twitter_, SIGNAL(linkedChanged()), this, SLOT(onLinkedChanged()));
+    connect(o1Twitter_, SIGNAL(linkingFailed()), this, SIGNAL(linkingFailed()));
+    connect(o1Twitter_, SIGNAL(linkingSucceeded()), this, SLOT(onLinkingSucceeded()));
+    connect(o1Twitter_, SIGNAL(openBrowser(QUrl)), this, SLOT(onOpenBrowser(QUrl)));
+    connect(o1Twitter_, SIGNAL(closeBrowser()), this, SLOT(onCloseBrowser()));
+
+    qDebug() << "Starting OAuth...";
+    o1Twitter_->unlink();  // For the sake of this demo
+    o1Twitter_->link();
+}
+
+void Tweeter::doXAuth(const QString &username, const QString &password) {
+    oxTwitter_ = new OXTwitter(this);
+    oxTwitter_->setClientId(O2_CONSUMER_KEY);
+    oxTwitter_->setClientSecret(O2_CONSUMER_SECRET);
+    oxTwitter_->setLocalPort(localPort);
+
+    oxTwitter_->setUsername(username);
+    oxTwitter_->setPassword(password);
+
+    // Create a store object for writing the received tokens
+    O0SettingsStore *store = new O0SettingsStore(O2_ENCRYPTION_KEY);
+    store->setGroupKey("twitter");
+    oxTwitter_->setStore(store);
+
+    connect(oxTwitter_, SIGNAL(linkedChanged()), this, SLOT(onLinkedChanged()));
+    connect(oxTwitter_, SIGNAL(linkingFailed()), this, SIGNAL(linkingFailed()));
+    connect(oxTwitter_, SIGNAL(linkingSucceeded()), this, SLOT(onLinkingSucceeded()));
+    connect(oxTwitter_, SIGNAL(openBrowser(QUrl)), this, SLOT(onOpenBrowser(QUrl)));
+    connect(oxTwitter_, SIGNAL(closeBrowser()), this, SLOT(onCloseBrowser()));
+
+    qDebug() << "Starting XAuth...";
+    qDebug() << "Username:" << username << "Password:" << password;
+    oxTwitter_->unlink();  // For the sake of this demo
+    oxTwitter_->link();
+}
+
+void Tweeter::postStatusUpdate(const QString &message) {
+    if (!o1Twitter_->linked()) {
+        qWarning() << "Application is not linked to Twitter!";
+        emit statusPosted();
+        return;
+    }
+
+    qDebug() << "Status update message:" << message.toLatin1().constData();
+
+    QNetworkAccessManager* manager = new QNetworkAccessManager(this);
+    O1Twitter* o1 = o1Twitter_;
+    O1Requestor* requestor = new O1Requestor(manager, o1, this);
+
+    QByteArray paramName("status");
+
+    QList<O0RequestParameter> reqParams = QList<O0RequestParameter>();
+    reqParams << O0RequestParameter(paramName, message.toLatin1());
+
+    QByteArray postData = O1::createQueryParameters(reqParams);
+
+    QUrl url = QUrl("https://api.twitter.com/1.1/statuses/update.json");
+
+    QNetworkRequest request(url);
+    request.setHeader(QNetworkRequest::ContentTypeHeader, O2_MIME_TYPE_XFORM);
+
+    QNetworkReply *reply = requestor->post(request, reqParams, postData);
+    connect(reply, SIGNAL(finished()), this, SLOT(tweetReplyDone()));
+}
+
+void Tweeter::onOpenBrowser(const QUrl &url) {
+    qDebug() << "Opening browser with URL" << url.toString();
+    QDesktopServices::openUrl(url);
+}
+
+void Tweeter::onCloseBrowser() {
+}
+
+void Tweeter::onLinkedChanged() {
+    qDebug() << "Linked changed!";
+}
+
+void Tweeter::onLinkingSucceeded() {
+    O1Twitter *o1t = qobject_cast<O1Twitter *>(sender());
+    if (!o1t->linked()) {
+        return;
+    }
+    QVariantMap extraTokens = o1t->extraTokens();
+    if (!extraTokens.isEmpty()) {
+        emit extraTokensReady(extraTokens);
+        qDebug() << "Extra tokens in response:";
+        foreach (QString key, extraTokens.keys()) {
+            qDebug() << "\t" << key << ":" << (extraTokens.value(key).toString().left(3) + "...");
+        }
+    }
+    emit linkingSucceeded();
+}
+
+void Tweeter::tweetReplyDone() {
+    QNetworkReply *reply = qobject_cast<QNetworkReply *>(sender());
+    if (reply->error() != QNetworkReply::NoError) {
+        qDebug() << "ERROR:" << reply->errorString();
+        qDebug() << "Content:" << reply->readAll();
+    } else {
+        qDebug() << "Tweet posted sucessfully!";
+    }
+    emit statusPosted();
+}
diff --git a/common/libkipiplugins/o2/examples/twitterdemo/tweeter.h b/common/libkipiplugins/o2/examples/twitterdemo/tweeter.h
new file mode 100644
index 0000000..6108725
--- /dev/null
+++ b/common/libkipiplugins/o2/examples/twitterdemo/tweeter.h
@@ -0,0 +1,41 @@
+#ifndef TWEETER_H
+#define TWEETER_H
+
+#include <QObject>
+#include <QString>
+#include <QUrl>
+#include <QVariantMap>
+
+#include "o1twitter.h"
+#include "oxtwitter.h"
+
+class Tweeter : public QObject
+{
+    Q_OBJECT
+public:
+    explicit Tweeter(QObject *parent = 0);
+
+signals:
+    void extraTokensReady(const QVariantMap &extraTokens);
+    void linkingFailed();
+    void linkingSucceeded();
+    void statusPosted();
+
+public slots:
+    void doOAuth();
+    void doXAuth(const QString &username, const QString &password);
+    void postStatusUpdate(const QString &message);
+
+private slots:
+    void onLinkedChanged();
+    void onLinkingSucceeded();
+    void onOpenBrowser(const QUrl &url);
+    void onCloseBrowser();
+    void tweetReplyDone();
+
+private:
+    O1Twitter* o1Twitter_;
+    OXTwitter* oxTwitter_;
+};
+
+#endif // TWEETER_H
diff --git a/common/libkipiplugins/o2/examples/twitterdemo/twitterdemo.pro b/common/libkipiplugins/o2/examples/twitterdemo/twitterdemo.pro
new file mode 100644
index 0000000..e955f9d
--- /dev/null
+++ b/common/libkipiplugins/o2/examples/twitterdemo/twitterdemo.pro
@@ -0,0 +1,14 @@
+QT += core gui
+
+greaterThan(QT_MAJOR_VERSION, 4): QT += widgets
+
+include(../../src/src.pri)
+
+TARGET = twitterdemo
+TEMPLATE = app
+
+SOURCES += main.cpp \
+    tweeter.cpp
+
+HEADERS += \
+    tweeter.h
diff --git a/common/libkipiplugins/o2/src/CMakeLists.txt b/common/libkipiplugins/o2/src/CMakeLists.txt
new file mode 100644
index 0000000..ea1d48a
--- /dev/null
+++ b/common/libkipiplugins/o2/src/CMakeLists.txt
@@ -0,0 +1,103 @@
+cmake_minimum_required(VERSION 2.8.11)
+
+project(o2)
+
+set(CMAKE_AUTOMOC ON)
+set(CMAKE_INCLUDE_CURRENT_DIR ON)
+set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall")
+
+if(o2_WITH_QT5)
+    find_package(Qt5 COMPONENTS Core Network REQUIRED)
+else(o2_WITH_QT5)
+    set(QT_USE_QTNETWORK true)
+    set(QT_USE_QTSCRIPT true)
+    find_package(Qt4 REQUIRED)
+endif(o2_WITH_QT5)
+#find_package(QJson REQUIRED)
+
+if (NOT o2_WITH_QT5)
+    include( ${QT_USE_FILE} )
+endif(NOT o2_WITH_QT5)
+
+set( o2_SRCS
+    o2.cpp
+    o2reply.cpp
+    o2replyserver.cpp
+    o2requestor.cpp
+    o2simplecrypt.cpp
+    o0settingsstore.cpp
+    o0baseauth.cpp
+    o0abstractstore.h
+    o0globals.h
+)
+
+if(o2_WITH_OAUTH1)
+    set( o2_SRCS
+        ${o2_SRCS}
+        o1.cpp
+        o1requestor.cpp
+        o1timedreply.cpp
+    )
+endif(o2_WITH_OAUTH1)
+
+if(o2_WITH_TWITTER)
+    set( o2_SRCS
+        ${o2_SRCS}
+        o1twitter.h
+        oxtwitter.cpp
+    )
+endif(o2_WITH_TWITTER)
+
+if(o2_WITH_DROPBOX)
+    set( o2_SRCS
+        ${o2_SRCS}
+        o1dropbox.h
+    )
+endif(o2_WITH_DROPBOX)
+
+if(o2_WITH_GOOGLE)
+    set( o2_SRCS
+        ${o2_SRCS}
+        o2gft.cpp
+    )
+endif(o2_WITH_GOOGLE)
+
+if(o2_WITH_FACEBOOK)
+    set( o2_SRCS
+        ${o2_SRCS}
+        o2facebook.cpp
+    )
+endif(o2_WITH_FACEBOOK)
+
+if(o2_WITH_SKYDRIVE)
+    set( o2_SRCS
+        ${o2_SRCS}
+        o2skydrive.cpp
+    )
+endif(o2_WITH_SKYDRIVE)
+
+if(o2_WITH_FLICKR)
+    set( o2_SRCS
+        ${o2_SRCS}
+        o1flickr.h
+    )
+endif(o2_WITH_FLICKR)
+
+if(o2_WITH_HUBIC)
+    set( o2_SRCS
+        ${o2_SRCS}
+        o2hubic.cpp
+    )
+endif(o2_WITH_HUBIC)
+
+if(NOT o2_WITH_QT5)
+    add_definitions(${QT4_DEFINITIONS})
+endif(NOT o2_WITH_QT5)
+
+add_library( o2 ${o2_SRCS} )
+
+if(o2_WITH_QT5)
+    target_link_libraries( o2 Qt5::Core Qt5::Network)
+else(o2_WITH_QT5)
+    target_link_libraries( o2 ${QT_LIBRARIES} )
+endif(o2_WITH_QT5)
diff --git a/common/libkipiplugins/o2/src/o0abstractstore.h b/common/libkipiplugins/o2/src/o0abstractstore.h
new file mode 100644
index 0000000..1397361
--- /dev/null
+++ b/common/libkipiplugins/o2/src/o0abstractstore.h
@@ -0,0 +1,22 @@
+#ifndef O0ABSTRACTSTORE_H
+#define O0ABSTRACTSTORE_H
+
+#include <QObject>
+#include <QString>
+
+/// Storage for strings.
+class O0AbstractStore: public QObject {
+    Q_OBJECT
+
+public:
+    explicit O0AbstractStore(QObject *parent = 0): QObject(parent) {
+    }
+
+    /// Retrieve a string value by key.
+    virtual QString value(const QString &key, const QString &defaultValue = QString()) = 0;
+
+    /// Set a string value for a key.
+    virtual void setValue(const QString &key, const QString &value) = 0;
+};
+
+#endif // O0ABSTRACTSTORE_H
diff --git a/common/libkipiplugins/o2/src/o0baseauth.cpp b/common/libkipiplugins/o2/src/o0baseauth.cpp
new file mode 100644
index 0000000..d4f052d
--- /dev/null
+++ b/common/libkipiplugins/o2/src/o0baseauth.cpp
@@ -0,0 +1,126 @@
+#include <QDataStream>
+#include <QDebug>
+
+#include "o0baseauth.h"
+#include "o0globals.h"
+#include "o0settingsstore.h"
+
+static const quint16 DefaultLocalPort = 1965;
+
+O0BaseAuth::O0BaseAuth(QObject *parent): QObject(parent) {
+    localPort_ = DefaultLocalPort;
+    store_ = new O0SettingsStore(O2_ENCRYPTION_KEY, this);
+}
+
+void O0BaseAuth::setStore(O0AbstractStore *store) {
+    if (store_) {
+        store_->deleteLater();
+    }
+    if (store) {
+        store_ = store;
+        store_->setParent(this);
+    } else {
+        store_ = new O0SettingsStore(O2_ENCRYPTION_KEY, this);
+        return;
+    }
+}
+
+bool O0BaseAuth::linked() {
+    QString key = QString(O2_KEY_LINKED).arg(clientId_);
+    bool result = !store_->value(key).isEmpty();
+    qDebug() << "O0BaseAuth::linked:" << (result? "Yes": "No");
+    return result;
+}
+
+void O0BaseAuth::setLinked(bool v) {
+    qDebug() << "O0BaseAuth::setLinked:" << (v? "true": "false");
+    bool oldValue = linked();
+    QString key = QString(O2_KEY_LINKED).arg(clientId_);
+    store_->setValue(key, v? "1": "");
+    if (oldValue != v) {
+        Q_EMIT linkedChanged();
+    }
+}
+
+QString O0BaseAuth::tokenSecret() {
+    QString key = QString(O2_KEY_TOKEN_SECRET).arg(clientId_);
+    return store_->value(key);
+}
+
+void O0BaseAuth::setTokenSecret(const QString &v) {
+    QString key = QString(O2_KEY_TOKEN_SECRET).arg(clientId_);
+    store_->setValue(key, v);
+    Q_EMIT tokenSecretChanged();
+}
+
+QString O0BaseAuth::token() {
+    QString key = QString(O2_KEY_TOKEN).arg(clientId_);
+    return store_->value(key);
+}
+
+void O0BaseAuth::setToken(const QString &v) {
+    QString key = QString(O2_KEY_TOKEN).arg(clientId_);
+    store_->setValue(key, v);
+    Q_EMIT tokenChanged();
+}
+
+QString O0BaseAuth::clientId() {
+    return clientId_;
+}
+
+void O0BaseAuth::setClientId(const QString &value) {
+    clientId_ = value;
+    Q_EMIT clientIdChanged();
+}
+
+QString O0BaseAuth::clientSecret() {
+    return clientSecret_;
+}
+
+void O0BaseAuth::setClientSecret(const QString &value) {
+    clientSecret_ = value;
+    Q_EMIT clientSecretChanged();
+}
+
+int O0BaseAuth::localPort() {
+    return localPort_;
+}
+
+void O0BaseAuth::setLocalPort(int value) {
+    qDebug() << "O0BaseAuth::setLocalPort:" << value;
+    localPort_ = value;
+    Q_EMIT localPortChanged();
+}
+
+QVariantMap O0BaseAuth::extraTokens() {
+    QString key = QString(O2_KEY_EXTRA_TOKENS).arg(clientId_);
+    QString value = store_->value(key);
+    QByteArray bytes = QByteArray::fromBase64(value.toLatin1());
+    QDataStream stream(&bytes, QIODevice::ReadOnly);
+    stream >> extraTokens_;
+    return extraTokens_;
+}
+
+void O0BaseAuth::setExtraTokens(QVariantMap extraTokens) {
+    extraTokens_ = extraTokens;
+    QByteArray bytes;
+    QDataStream stream(&bytes, QIODevice::WriteOnly);
+    stream << extraTokens;
+    QString key = QString(O2_KEY_EXTRA_TOKENS).arg(clientId_);
+    store_->setValue(key, bytes.toBase64());
+    Q_EMIT extraTokensChanged();
+}
+
+QByteArray O0BaseAuth::createQueryParameters(const QList<O0RequestParameter> &parameters) {
+    QByteArray ret;
+    bool first = true;
+    foreach (O0RequestParameter h, parameters) {
+        if (first) {
+            first = false;
+        } else {
+            ret.append("&");
+        }
+        ret.append(QUrl::toPercentEncoding(h.name) + "=" + QUrl::toPercentEncoding(h.value));
+    }
+    return ret;
+}
diff --git a/common/libkipiplugins/o2/src/o0baseauth.h b/common/libkipiplugins/o2/src/o0baseauth.h
new file mode 100644
index 0000000..d8a68a2
--- /dev/null
+++ b/common/libkipiplugins/o2/src/o0baseauth.h
@@ -0,0 +1,120 @@
+#ifndef O0BASEAUTH_H
+#define O0BASEAUTH_H
+
+#include <QByteArray>
+#include <QObject>
+#include <QMap>
+#include <QString>
+#include <QUrl>
+#include <QVariantMap>
+
+#include "o0abstractstore.h"
+#include "o0requestparameter.h"
+
+/// Base class of OAuth authenticators
+class O0BaseAuth : public QObject {
+    Q_OBJECT
+
+public:
+    explicit O0BaseAuth(QObject *parent = 0);
+
+public:
+    /// Are we authenticated?
+    Q_PROPERTY(bool linked READ linked WRITE setLinked NOTIFY linkedChanged)
+    bool linked();
+
+    /// Authentication token.
+    Q_PROPERTY(QString token READ token NOTIFY tokenChanged)
+    QString token();
+
+    /// Authentication token secret.
+    Q_PROPERTY(QString tokenSecret READ tokenSecret NOTIFY tokenSecretChanged)
+    QString tokenSecret();
+
+    /// Provider-specific extra tokens, available after a successful authentication
+    Q_PROPERTY(QVariantMap extraTokens READ extraTokens NOTIFY extraTokensChanged)
+    QVariantMap extraTokens();
+
+    /// Client application ID.
+    /// O1 instances with the same (client ID, client secret) share the same "linked", "token" and "tokenSecret" properties.
+    Q_PROPERTY(QString clientId READ clientId WRITE setClientId NOTIFY clientIdChanged)
+    QString clientId();
+    void setClientId(const QString &value);
+
+    /// Client application secret.
+    /// O1 instances with the same (client ID, client secret) share the same "linked", "token" and "tokenSecret" properties.
+    Q_PROPERTY(QString clientSecret READ clientSecret WRITE setClientSecret NOTIFY clientSecretChanged)
+    QString clientSecret();
+    void setClientSecret(const QString &value);
+
+    /// TCP port number to use in local redirections.
+    /// The OAuth "redirect_uri" will be set to "http://localhost:<localPort>/".
+    /// If localPort is set to 0 (default), O2 will replace it with a free one.
+    Q_PROPERTY(int localPort READ localPort WRITE setLocalPort NOTIFY localPortChanged)
+    int localPort();
+    void setLocalPort(int value);
+
+    /// Sets the storage object to use for storing the OAuth tokens on a peristent medium
+    void setStore(O0AbstractStore *store);
+
+    /// Construct query string from list of headers
+    static QByteArray createQueryParameters(const QList<O0RequestParameter> &parameters);
+
+public Q_SLOTS:
+    /// Authenticate.
+    Q_INVOKABLE virtual void link() = 0;
+
+    /// De-authenticate.
+    Q_INVOKABLE virtual void unlink() = 0;
+
+Q_SIGNALS:
+    /// Emitted when client needs to open a web browser window, with the given URL.
+    void openBrowser(const QUrl &url);
+
+    /// Emitted when client can close the browser window.
+    void closeBrowser();
+
+    /// Emitted when authentication/deauthentication succeeded.
+    void linkingSucceeded();
+
+    /// Emitted when authentication/deauthentication failed.
+    void linkingFailed();
+
+    // Property change signals
+
+    void linkedChanged();
+    void clientIdChanged();
+    void clientSecretChanged();
+    void localPortChanged();
+    void tokenChanged();
+    void tokenSecretChanged();
+    void extraTokensChanged();
+
+protected:
+    /// Set authentication token.
+    void setToken(const QString &v);
+
+    /// Set authentication token secret.
+    void setTokenSecret(const QString &v);
+
+    /// Set the linked state
+    void setLinked(bool v);
+
+    /// Set extra tokens found in OAuth response
+    void setExtraTokens(QVariantMap extraTokens);
+
+protected:
+    QString clientId_;
+    QString clientSecret_;
+    QString redirectUri_;
+    QString requestToken_;
+    QString requestTokenSecret_;
+    QUrl requestTokenUrl_;
+    QUrl authorizeUrl_;
+    QUrl accessTokenUrl_;
+    quint16 localPort_;
+    O0AbstractStore *store_;
+    QVariantMap extraTokens_;
+};
+
+#endif // O0BASEAUTH
diff --git a/common/libkipiplugins/o2/src/o0globals.h b/common/libkipiplugins/o2/src/o0globals.h
new file mode 100644
index 0000000..4ce7147
--- /dev/null
+++ b/common/libkipiplugins/o2/src/o0globals.h
@@ -0,0 +1,61 @@
+#ifndef O0GLOBALS_H
+#define O0GLOBALS_H
+
+// Common constants
+const char O2_ENCRYPTION_KEY[] = "12345678";
+const char O2_CALLBACK_URL[] = "http://127.0.0.1:%1/";
+const char O2_MIME_TYPE_XFORM[] = "application/x-www-form-urlencoded";
+
+// QSettings key names
+const char O2_KEY_TOKEN[] = "token.%1";
+const char O2_KEY_TOKEN_SECRET[] = "tokensecret.%1";
+const char O2_KEY_CODE[] = "code.%1";
+const char O2_KEY_EXPIRES[] = "expires.%1";
+const char O2_KEY_REFRESH_TOKEN[] = "refreshtoken.%1";
+const char O2_KEY_LINKED[] = "linked.%1";
+const char O2_KEY_EXTRA_TOKENS[] = "extratokens.%1";
+
+// OAuth 1/1.1 Request Parameters
+const char O2_OAUTH_CALLBACK[] = "oauth_callback";
+const char O2_OAUTH_CONSUMER_KEY[] = "oauth_consumer_key";
+const char O2_OAUTH_NONCE[] = "oauth_nonce";
+const char O2_OAUTH_SIGNATURE[] = "oauth_signature";
+const char O2_OAUTH_SIGNATURE_METHOD[] = "oauth_signature_method";
+const char O2_OAUTH_TIMESTAMP[] = "oauth_timestamp";
+const char O2_OAUTH_VERSION[] = "oauth_version";
+// OAuth 1/1.1 Response Parameters
+const char O2_OAUTH_TOKEN[] = "oauth_token";
+const char O2_OAUTH_TOKEN_SECRET[] = "oauth_token_secret";
+const char O2_OAUTH_CALLBACK_CONFIRMED[] = "oauth_callback_confirmed";
+const char O2_OAUTH_VERFIER[] = "oauth_verifier";
+
+// OAuth 2 Request Parameters
+const char O2_OAUTH2_RESPONSE_TYPE[] = "response_type";
+const char O2_OAUTH2_CLIENT_ID[] = "client_id";
+const char O2_OAUTH2_CLIENT_SECRET[] = "client_secret";
+const char O2_OAUTH2_USERNAME[] = "username";
+const char O2_OAUTH2_PASSWORD[] = "password";
+const char O2_OAUTH2_REDIRECT_URI[] = "redirect_uri";
+const char O2_OAUTH2_SCOPE[] = "scope";
+const char O2_OAUTH2_GRANT_TYPE_CODE[] = "code";
+const char O2_OAUTH2_GRANT_TYPE_TOKEN[] = "token";
+const char O2_OAUTH2_GRANT_TYPE_PASSWORD[] = "password";
+const char O2_OAUTH2_GRANT_TYPE[] = "grant_type";
+const char O2_OAUTH2_API_KEY[] = "api_key";
+
+// OAuth 2 Response Parameters
+const char O2_OAUTH2_ACCESS_TOKEN[] = "access_token";
+const char O2_OAUTH2_REFRESH_TOKEN[] = "refresh_token";
+const char O2_OAUTH2_EXPIRES_IN[] = "expires_in";
+
+// OAuth signature types
+const char O2_SIGNATURE_TYPE_HMAC_SHA1[] = "HMAC-SHA1";
+const char O2_SIGNATURE_TYPE_PLAINTEXT[] = "PLAINTEXT";
+
+// Parameter values
+const char O2_AUTHORIZATION_CODE[] = "authorization_code";
+
+// Standard HTTP headers
+const char O2_HTTP_AUTHORIZATION_HEADER[] = "Authorization";
+
+#endif // O0GLOBALS_H
diff --git a/common/libkipiplugins/o2/src/o0requestparameter.h b/common/libkipiplugins/o2/src/o0requestparameter.h
new file mode 100644
index 0000000..c793aad
--- /dev/null
+++ b/common/libkipiplugins/o2/src/o0requestparameter.h
@@ -0,0 +1,14 @@
+#ifndef O0REQUESTPARAMETER_H
+#define O0REQUESTPARAMETER_H
+
+/// Request parameter (name-value pair) participating in authentication.
+struct O0RequestParameter {
+    O0RequestParameter(const QByteArray &n, const QByteArray &v): name(n), value(v) {}
+    bool operator <(const O0RequestParameter &other) const {
+        return (name == other.name)? (value < other.value): (name < other.name);
+    }
+    QByteArray name;
+    QByteArray value;
+};
+
+#endif // O0REQUESTPARAMETER_H
diff --git a/common/libkipiplugins/o2/src/o0settingsstore.cpp b/common/libkipiplugins/o2/src/o0settingsstore.cpp
new file mode 100644
index 0000000..c475389
--- /dev/null
+++ b/common/libkipiplugins/o2/src/o0settingsstore.cpp
@@ -0,0 +1,44 @@
+#include <QCryptographicHash>
+#include <QByteArray>
+
+#include "o0settingsstore.h"
+
+static quint64 getHash(const QString &encryptionKey) {
+    return QCryptographicHash::hash(encryptionKey.toLatin1(), QCryptographicHash::Sha1).toULongLong();
+}
+
+O0SettingsStore::O0SettingsStore(const QString &encryptionKey, QObject *parent):
+    O0AbstractStore(parent), crypt_(getHash(encryptionKey)) {
+    settings_ = new QSettings(this);
+}
+
+O0SettingsStore::O0SettingsStore(QSettings *settings, const QString &encryptionKey, QObject *parent):
+    O0AbstractStore(parent), crypt_(getHash(encryptionKey)) {
+    settings_ = settings;
+    settings_->setParent(this);
+}
+
+QString O0SettingsStore::groupKey() const {
+    return groupKey_;
+}
+
+void O0SettingsStore::setGroupKey(const QString &groupKey) {
+    if (groupKey_ == groupKey) {
+        return;
+    }
+    groupKey_ = groupKey;
+    Q_EMIT groupKeyChanged();
+}
+
+QString O0SettingsStore::value(const QString &key, const QString &defaultValue) {
+    QString fullKey = groupKey_.isEmpty() ? key : (groupKey_ + '/' + key);
+    if (!settings_->contains(fullKey)) {
+        return defaultValue;
+    }
+    return crypt_.decryptToString(settings_->value(fullKey).toString());
+}
+
+void O0SettingsStore::setValue(const QString &key, const QString &value) {
+    QString fullKey = groupKey_.isEmpty() ? key : (groupKey_ + '/' + key);
+    settings_->setValue(fullKey, crypt_.encryptToString(value));
+}
diff --git a/common/libkipiplugins/o2/src/o0settingsstore.h b/common/libkipiplugins/o2/src/o0settingsstore.h
new file mode 100644
index 0000000..2b6964a
--- /dev/null
+++ b/common/libkipiplugins/o2/src/o0settingsstore.h
@@ -0,0 +1,42 @@
+#ifndef O0SETTINGSSTORE_H
+#define O0SETTINGSSTORE_H
+
+#include <QSettings>
+#include <QString>
+
+#include "o0abstractstore.h"
+#include "o0simplecrypt.h"
+
+/// Persistent storage for authentication tokens, using QSettings.
+class O0SettingsStore: public O0AbstractStore {
+    Q_OBJECT
+
+public:
+    /// Constructor
+    explicit O0SettingsStore(const QString &encryptionKey, QObject *parent = 0);
+
+    /// Construct with an explicit QSettings instance
+    explicit O0SettingsStore(QSettings *settings, const QString &encryptionKey, QObject *parent = 0);
+
+    /// Group key prefix
+    Q_PROPERTY(QString groupKey READ groupKey WRITE setGroupKey NOTIFY groupKeyChanged)
+    QString groupKey() const;
+    void setGroupKey(const QString &groupKey);
+
+    /// Get a string value for a key
+    QString value(const QString &key, const QString &defaultValue = QString());
+
+    /// Set a string value for a key
+    void setValue(const QString &key, const QString &value);
+
+Q_SIGNALS:
+    // Property change signals
+    void groupKeyChanged();
+
+protected:
+    QSettings* settings_;
+    QString groupKey_;
+    O0SimpleCrypt crypt_;
+};
+
+#endif // O0SETTINGSSTORE_H
diff --git a/common/libkipiplugins/o2/src/o0simplecrypt.h b/common/libkipiplugins/o2/src/o0simplecrypt.h
new file mode 100644
index 0000000..64f916d
--- /dev/null
+++ b/common/libkipiplugins/o2/src/o0simplecrypt.h
@@ -0,0 +1,225 @@
+/*
+Copyright (c) 2011, Andre Somers
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of the Rathenau Instituut, Andre Somers nor the
+      names of its contributors may be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL ANDRE SOMERS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef SIMPLECRYPT_H
+#define SIMPLECRYPT_H
+#include <QString>
+#include <QVector>
+#include <QFlags>
+
+/**
+  @short Simple encryption and decryption of strings and byte arrays
+
+  This class provides a simple implementation of encryption and decryption
+  of strings and byte arrays.
+
+  @warning The encryption provided by this class is NOT strong encryption. It may
+  help to shield things from curious eyes, but it will NOT stand up to someone
+  determined to break the encryption. Don't say you were not warned.
+
+  The class uses a 64 bit key. Simply create an instance of the class, set the key,
+  and use the encryptToString() method to calculate an encrypted version of the input string.
+  To decrypt that string again, use an instance of SimpleCrypt initialized with
+  the same key, and call the decryptToString() method with the encrypted string. If the key
+  matches, the decrypted version of the string will be returned again.
+
+  If you do not provide a key, or if something else is wrong, the encryption and
+  decryption function will return an empty string or will return a string containing nonsense.
+  lastError() will return a value indicating if the method was succesful, and if not, why not.
+
+  SimpleCrypt is prepared for the case that the encryption and decryption
+  algorithm is changed in a later version, by prepending a version identifier to the cypertext.
+  */
+class O0SimpleCrypt
+{
+public:
+    /**
+      CompressionMode describes if compression will be applied to the data to be
+      encrypted.
+      */
+    enum CompressionMode {
+        CompressionAuto,    /*!< Only apply compression if that results in a shorter plaintext. */
+        CompressionAlways,  /*!< Always apply compression. Note that for short inputs, a compression may result in longer data */
+        CompressionNever    /*!< Never apply compression. */
+    };
+    /**
+      IntegrityProtectionMode describes measures taken to make it possible to detect problems with the data
+      or wrong decryption keys.
+
+      Measures involve adding a checksum or a cryptograhpic hash to the data to be encrypted. This
+      increases the length of the resulting cypertext, but makes it possible to check if the plaintext
+      appears to be valid after decryption.
+    */
+    enum IntegrityProtectionMode {
+        ProtectionNone,    /*!< The integerity of the encrypted data is not protected. It is not really possible to detect a wrong key, for instance. */
+        ProtectionChecksum,/*!< A simple checksum is used to verify that the data is in order. If not, an empty string is returned. */
+        ProtectionHash     /*!< A cryptographic hash is used to verify the integrity of the data. This method produces a much stronger, but longer check */
+    };
+    /**
+      Error describes the type of error that occured.
+      */
+    enum Error {
+        ErrorNoError,         /*!< No error occurred. */
+        ErrorNoKeySet,        /*!< No key was set. You can not encrypt or decrypt without a valid key. */
+        ErrorUnknownVersion,  /*!< The version of this data is unknown, or the data is otherwise not valid. */
+        ErrorIntegrityFailed  /*!< The integrity check of the data failed. Perhaps the wrong key was used. */
+    };
+
+    /**
+      Constructor.
+
+      Constructs a SimpleCrypt instance without a valid key set on it.
+     */
+    O0SimpleCrypt();
+    /**
+      Constructor.
+
+      Constructs a SimpleCrypt instance and initializes it with the given @arg key.
+     */
+    explicit O0SimpleCrypt(quint64 key);
+
+    /**
+      (Re-) initializes the key with the given @arg key.
+      */
+    void setKey(quint64 key);
+    /**
+      Returns true if SimpleCrypt has been initialized with a key.
+      */
+    bool hasKey() const {return !m_keyParts.isEmpty();}
+
+    /**
+      Sets the compression mode to use when encrypting data. The default mode is Auto.
+
+      Note that decryption is not influenced by this mode, as the decryption recognizes
+      what mode was used when encrypting.
+      */
+    void setCompressionMode(CompressionMode mode) {m_compressionMode = mode;}
+    /**
+      Returns the CompressionMode that is currently in use.
+      */
+    CompressionMode compressionMode() const {return m_compressionMode;}
+
+    /**
+      Sets the integrity mode to use when encrypting data. The default mode is Checksum.
+
+      Note that decryption is not influenced by this mode, as the decryption recognizes
+      what mode was used when encrypting.
+      */
+    void setIntegrityProtectionMode(IntegrityProtectionMode mode) {m_protectionMode = mode;}
+    /**
+      Returns the IntegrityProtectionMode that is currently in use.
+      */
+    IntegrityProtectionMode integrityProtectionMode() const {return m_protectionMode;}
+
+    /**
+      Returns the last error that occurred.
+      */
+    Error lastError() const {return m_lastError;}
+
+    /**
+      Encrypts the @arg plaintext string with the key the class was initialized with, and returns
+      a cyphertext the result. The result is a base64 encoded version of the binary array that is the
+      actual result of the string, so it can be stored easily in a text format.
+      */
+    QString encryptToString(const QString& plaintext) ;
+    /**
+      Encrypts the @arg plaintext QByteArray with the key the class was initialized with, and returns
+      a cyphertext the result. The result is a base64 encoded version of the binary array that is the
+      actual result of the encryption, so it can be stored easily in a text format.
+      */
+    QString encryptToString(QByteArray plaintext) ;
+    /**
+      Encrypts the @arg plaintext string with the key the class was initialized with, and returns
+      a binary cyphertext in a QByteArray the result.
+
+      This method returns a byte array, that is useable for storing a binary format. If you need
+      a string you can store in a text file, use encryptToString() instead.
+      */
+    QByteArray encryptToByteArray(const QString& plaintext) ;
+    /**
+      Encrypts the @arg plaintext QByteArray with the key the class was initialized with, and returns
+      a binary cyphertext in a QByteArray the result.
+
+      This method returns a byte array, that is useable for storing a binary format. If you need
+      a string you can store in a text file, use encryptToString() instead.
+      */
+    QByteArray encryptToByteArray(QByteArray plaintext) ;
+
+    /**
+      Decrypts a cyphertext string encrypted with this class with the set key back to the
+      plain text version.
+
+      If an error occured, such as non-matching keys between encryption and decryption,
+      an empty string or a string containing nonsense may be returned.
+      */
+    QString decryptToString(const QString& cyphertext) ;
+    /**
+      Decrypts a cyphertext string encrypted with this class with the set key back to the
+      plain text version.
+
+      If an error occured, such as non-matching keys between encryption and decryption,
+      an empty string or a string containing nonsense may be returned.
+      */
+    QByteArray decryptToByteArray(const QString& cyphertext) ;
+    /**
+      Decrypts a cyphertext binary encrypted with this class with the set key back to the
+      plain text version.
+
+      If an error occured, such as non-matching keys between encryption and decryption,
+      an empty string or a string containing nonsense may be returned.
+      */
+    QString decryptToString(QByteArray cypher) ;
+    /**
+      Decrypts a cyphertext binary encrypted with this class with the set key back to the
+      plain text version.
+
+      If an error occured, such as non-matching keys between encryption and decryption,
+      an empty string or a string containing nonsense may be returned.
+      */
+    QByteArray decryptToByteArray(QByteArray cypher) ;
+
+    //enum to describe options that have been used for the encryption. Currently only one, but
+    //that only leaves room for future extensions like adding a cryptographic hash...
+    enum CryptoFlag{CryptoFlagNone = 0,
+                    CryptoFlagCompression = 0x01,
+                    CryptoFlagChecksum = 0x02,
+                    CryptoFlagHash = 0x04
+                   };
+    Q_DECLARE_FLAGS(CryptoFlags, CryptoFlag)
+private:
+
+    void splitKey();
+
+    quint64 m_key;
+    QVector<char> m_keyParts;
+    CompressionMode m_compressionMode;
+    IntegrityProtectionMode m_protectionMode;
+    Error m_lastError;
+};
+Q_DECLARE_OPERATORS_FOR_FLAGS(O0SimpleCrypt::CryptoFlags)
+
+#endif // SimpleCrypt_H
diff --git a/common/libkipiplugins/o2/src/o1.cpp b/common/libkipiplugins/o2/src/o1.cpp
new file mode 100644
index 0000000..47783fc
--- /dev/null
+++ b/common/libkipiplugins/o2/src/o1.cpp
@@ -0,0 +1,379 @@
+#include <QCryptographicHash>
+#include <QNetworkRequest>
+#include <QNetworkAccessManager>
+#include <QDateTime>
+#include <QByteArray>
+#include <QDebug>
+#include <QDataStream>
+#include <QStringList>
+
+#if QT_VERSION >= 0x050000
+#include <QUrlQuery>
+#endif
+
+#if QT_VERSION >= 0x050100
+#include <QMessageAuthenticationCode>
+#endif
+
+#include "o1.h"
+#include "o2replyserver.h"
+#include "o0globals.h"
+#include "o0settingsstore.h"
+
+O1::O1(QObject *parent): O0BaseAuth(parent) {
+    setSignatureMethod(O2_SIGNATURE_TYPE_HMAC_SHA1);
+    manager_ = new QNetworkAccessManager(this);
+    replyServer_ = new O2ReplyServer(this);
+    qRegisterMetaType<QNetworkReply::NetworkError>("QNetworkReply::NetworkError");
+    connect(replyServer_, SIGNAL(verificationReceived(QMap<QString,QString>)), this, SLOT(onVerificationReceived(QMap<QString,QString>)));
+    setCallbackUrl(O2_CALLBACK_URL);
+}
+
+QUrl O1::requestTokenUrl() {
+    return requestTokenUrl_;
+}
+
+void O1::setRequestTokenUrl(const QUrl &v) {
+    requestTokenUrl_ = v;
+    Q_EMIT requestTokenUrlChanged();
+}
+
+QList<O0RequestParameter> O1::requestParameters() {
+    return requestParameters_;
+}
+
+void O1::setRequestParameters(const QList<O0RequestParameter> &v) {
+    requestParameters_ = v;
+}
+
+QString O1::callbackUrl() {
+    return callbackUrl_;
+}
+
+void O1::setCallbackUrl(const QString &v) {
+    callbackUrl_ = v;
+}
+
+QUrl O1::authorizeUrl() {
+    return authorizeUrl_;
+}
+
+void O1::setAuthorizeUrl(const QUrl &value) {
+    authorizeUrl_ = value;
+    Q_EMIT authorizeUrlChanged();
+}
+
+QUrl O1::accessTokenUrl() {
+    return accessTokenUrl_;
+}
+
+void O1::setAccessTokenUrl(const QUrl &value) {
+    accessTokenUrl_ = value;
+    Q_EMIT accessTokenUrlChanged();
+}
+
+QString O1::signatureMethod() {
+    return signatureMethod_;
+}
+
+void O1::setSignatureMethod(const QString &value) {
+    qDebug() << "O1::setSignatureMethod: " << value;
+    signatureMethod_ = value;
+}
+
+void O1::unlink() {
+    qDebug() << "O1::unlink";
+    setLinked(false);
+    setToken("");
+    setTokenSecret("");
+    setExtraTokens(QVariantMap());
+    Q_EMIT linkingSucceeded();
+}
+
+#if QT_VERSION < 0x050100
+/// Calculate the HMAC variant of SHA1 hash.
+/// @author     http://qt-project.org/wiki/HMAC-SHA1.
+/// @copyright  Creative Commons Attribution-ShareAlike 2.5 Generic.
+static QByteArray hmacSha1(QByteArray key, QByteArray baseString) {
+    int blockSize = 64;
+    if (key.length() > blockSize) {
+        key = QCryptographicHash::hash(key, QCryptographicHash::Sha1);
+    }
+    QByteArray innerPadding(blockSize, char(0x36));
+    QByteArray outerPadding(blockSize, char(0x5c));
+    for (int i = 0; i < key.length(); i++) {
+        innerPadding[i] = innerPadding[i] ^ key.at(i);
+        outerPadding[i] = outerPadding[i] ^ key.at(i);
+    }
+    QByteArray total = outerPadding;
+    QByteArray part = innerPadding;
+    part.append(baseString);
+    total.append(QCryptographicHash::hash(part, QCryptographicHash::Sha1));
+    QByteArray hashed = QCryptographicHash::hash(total, QCryptographicHash::Sha1);
+    return hashed.toBase64();
+}
+#endif
+
+/// Get HTTP operation name.
+static QString getOperationName(QNetworkAccessManager::Operation op) {
+    switch (op) {
+    case QNetworkAccessManager::GetOperation: return "GET";
+    case QNetworkAccessManager::PostOperation: return "POST";
+    case QNetworkAccessManager::PutOperation: return "PUT";
+    case QNetworkAccessManager::DeleteOperation: return "DEL";
+    default: return "";
+    }
+}
+
+/// Build a concatenated/percent-encoded string from a list of headers.
+QByteArray O1::encodeHeaders(const QList<O0RequestParameter> &headers) {
+    return QUrl::toPercentEncoding(createQueryParameters(headers));
+}
+
+/// Build a base string for signing.
+QByteArray O1::getRequestBase(const QList<O0RequestParameter> &oauthParams, const QList<O0RequestParameter> &otherParams, const QUrl &url, QNetworkAccessManager::Operation op) {
+    QByteArray base;
+
+    // Initialize base string with the operation name (e.g. "GET") and the base URL
+    base.append(getOperationName(op).toUtf8() + "&");
+    base.append(QUrl::toPercentEncoding(url.toString(QUrl::RemoveQuery)) + "&");
+
+    // Append a sorted+encoded list of all request parameters to the base string
+    QList<O0RequestParameter> headers(oauthParams);
+    headers.append(otherParams);
+    qSort(headers);
+    base.append(encodeHeaders(headers));
+
+    return base;
+}
+
+QByteArray O1::sign(const QList<O0RequestParameter> &oauthParams, const QList<O0RequestParameter> &otherParams, const QUrl &url, QNetworkAccessManager::Operation op, const QString &consumerSecret, const QString &tokenSecret) {
+    QByteArray baseString = getRequestBase(oauthParams, otherParams, url, op);
+    QByteArray secret = QUrl::toPercentEncoding(consumerSecret) + "&" + QUrl::toPercentEncoding(tokenSecret);
+#if QT_VERSION >= 0x050100
+    return QMessageAuthenticationCode::hash(baseString, secret, QCryptographicHash::Sha1).toBase64();
+#else
+    return hmacSha1(secret, baseString);
+#endif
+}
+
+QByteArray O1::buildAuthorizationHeader(const QList<O0RequestParameter> &oauthParams) {
+    bool first = true;
+    QByteArray ret("OAuth ");
+    QList<O0RequestParameter> headers(oauthParams);
+    qSort(headers);
+    foreach (O0RequestParameter h, headers) {
+        if (first) {
+            first = false;
+        } else {
+            ret.append(",");
+        }
+        ret.append(h.name);
+        ret.append("=\"");
+        ret.append(QUrl::toPercentEncoding(h.value));
+        ret.append("\"");
+    }
+    return ret;
+}
+
+QByteArray O1::generateSignature(const QList<O0RequestParameter> headers, const QNetworkRequest &req, const QList<O0RequestParameter> &signingParameters, QNetworkAccessManager::Operation operation) {
+    QByteArray signature;
+    if (signatureMethod() == O2_SIGNATURE_TYPE_HMAC_SHA1) {
+        signature = sign(headers, signingParameters, req.url(), operation, clientSecret(), tokenSecret());
+    } else if (signatureMethod() == O2_SIGNATURE_TYPE_PLAINTEXT) {
+        signature = clientSecret().toLatin1() + "&" + tokenSecret().toLatin1();
+    }
+    return signature;
+}
+
+void O1::link() {
+    qDebug() << "O1::link";
+    if (linked()) {
+        qDebug() << "O1::link: Linked already";
+        Q_EMIT linkingSucceeded();
+        return;
+    }
+
+    setLinked(false);
+    setToken("");
+    setTokenSecret("");
+    setExtraTokens(QVariantMap());
+
+    // Start reply server
+    replyServer_->listen(QHostAddress::Any, localPort());
+
+    // Get any query parameters for the request
+    QUrlQuery requestData;
+    O0RequestParameter param("", "");
+    foreach(param, requestParameters())
+      requestData.addQueryItem(QString(param.name), QUrl::toPercentEncoding(QString(param.value)));
+
+    // Get the request url and add parameters
+    QUrl requestUrl = requestTokenUrl();
+    requestUrl.setQuery(requestData);
+
+    // Create request
+    QNetworkRequest request(requestUrl);
+
+    // Create initial token request
+    QList<O0RequestParameter> headers;
+    headers.append(O0RequestParameter(O2_OAUTH_CALLBACK, callbackUrl().arg(replyServer_->serverPort()).toLatin1()));
+    headers.append(O0RequestParameter(O2_OAUTH_CONSUMER_KEY, clientId().toLatin1()));
+    headers.append(O0RequestParameter(O2_OAUTH_NONCE, nonce()));
+    headers.append(O0RequestParameter(O2_OAUTH_TIMESTAMP, QString::number(QDateTime::currentDateTimeUtc().toTime_t()).toLatin1()));
+    headers.append(O0RequestParameter(O2_OAUTH_VERSION, "1.0"));
+    headers.append(O0RequestParameter(O2_OAUTH_SIGNATURE_METHOD, signatureMethod().toLatin1()));
+    headers.append(O0RequestParameter(O2_OAUTH_SIGNATURE, generateSignature(headers, request, requestParameters(), QNetworkAccessManager::PostOperation)));
+
+    // Clear request token
+    requestToken_.clear();
+    requestTokenSecret_.clear();
+
+    // Post request
+    request.setRawHeader(O2_HTTP_AUTHORIZATION_HEADER, buildAuthorizationHeader(headers));
+    request.setHeader(QNetworkRequest::ContentTypeHeader, O2_MIME_TYPE_XFORM);
+    QNetworkReply *reply = manager_->post(request, QByteArray());
+    connect(reply, SIGNAL(error(QNetworkReply::NetworkError)), this, SLOT(onTokenRequestError(QNetworkReply::NetworkError)));
+    connect(reply, SIGNAL(finished()), this, SLOT(onTokenRequestFinished()));
+}
+
+void O1::onTokenRequestError(QNetworkReply::NetworkError error) {
+    QNetworkReply *reply = qobject_cast<QNetworkReply *>(sender());
+    qWarning() << "O1::onTokenRequestError:" << (int)error << reply->errorString() << reply->readAll();
+    Q_EMIT linkingFailed();
+}
+
+void O1::onTokenRequestFinished() {
+    qDebug() << "O1::onTokenRequestFinished";
+    QNetworkReply *reply = qobject_cast<QNetworkReply *>(sender());
+    reply->deleteLater();
+    if (reply->error() != QNetworkReply::NoError) {
+        qWarning() << "O1::onTokenRequestFinished: " << reply->errorString();
+        return;
+    }
+
+    // Get request token and secret
+    QByteArray data = reply->readAll();
+    QMap<QString, QString> response = parseResponse(data);
+    requestToken_ = response.value(O2_OAUTH_TOKEN, "");
+    requestTokenSecret_ = response.value(O2_OAUTH_TOKEN_SECRET, "");
+    setToken(requestToken_);
+    setTokenSecret(requestTokenSecret_);
+
+    // Checking for "oauth_callback_confirmed" is present and set to true
+    QString oAuthCbConfirmed = response.value(O2_OAUTH_CALLBACK_CONFIRMED, "false");
+    if (requestToken_.isEmpty() || requestTokenSecret_.isEmpty() || (oAuthCbConfirmed == "false")) {
+        qWarning() << "O1::onTokenRequestFinished: No oauth_token, oauth_token_secret or oauth_callback_confirmed in response :" << data;
+        Q_EMIT linkingFailed();
+        return;
+    }
+
+    // Continue authorization flow in the browser
+    QUrl url(authorizeUrl());
+#if QT_VERSION < 0x050000
+    url.addQueryItem(O2_OAUTH_TOKEN, requestToken_);
+    url.addQueryItem(O2_OAUTH_CALLBACK, callbackUrl().arg(replyServer_->serverPort()).toLatin1());
+#else
+    QUrlQuery query(url);
+    query.addQueryItem(O2_OAUTH_TOKEN, requestToken_);
+    query.addQueryItem(O2_OAUTH_CALLBACK, callbackUrl().arg(replyServer_->serverPort()).toLatin1());
+    url.setQuery(query);
+#endif
+    Q_EMIT openBrowser(url);
+}
+
+void O1::onVerificationReceived(QMap<QString, QString> params) {
+    qDebug() << "O1::onVerificationReceived";
+    Q_EMIT closeBrowser();
+    verifier_ = params.value(O2_OAUTH_VERFIER, "");
+    if (params.value(O2_OAUTH_TOKEN) == requestToken_) {
+        // Exchange request token for access token
+        exchangeToken();
+    } else {
+        qWarning() << "O1::onVerificationReceived: oauth_token missing or doesn't match";
+        Q_EMIT linkingFailed();
+    }
+}
+
+void O1::exchangeToken() {
+    qDebug() << "O1::exchangeToken";
+
+    // Create token exchange request
+    QNetworkRequest request(accessTokenUrl());
+    QList<O0RequestParameter> oauthParams;
+    oauthParams.append(O0RequestParameter(O2_OAUTH_CONSUMER_KEY, clientId().toLatin1()));
+    oauthParams.append(O0RequestParameter(O2_OAUTH_VERSION, "1.0"));
+    oauthParams.append(O0RequestParameter(O2_OAUTH_TIMESTAMP, QString::number(QDateTime::currentDateTimeUtc().toTime_t()).toLatin1()));
+    oauthParams.append(O0RequestParameter(O2_OAUTH_NONCE, nonce()));
+    oauthParams.append(O0RequestParameter(O2_OAUTH_TOKEN, requestToken_.toLatin1()));
+    oauthParams.append(O0RequestParameter(O2_OAUTH_VERFIER, verifier_.toLatin1()));
+    oauthParams.append(O0RequestParameter(O2_OAUTH_SIGNATURE_METHOD, signatureMethod().toLatin1()));
+    oauthParams.append(O0RequestParameter(O2_OAUTH_SIGNATURE, generateSignature(oauthParams, request, QList<O0RequestParameter>(), QNetworkAccessManager::PostOperation)));
+
+    // Post request
+    request.setRawHeader(O2_HTTP_AUTHORIZATION_HEADER, buildAuthorizationHeader(oauthParams));
+    request.setHeader(QNetworkRequest::ContentTypeHeader, O2_MIME_TYPE_XFORM);
+    QNetworkReply *reply = manager_->post(request, QByteArray());
+    connect(reply, SIGNAL(error(QNetworkReply::NetworkError)), this, SLOT(onTokenExchangeError(QNetworkReply::NetworkError)));
+    connect(reply, SIGNAL(finished()), this, SLOT(onTokenExchangeFinished()));
+}
+
+void O1::onTokenExchangeError(QNetworkReply::NetworkError error) {
+    QNetworkReply *reply = qobject_cast<QNetworkReply *>(sender());
+    qWarning() << "O1::onTokenExchangeError:" << (int)error << reply->errorString() << reply->readAll();
+    Q_EMIT linkingFailed();
+}
+
+void O1::onTokenExchangeFinished() {
+    qDebug() << "O1::onTokenExchangeFinished";
+
+    QNetworkReply *reply = qobject_cast<QNetworkReply *>(sender());
+    reply->deleteLater();
+    if (reply->error() != QNetworkReply::NoError) {
+        qWarning() << "O1::onTokenExchangeFinished: " << reply->errorString();
+        return;
+    }
+
+    // Get access token and secret
+    QByteArray data = reply->readAll();
+    QMap<QString, QString> response = parseResponse(data);
+    if (response.contains(O2_OAUTH_TOKEN) && response.contains(O2_OAUTH_TOKEN_SECRET)) {
+        setToken(response.take(O2_OAUTH_TOKEN));
+        setTokenSecret(response.take(O2_OAUTH_TOKEN_SECRET));
+        // Set extra tokens if any
+        if (!response.isEmpty()) {
+            QVariantMap extraTokens;
+            foreach (QString key, response.keys()) {
+               extraTokens.insert(key, response.value(key));
+            }
+            setExtraTokens(extraTokens);
+        }
+        setLinked(true);
+        Q_EMIT linkingSucceeded();
+    } else {
+        qWarning() << "O1::onTokenExchangeFinished: oauth_token or oauth_token_secret missing from response" << data;
+        Q_EMIT linkingFailed();
+    }
+}
+
+QMap<QString, QString> O1::parseResponse(const QByteArray &response) {
+    QMap<QString, QString> ret;
+    foreach (QByteArray param, response.split('&')) {
+        QList<QByteArray> kv = param.split('=');
+        if (kv.length() == 2) {
+            ret.insert(QUrl::fromPercentEncoding(kv[0]), QUrl::fromPercentEncoding(kv[1]));
+        }
+    }
+    return ret;
+}
+
+QByteArray O1::nonce() {
+    static bool firstTime = true;
+    if (firstTime) {
+        firstTime = false;
+        qsrand(QTime::currentTime().msec());
+    }
+    QString u = QString::number(QDateTime::currentDateTimeUtc().toTime_t());
+    u.append(QString::number(qrand()));
+    return u.toLatin1();
+}
diff --git a/common/libkipiplugins/o2/src/o1.h b/common/libkipiplugins/o2/src/o1.h
new file mode 100644
index 0000000..6d07b01
--- /dev/null
+++ b/common/libkipiplugins/o2/src/o1.h
@@ -0,0 +1,124 @@
+#ifndef O1_H
+#define O1_H
+
+#include <QNetworkAccessManager>
+#include <QUrl>
+#include <QNetworkReply>
+
+#include "o0baseauth.h"
+
+class O2ReplyServer;
+
+/// Simple OAuth 1.0 authenticator.
+class O1: public O0BaseAuth {
+    Q_OBJECT
+
+public:
+    /// Signature method
+    Q_PROPERTY(QString signatureMethod READ signatureMethod WRITE setSignatureMethod NOTIFY signatureMethodChanged)
+    QString signatureMethod();
+    void setSignatureMethod(const QString &value);
+
+    /// Token request URL.
+    Q_PROPERTY(QUrl requestTokenUrl READ requestTokenUrl WRITE setRequestTokenUrl NOTIFY requestTokenUrlChanged)
+    QUrl requestTokenUrl();
+    void setRequestTokenUrl(const QUrl &value);
+
+    /// Parameters to pass with request URL.
+    Q_PROPERTY(QList<O0RequestParameter> requestParameters READ requestParameters WRITE setRequestParameters);
+    QList<O0RequestParameter> requestParameters();
+    void setRequestParameters(const QList<O0RequestParameter> &value);
+
+    /// Callback URL.
+    /// It should contain a `%1` place marker, to be replaced by `O0BaseAuth::localPort()`.
+    /// Defaults to `O2_CALLBACK_URL`.
+    Q_PROPERTY(QString callbackUrl READ callbackUrl WRITE setCallbackUrl)
+    QString callbackUrl();
+    void setCallbackUrl(const QString &value);
+
+    /// Authorization URL.
+    Q_PROPERTY(QUrl authorizeUrl READ authorizeUrl WRITE setAuthorizeUrl NOTIFY authorizeUrlChanged)
+    QUrl authorizeUrl();
+    void setAuthorizeUrl(const QUrl &value);
+
+    /// Access token URL.
+    Q_PROPERTY(QUrl accessTokenUrl READ accessTokenUrl WRITE setAccessTokenUrl NOTIFY accessTokenUrlChanged)
+    QUrl accessTokenUrl();
+    void setAccessTokenUrl(const QUrl &value);
+
+    /// Constructor.
+    explicit O1(QObject *parent = 0);
+
+    /// Parse a URL-encoded response string.
+    static QMap<QString, QString> parseResponse(const QByteArray &response);
+
+    /// Build the value of the "Authorization:" header.
+    static QByteArray buildAuthorizationHeader(const QList<O0RequestParameter> &oauthParams);
+
+    /// Create unique bytes to prevent replay attacks.
+    static QByteArray nonce();
+
+    /// Generate signature string depending on signature method type
+    QByteArray generateSignature(const QList<O0RequestParameter> headers, const QNetworkRequest &req, const QList<O0RequestParameter> &signingParameters, QNetworkAccessManager::Operation operation);
+
+    /// Calculate the HMAC-SHA1 signature of a request.
+    /// @param  oauthParams     OAuth parameters.
+    /// @param  otherParams     Other parameters participating in signing.
+    /// @param  URL             Request URL. May contain query parameters, but they will not be used for signing.
+    /// @param  op              HTTP operation.
+    /// @param  consumerSecret  Consumer (application) secret.
+    /// @param  tokenSecret     Authorization token secret (empty if not yet available).
+    /// @return Signature that can be used as the value of the "oauth_signature" parameter.
+    static QByteArray sign(const QList<O0RequestParameter> &oauthParams, const QList<O0RequestParameter> &otherParams, const QUrl &url, QNetworkAccessManager::Operation op, const QString &consumerSecret, const QString &tokenSecret);
+
+    /// Build a base string for signing.
+    static QByteArray getRequestBase(const QList<O0RequestParameter> &oauthParams, const QList<O0RequestParameter> &otherParams, const QUrl &url, QNetworkAccessManager::Operation op);
+
+    /// Build a concatenated/percent-encoded string from a list of headers.
+    static QByteArray encodeHeaders(const QList<O0RequestParameter> &headers);
+
+public Q_SLOTS:
+    /// Authenticate.
+    Q_INVOKABLE virtual void link();
+
+    /// De-authenticate.
+    Q_INVOKABLE virtual void unlink();
+
+Q_SIGNALS:
+    void requestTokenUrlChanged();
+    void authorizeUrlChanged();
+    void accessTokenUrlChanged();
+    void signatureMethodChanged();
+
+protected Q_SLOTS:
+    /// Handle verification received from the reply server.
+    virtual void onVerificationReceived(QMap<QString,QString> params);
+
+    /// Handle token request error.
+    virtual void onTokenRequestError(QNetworkReply::NetworkError error);
+
+    /// Handle token request finished.
+    virtual void onTokenRequestFinished();
+
+    /// Handle token exchange error.
+    void onTokenExchangeError(QNetworkReply::NetworkError error);
+
+    /// Handle token exchange finished.
+    void onTokenExchangeFinished();
+
+protected:
+    /// Exchange temporary token to authentication token
+    void exchangeToken();
+
+    QUrl requestUrl_;
+    QList<O0RequestParameter> requestParameters_;
+    QString callbackUrl_;
+    QUrl tokenUrl_;
+    QUrl refreshTokenUrl_;
+    QString verifier_;
+    QString signatureMethod_;
+    QNetworkAccessManager *manager_;
+    O2ReplyServer *replyServer_;
+};
+
+#endif // O1_H
diff --git a/common/libkipiplugins/o2/src/o1dropbox.h b/common/libkipiplugins/o2/src/o1dropbox.h
new file mode 100644
index 0000000..b34cb4c
--- /dev/null
+++ b/common/libkipiplugins/o2/src/o1dropbox.h
@@ -0,0 +1,18 @@
+#ifndef O1DROPBOX_H
+#define O1DROPBOX_H
+
+#include "o1.h"
+
+/// Dropbox authenticator
+class O1Dropbox: public O1 {
+    Q_OBJECT
+
+public:
+    explicit O1Dropbox(QObject *parent = 0): O1(parent) {
+        setRequestTokenUrl(QUrl("https://api.dropbox.com/1/oauth/request_token"));
+        setAuthorizeUrl(QUrl("https://www.dropbox.com/1/oauth/authorize?display=mobile"));
+        setAccessTokenUrl(QUrl("https://api.dropbox.com/1/oauth/access_token"));
+     }
+};
+
+#endif // O1DROPBOX_H
diff --git a/common/libkipiplugins/o2/src/o1flickr.h b/common/libkipiplugins/o2/src/o1flickr.h
new file mode 100644
index 0000000..bffcb0a
--- /dev/null
+++ b/common/libkipiplugins/o2/src/o1flickr.h
@@ -0,0 +1,18 @@
+#ifndef O1FLICKR_H
+#define O1FLICKR_H
+
+#include "o1.h"
+
+/// Flickr authenticator.
+class O1Flickr: public O1 {
+    Q_OBJECT
+
+public:
+    explicit O1Flickr(QObject *parent = 0): O1(parent) {
+        setRequestTokenUrl(QUrl("http://www.flickr.com/services/oauth/request_token"));
+        setAuthorizeUrl(QUrl("http://www.flickr.com/services/oauth/authorize?perms=write"));
+        setAccessTokenUrl(QUrl("http://www.flickr.com/services/oauth/access_token"));
+    }
+};
+
+#endif // O1FLICKR_H
diff --git a/common/libkipiplugins/o2/src/o1freshbooks.h b/common/libkipiplugins/o2/src/o1freshbooks.h
new file mode 100755
index 0000000..49c4ea4
--- /dev/null
+++ b/common/libkipiplugins/o2/src/o1freshbooks.h
@@ -0,0 +1,22 @@
+#ifndef O1FRESHBOOKS_H
+#define O1FRESHBOOKS_H
+
+#include "o1.h"
+
+/// FreshBooks authenticator.
+class O1Freshbooks: public O1 {
+    Q_OBJECT
+
+public:
+    explicit O1Freshbooks(QObject *parent = 0): O1(parent) {
+    }
+
+    void setClientId(const QString &value) {
+        O1::setClientId(value);
+        setRequestTokenUrl(QUrl("https://" + clientId() + ".freshbooks.com/oauth/oauth_request.php"));
+        setAuthorizeUrl(QUrl("https://" + clientId() + ".freshbooks.com/oauth/oauth_authorize.php"));
+        setAccessTokenUrl(QUrl("https://" + clientId() + ".freshbooks.com/oauth/oauth_access.php"));
+    }
+};
+
+#endif // O1FRESHBOOKS_H
diff --git a/common/libkipiplugins/o2/src/o1requestor.cpp b/common/libkipiplugins/o2/src/o1requestor.cpp
new file mode 100644
index 0000000..fabb4fa
--- /dev/null
+++ b/common/libkipiplugins/o2/src/o1requestor.cpp
@@ -0,0 +1,57 @@
+#include <QDebug>
+#include <QDateTime>
+#include <QNetworkReply>
+#include <QNetworkAccessManager>
+
+#include "o1requestor.h"
+#include "o1timedreply.h"
+#include "o0globals.h"
+
+O1Requestor::O1Requestor(QNetworkAccessManager *manager, O1 *authenticator, QObject *parent): QObject(parent) {
+    manager_ = manager;
+    authenticator_ = authenticator;
+}
+
+QNetworkReply *O1Requestor::get(const QNetworkRequest &req, const QList<O0RequestParameter> &signingParameters) {
+    QNetworkRequest request = setup(req, signingParameters, QNetworkAccessManager::GetOperation);
+    return addTimer(manager_->get(request));
+}
+
+QNetworkReply *O1Requestor::post(const QNetworkRequest &req, const QList<O0RequestParameter> &signingParameters, const QByteArray &data) {
+    QNetworkRequest request = setup(req, signingParameters, QNetworkAccessManager::PostOperation);
+    return addTimer(manager_->post(request, data));
+}
+
+QNetworkReply *O1Requestor::post(const QNetworkRequest &req, const QList<O0RequestParameter> &signingParameters, QHttpMultiPart * multiPart) {
+    QNetworkRequest request = setup(req, signingParameters, QNetworkAccessManager::PostOperation);
+    return addTimer(manager_->post(request, multiPart));
+}
+
+QNetworkReply *O1Requestor::put(const QNetworkRequest &req, const QList<O0RequestParameter> &signingParameters, const QByteArray &data) {
+    QNetworkRequest request = setup(req, signingParameters, QNetworkAccessManager::PutOperation);
+    return addTimer(manager_->put(request, data));
+}
+
+QNetworkReply *O1Requestor::addTimer(QNetworkReply *reply) {
+    (void)new O1TimedReply(reply);
+    return reply;
+}
+
+QNetworkRequest O1Requestor::setup(const QNetworkRequest &req, const QList<O0RequestParameter> &signingParameters, QNetworkAccessManager::Operation operation) {
+    // Collect OAuth parameters
+    QList<O0RequestParameter> oauthParams;
+    oauthParams.append(O0RequestParameter(O2_OAUTH_CONSUMER_KEY, authenticator_->clientId().toLatin1()));
+    oauthParams.append(O0RequestParameter(O2_OAUTH_VERSION, "1.0"));
+    oauthParams.append(O0RequestParameter(O2_OAUTH_TOKEN, authenticator_->token().toLatin1()));
+    oauthParams.append(O0RequestParameter(O2_OAUTH_SIGNATURE_METHOD, authenticator_->signatureMethod().toLatin1()));
+    oauthParams.append(O0RequestParameter(O2_OAUTH_NONCE, O1::nonce()));
+    oauthParams.append(O0RequestParameter(O2_OAUTH_TIMESTAMP, QString::number(QDateTime::currentDateTimeUtc().toTime_t()).toLatin1()));
+
+    // Add signature parameter
+    oauthParams.append(O0RequestParameter(O2_OAUTH_SIGNATURE, authenticator_->generateSignature(oauthParams, req, signingParameters, operation)));
+
+    // Return a copy of the original request with authorization header set
+    QNetworkRequest request(req);
+    request.setRawHeader(O2_HTTP_AUTHORIZATION_HEADER, O1::buildAuthorizationHeader(oauthParams));
+    return request;
+}
diff --git a/common/libkipiplugins/o2/src/o1requestor.h b/common/libkipiplugins/o2/src/o1requestor.h
new file mode 100644
index 0000000..5de2fb2
--- /dev/null
+++ b/common/libkipiplugins/o2/src/o1requestor.h
@@ -0,0 +1,61 @@
+#ifndef O1REQUESTOR_H
+#define O1REQUESTOR_H
+
+#include <QObject>
+#include <QNetworkRequest>
+#include <QByteArray>
+
+#include "o1.h"
+
+class QNetworkAccessManager;
+class QNetworkReply;
+class O1;
+
+/// Makes authenticated requests using OAuth 1.0.
+class O1Requestor: public QObject {
+    Q_OBJECT
+
+public:
+    explicit O1Requestor(QNetworkAccessManager *manager, O1 *authenticator, QObject *parent = 0);
+
+public Q_SLOTS:
+    /// Make a GET request.
+    /// @param  req                 Network request.
+    /// @param  signingParameters   Extra (non-OAuth) parameters participating in signing.
+    /// @return Reply.
+    QNetworkReply *get(const QNetworkRequest &req, const QList<O0RequestParameter> &signingParameters);
+
+    /// Make a POST request.
+    /// @param  req                 Network request.
+    /// @param  signingParameters   Extra (non-OAuth) parameters participating in signing.
+    /// @param  data                Request payload.
+    /// @return Reply.
+    QNetworkReply *post(const QNetworkRequest &req, const QList<O0RequestParameter> &signingParameters, const QByteArray &data);
+
+    /// Make a POST request.
+    /// @param  req                 Network request.
+    /// @param  signingParameters   Extra (non-OAuth) parameters participating in signing.
+    /// @param  multiPart           HTTPMultiPart.
+    /// @return Reply.
+    QNetworkReply *post(const QNetworkRequest &req, const QList<O0RequestParameter> &signingParameters, QHttpMultiPart *multiPart);
+
+    /// Make a PUT request.
+    /// @param  req                 Network request.
+    /// @param  signingParameters   Extra (non-OAuth) parameters participating in signing.
+    /// @param  data                Request payload.
+    /// @return Reply.
+    QNetworkReply *put(const QNetworkRequest &req, const QList<O0RequestParameter> &signingParameters, const QByteArray &data);
+
+protected:
+    /// Return new request based on the original, with the "Authentication:" header added.
+    QNetworkRequest setup(const QNetworkRequest &request, const QList<O0RequestParameter> &signingParameters, QNetworkAccessManager::Operation operation);
+
+    /// Augment reply with a timer.
+    QNetworkReply *addTimer(QNetworkReply *reply);
+
+    QNetworkAccessManager *manager_;
+    O1 *authenticator_;
+};
+
+
+#endif // O1REQUESTOR_H
diff --git a/common/libkipiplugins/o2/src/o1timedreply.cpp b/common/libkipiplugins/o2/src/o1timedreply.cpp
new file mode 100644
index 0000000..14897f5
--- /dev/null
+++ b/common/libkipiplugins/o2/src/o1timedreply.cpp
@@ -0,0 +1,20 @@
+#include <QTimer>
+#include <QNetworkReply>
+
+#include "o1timedreply.h"
+
+O1TimedReply::O1TimedReply(QNetworkReply *parent, int pTimeout): QTimer(parent) {
+    setSingleShot(true);
+    setInterval(pTimeout);
+    connect(this, SIGNAL(timeout()), this, SLOT(onTimeout()));
+    connect(parent, SIGNAL(finished()), this, SLOT(onFinished()));
+}
+
+void O1TimedReply::onFinished() {
+    stop();
+    Q_EMIT finished();
+}
+
+void O1TimedReply::onTimeout() {
+    Q_EMIT error(QNetworkReply::TimeoutError);
+}
diff --git a/common/libkipiplugins/o2/src/o1timedreply.h b/common/libkipiplugins/o2/src/o1timedreply.h
new file mode 100644
index 0000000..174cc0c
--- /dev/null
+++ b/common/libkipiplugins/o2/src/o1timedreply.h
@@ -0,0 +1,25 @@
+#ifndef O1TIMEDREPLY_H
+#define O1TIMEDREPLY_H
+
+#include <QNetworkReply>
+#include <QTimer>
+
+/// A timer connected to a network reply.
+class O1TimedReply: public QTimer {
+    Q_OBJECT
+
+public:
+    explicit O1TimedReply(QNetworkReply *parent, int pTimeout=60*1000);
+
+Q_SIGNALS:
+    /// Emitted when we have timed out waiting for the network reply.
+    void error(QNetworkReply::NetworkError);
+    /// Emitted when the network reply has responded.
+    void finished();
+
+private Q_SLOTS:
+    void onFinished();
+    void onTimeout();
+};
+
+#endif
diff --git a/common/libkipiplugins/o2/src/o1twitter.h b/common/libkipiplugins/o2/src/o1twitter.h
new file mode 100644
index 0000000..4a4c7bb
--- /dev/null
+++ b/common/libkipiplugins/o2/src/o1twitter.h
@@ -0,0 +1,18 @@
+#ifndef O1TWITTER_H
+#define O1TWITTER_H
+
+#include "o1.h"
+
+/// Twitter OAuth 1.0 client
+class O1Twitter: public O1 {
+    Q_OBJECT
+
+public:
+    explicit O1Twitter(QObject *parent = 0): O1(parent) {
+        setRequestTokenUrl(QUrl("https://api.twitter.com/oauth/request_token"));
+        setAuthorizeUrl(QUrl("https://api.twitter.com/oauth/authenticate"));
+        setAccessTokenUrl(QUrl("https://api.twitter.com/oauth/access_token"));
+    }
+};
+
+#endif // O1TWITTER_H
diff --git a/common/libkipiplugins/o2/src/o2.cpp b/common/libkipiplugins/o2/src/o2.cpp
new file mode 100644
index 0000000..e8108da
--- /dev/null
+++ b/common/libkipiplugins/o2/src/o2.cpp
@@ -0,0 +1,417 @@
+#include <QList>
+#include <QPair>
+#include <QDebug>
+#include <QTcpServer>
+#include <QMap>
+#include <QNetworkRequest>
+#include <QNetworkReply>
+#include <QNetworkAccessManager>
+#include <QDateTime>
+#include <QCryptographicHash>
+#include <QTimer>
+#include <QVariantMap>
+
+#if QT_VERSION >= 0x050000
+#include <QUrlQuery>
+#include <QJsonDocument>
+#include <QJsonObject>
+#else
+#include <QScriptEngine>
+#include <QScriptValueIterator>
+#endif
+
+#include "o2.h"
+#include "o2replyserver.h"
+#include "o0globals.h"
+#include "o0settingsstore.h"
+
+/// Parse JSON data into a QVariantMap
+static QVariantMap parseTokenResponse(const QByteArray &data) {
+#if QT_VERSION >= 0x050000
+    QJsonParseError err;
+    QJsonDocument doc = QJsonDocument::fromJson(data, &err);
+    if (err.error != QJsonParseError::NoError) {
+        qWarning() << "parseTokenResponse: Failed to parse token response due to err:" << err.errorString();
+        return QVariantMap();
+    }
+
+    if (!doc.isObject()) {
+        qWarning() << "parseTokenResponse: Token response is not an object";
+        return QVariantMap();
+    }
+
+    return doc.object().toVariantMap();
+#else
+    QScriptEngine engine;
+    QScriptValue value = engine.evaluate("(" + QString(data) + ")");
+    QScriptValueIterator it(value);
+    QVariantMap map;
+
+    while (it.hasNext()) {
+        it.next();
+        map.insert(it.name(), it.value().toVariant());
+    }
+
+    return map;
+#endif
+}
+
+/// Add query parameters to a query
+static void addQueryParametersToUrl(QUrl &url,  QList<QPair<QString, QString> > parameters) {
+#if QT_VERSION < 0x050000
+    url.setQueryItems(parameters);
+#else
+    QUrlQuery query(url);
+    query.setQueryItems(parameters);
+    url.setQuery(query);
+#endif
+}
+
+O2::O2(QObject *parent): O0BaseAuth(parent) {
+    manager_ = new QNetworkAccessManager(this);
+    replyServer_ = new O2ReplyServer(this);
+    grantFlow_ = GrantFlowAuthorizationCode;
+    localhostPolicy_ = QString(O2_CALLBACK_URL);
+    qRegisterMetaType<QNetworkReply::NetworkError>("QNetworkReply::NetworkError");
+    connect(replyServer_, SIGNAL(verificationReceived(QMap<QString,QString>)), this, SLOT(onVerificationReceived(QMap<QString,QString>)));
+}
+
+O2::GrantFlow O2::grantFlow() {
+    return grantFlow_;
+}
+
+void O2::setGrantFlow(O2::GrantFlow value) {
+    grantFlow_ = value;
+    Q_EMIT grantFlowChanged();
+}
+
+QString O2::username() {
+    return username_;
+}
+
+void O2::setUsername(const QString &value) {
+    username_ = value;
+    Q_EMIT usernameChanged();
+}
+
+QString O2::password() {
+    return password_;
+}
+
+void O2::setPassword(const QString &value) {
+    password_ = value;
+    Q_EMIT passwordChanged();
+}
+
+QString O2::scope() {
+    return scope_;
+}
+
+void O2::setScope(const QString &value) {
+    scope_ = value;
+    Q_EMIT scopeChanged();
+}
+
+QString O2::requestUrl() {
+    return requestUrl_.toString();
+}
+
+void O2::setRequestUrl(const QString &value) {
+    requestUrl_ = value;
+    Q_EMIT requestUrlChanged();
+}
+
+QString O2::tokenUrl() {
+    return tokenUrl_.toString();
+}
+
+void O2::setTokenUrl(const QString &value) {
+    tokenUrl_= value;
+    Q_EMIT tokenUrlChanged();
+}
+
+QString O2::refreshTokenUrl() {
+    return refreshTokenUrl_.toString();
+}
+
+void O2::setRefreshTokenUrl(const QString &value) {
+    refreshTokenUrl_ = value;
+    Q_EMIT refreshTokenUrlChanged();
+}
+
+void O2::link() {
+    qDebug() << "O2::link";
+
+    if (linked()) {
+        qDebug() << "O2::link: Linked already";
+        Q_EMIT linkingSucceeded();
+        return;
+    }
+
+    setLinked(false);
+    setToken("");
+    setTokenSecret("");
+    setExtraTokens(QVariantMap());
+    setRefreshToken(QString());
+    setExpires(0);
+
+    if (grantFlow_ == GrantFlowAuthorizationCode) {
+        // Start listening to authentication replies
+        replyServer_->listen(QHostAddress::Any, localPort_);
+
+        // Save redirect URI, as we have to reuse it when requesting the access token
+        redirectUri_ = localhostPolicy_.arg(replyServer_->serverPort());
+
+        // Assemble intial authentication URL
+        QList<QPair<QString, QString> > parameters;
+        parameters.append(qMakePair(QString(O2_OAUTH2_RESPONSE_TYPE), (grantFlow_ == GrantFlowAuthorizationCode)? QString(O2_OAUTH2_GRANT_TYPE_CODE): QString(O2_OAUTH2_GRANT_TYPE_TOKEN)));
+        parameters.append(qMakePair(QString(O2_OAUTH2_CLIENT_ID), clientId_));
+        parameters.append(qMakePair(QString(O2_OAUTH2_REDIRECT_URI), redirectUri_));
+        parameters.append(qMakePair(QString(O2_OAUTH2_SCOPE), scope_));
+        parameters.append(qMakePair(QString(O2_OAUTH2_API_KEY), apiKey_));
+
+        // Show authentication URL with a web browser
+        QUrl url(requestUrl_);
+        addQueryParametersToUrl(url, parameters);
+        qDebug() << "O2::link: Emit openBrowser" << url.toString();
+        Q_EMIT openBrowser(url);
+    } else if (grantFlow_ == GrantFlowResourceOwnerPasswordCredentials) {
+        QList<O0RequestParameter> parameters;
+        parameters.append(O0RequestParameter(O2_OAUTH2_CLIENT_ID, clientId_.toUtf8()));
+        parameters.append(O0RequestParameter(O2_OAUTH2_CLIENT_SECRET, clientSecret_.toUtf8()));
+        parameters.append(O0RequestParameter(O2_OAUTH2_USERNAME, username_.toUtf8()));
+        parameters.append(O0RequestParameter(O2_OAUTH2_PASSWORD, password_.toUtf8()));
+        parameters.append(O0RequestParameter(O2_OAUTH2_GRANT_TYPE, O2_OAUTH2_GRANT_TYPE_PASSWORD));
+        parameters.append(O0RequestParameter(O2_OAUTH2_SCOPE, scope_.toUtf8()));
+        parameters.append(O0RequestParameter(O2_OAUTH2_API_KEY, apiKey_.toUtf8()));
+        QByteArray payload = O0BaseAuth::createQueryParameters(parameters);
+
+        QUrl url(tokenUrl_);
+        QNetworkRequest tokenRequest(url);
+        tokenRequest.setHeader(QNetworkRequest::ContentTypeHeader, "application/x-www-form-urlencoded");
+        QNetworkReply *tokenReply = manager_->post(tokenRequest, payload);
+
+        connect(tokenReply, SIGNAL(finished()), this, SLOT(onTokenReplyFinished()), Qt::QueuedConnection);
+        connect(tokenReply, SIGNAL(error(QNetworkReply::NetworkError)), this, SLOT(onTokenReplyError(QNetworkReply::NetworkError)), Qt::QueuedConnection);
+    }
+}
+
+void O2::unlink() {
+    qDebug() << "O2::unlink";
+    setLinked(false);
+    setToken(QString());
+    setRefreshToken(QString());
+    setExpires(0);
+    setExtraTokens(QVariantMap());
+    Q_EMIT linkingSucceeded();
+}
+
+void O2::onVerificationReceived(const QMap<QString, QString> response) {
+    qDebug() << "O2::onVerificationReceived:" << response;
+    qDebug() << "O2::onVerificationReceived: Emitting closeBrowser()";
+    Q_EMIT closeBrowser();
+
+    if (response.contains("error")) {
+        qWarning() << "O2::onVerificationReceived: Verification failed: " << response;
+        Q_EMIT linkingFailed();
+        return;
+    }
+
+    if (grantFlow_ == GrantFlowAuthorizationCode) {
+        // Save access code
+        setCode(response.value(QString(O2_OAUTH2_GRANT_TYPE_CODE)));
+
+        // Exchange access code for access/refresh tokens
+        QString query;
+        if(!apiKey_.isEmpty())
+            query = QString("?" + QString(O2_OAUTH2_API_KEY) + "=" + apiKey_);
+        QNetworkRequest tokenRequest(QUrl(tokenUrl_.toString() + query));
+        tokenRequest.setHeader(QNetworkRequest::ContentTypeHeader, O2_MIME_TYPE_XFORM);
+        QMap<QString, QString> parameters;
+        parameters.insert(O2_OAUTH2_GRANT_TYPE_CODE, code());
+        parameters.insert(O2_OAUTH2_CLIENT_ID, clientId_);
+        parameters.insert(O2_OAUTH2_CLIENT_SECRET, clientSecret_);
+        parameters.insert(O2_OAUTH2_REDIRECT_URI, redirectUri_);
+        parameters.insert(O2_OAUTH2_GRANT_TYPE, O2_AUTHORIZATION_CODE);
+        QByteArray data = buildRequestBody(parameters);
+        QNetworkReply *tokenReply = manager_->post(tokenRequest, data);
+        timedReplies_.add(tokenReply);
+        connect(tokenReply, SIGNAL(finished()), this, SLOT(onTokenReplyFinished()), Qt::QueuedConnection);
+        connect(tokenReply, SIGNAL(error(QNetworkReply::NetworkError)), this, SLOT(onTokenReplyError(QNetworkReply::NetworkError)), Qt::QueuedConnection);
+    } else {
+        setToken(response.value(O2_OAUTH2_ACCESS_TOKEN));
+        setRefreshToken(response.value(O2_OAUTH2_REFRESH_TOKEN));
+    }
+}
+
+QString O2::code() {
+    QString key = QString(O2_KEY_CODE).arg(clientId_);
+    return store_->value(key);
+}
+
+void O2::setCode(const QString &c) {
+    QString key = QString(O2_KEY_CODE).arg(clientId_);
+    store_->setValue(key, c);
+}
+
+void O2::onTokenReplyFinished() {
+    qDebug() << "O2::onTokenReplyFinished";
+    QNetworkReply *tokenReply = qobject_cast<QNetworkReply *>(sender());
+    if (tokenReply->error() == QNetworkReply::NoError) {
+        QByteArray replyData = tokenReply->readAll();
+        QVariantMap tokens = parseTokenResponse(replyData);
+
+        // Check for mandatory tokens
+        if (tokens.contains(O2_OAUTH2_ACCESS_TOKEN)) {
+            setToken(tokens.take(O2_OAUTH2_ACCESS_TOKEN).toString());
+            bool ok = false;
+            int expiresIn = tokens.take(O2_OAUTH2_EXPIRES_IN).toInt(&ok);
+            if (ok) {
+                qDebug() << "O2::onTokenReplyFinished: Token expires in" << expiresIn << "seconds";
+                setExpires(QDateTime::currentMSecsSinceEpoch() / 1000 + expiresIn);
+            }
+            setRefreshToken(tokens.take(O2_OAUTH2_REFRESH_TOKEN).toString());
+            setExtraTokens(tokens);
+            timedReplies_.remove(tokenReply);
+            setLinked(true);
+            Q_EMIT linkingSucceeded();
+        } else {
+            qWarning() << "O2::onTokenReplyFinished: oauth_token missing from response" << replyData;
+            Q_EMIT linkingFailed();
+        }
+    }
+    tokenReply->deleteLater();
+}
+
+void O2::onTokenReplyError(QNetworkReply::NetworkError error) {
+    QNetworkReply *tokenReply = qobject_cast<QNetworkReply *>(sender());
+    qWarning() << "O2::onTokenReplyError: " << error << ": " << tokenReply->errorString();
+    qDebug() << "O2::onTokenReplyError: " << tokenReply->readAll();
+    setToken(QString());
+    setRefreshToken(QString());
+    timedReplies_.remove(tokenReply);
+    Q_EMIT linkingFailed();
+}
+
+QByteArray O2::buildRequestBody(const QMap<QString, QString> &parameters) {
+    QByteArray body;
+    bool first = true;
+    foreach (QString key, parameters.keys()) {
+        if (first) {
+            first = false;
+        } else {
+            body.append("&");
+        }
+        QString value = parameters.value(key);
+        body.append(QUrl::toPercentEncoding(key) + QString("=").toUtf8() + QUrl::toPercentEncoding(value));
+    }
+    return body;
+}
+
+int O2::expires() {
+    QString key = QString(O2_KEY_EXPIRES).arg(clientId_);
+    return store_->value(key).toInt();
+}
+
+void O2::setExpires(int v) {
+    QString key = QString(O2_KEY_EXPIRES).arg(clientId_);
+    store_->setValue(key, QString::number(v));
+}
+
+QString O2::refreshToken() {
+    QString key = QString(O2_KEY_REFRESH_TOKEN).arg(clientId_);
+    return store_->value(key);
+}
+
+void O2::setRefreshToken(const QString &v) {
+    qDebug() << "O2::setRefreshToken" << v.left(4) << "...";
+    QString key = QString(O2_KEY_REFRESH_TOKEN).arg(clientId_);
+    store_->setValue(key, v);
+}
+
+void O2::refresh() {
+    qDebug() << "O2::refresh: Token: ..." << refreshToken().right(7);
+
+    if (refreshToken().isEmpty()) {
+        qWarning() << "O2::refresh: No refresh token";
+        onRefreshError(QNetworkReply::AuthenticationRequiredError);
+        return;
+    }
+    if (refreshTokenUrl_.isEmpty()) {
+        qWarning() << "O2::refresh: Refresh token URL not set";
+        onRefreshError(QNetworkReply::AuthenticationRequiredError);
+        return;
+    }
+
+    QNetworkRequest refreshRequest(refreshTokenUrl_);
+    refreshRequest.setHeader(QNetworkRequest::ContentTypeHeader, O2_MIME_TYPE_XFORM);
+    QMap<QString, QString> parameters;
+    parameters.insert(O2_OAUTH2_CLIENT_ID, clientId_);
+    parameters.insert(O2_OAUTH2_CLIENT_SECRET, clientSecret_);
+    parameters.insert(O2_OAUTH2_REFRESH_TOKEN, refreshToken());
+    parameters.insert(O2_OAUTH2_GRANT_TYPE, O2_OAUTH2_REFRESH_TOKEN);
+
+    QByteArray data = buildRequestBody(parameters);
+    QNetworkReply *refreshReply = manager_->post(refreshRequest, data);
+    timedReplies_.add(refreshReply);
+    connect(refreshReply, SIGNAL(finished()), this, SLOT(onRefreshFinished()), Qt::QueuedConnection);
+    connect(refreshReply, SIGNAL(error(QNetworkReply::NetworkError)), this, SLOT(onRefreshError(QNetworkReply::NetworkError)), Qt::QueuedConnection);
+}
+
+void O2::onRefreshFinished() {
+    QNetworkReply *refreshReply = qobject_cast<QNetworkReply *>(sender());
+    qDebug() << "O2::onRefreshFinished: Error" << (int)refreshReply->error() << refreshReply->errorString();
+    if (refreshReply->error() == QNetworkReply::NoError) {
+        QByteArray reply = refreshReply->readAll();
+        QVariantMap tokens = parseTokenResponse(reply);
+        setToken(tokens.value(O2_OAUTH2_ACCESS_TOKEN).toString());
+        setExpires(QDateTime::currentMSecsSinceEpoch() / 1000 + tokens.value(O2_OAUTH2_EXPIRES_IN).toInt());
+        setRefreshToken(tokens.value(O2_OAUTH2_REFRESH_TOKEN).toString());
+        timedReplies_.remove(refreshReply);
+        setLinked(true);
+        Q_EMIT linkingSucceeded();
+        Q_EMIT refreshFinished(QNetworkReply::NoError);
+        qDebug() << " New token expires in" << expires() << "seconds";
+    }
+    refreshReply->deleteLater();
+}
+
+void O2::onRefreshError(QNetworkReply::NetworkError error) {
+    QNetworkReply *refreshReply = qobject_cast<QNetworkReply *>(sender());
+    qWarning() << "O2::onRefreshError: " << error;
+    unlink();
+    timedReplies_.remove(refreshReply);
+    Q_EMIT refreshFinished(error);
+}
+
+QString O2::localhostPolicy() const {
+    return localhostPolicy_;
+}
+
+void O2::setLocalhostPolicy(const QString &value) {
+    localhostPolicy_ = value;
+}
+
+QString O2::apiKey() {
+    return apiKey_;
+}
+
+void O2::setApiKey(const QString &value) {
+    apiKey_ = value;
+}
+
+QByteArray O2::replyContent() {
+    return replyServer_->replyContent();
+}
+
+void O2::setReplyContent(const QByteArray &value) {
+    replyServer_->setReplyContent(value);
+}
+
+bool O2::ignoreSslErrors() {
+    return timedReplies_.ignoreSslErrors();
+}
+
+void O2::setIgnoreSslErrors(bool ignoreSslErrors) {
+    timedReplies_.setIgnoreSslErrors(ignoreSslErrors);
+}
diff --git a/common/libkipiplugins/o2/src/o2.h b/common/libkipiplugins/o2/src/o2.h
new file mode 100644
index 0000000..250ea50
--- /dev/null
+++ b/common/libkipiplugins/o2/src/o2.h
@@ -0,0 +1,170 @@
+#ifndef O2_H
+#define O2_H
+
+#include <QNetworkAccessManager>
+#include <QNetworkRequest>
+#include <QNetworkReply>
+#include <QPair>
+
+#include "o0baseauth.h"
+#include "o2reply.h"
+#include "o0abstractstore.h"
+
+class O2ReplyServer;
+
+/// Simple OAuth2 authenticator.
+class O2: public O0BaseAuth {
+    Q_OBJECT
+    Q_ENUMS(GrantFlow)
+
+public:
+    /// Authorization flow types.
+    enum GrantFlow {
+        GrantFlowAuthorizationCode, ///< @see http://tools.ietf.org/html/draft-ietf-oauth-v2-15#section-4.1
+        GrantFlowImplicit, ///< @see http://tools.ietf.org/html/draft-ietf-oauth-v2-15#section-4.2
+        GrantFlowResourceOwnerPasswordCredentials,
+    };
+
+    /// Authorization flow.
+    Q_PROPERTY(GrantFlow grantFlow READ grantFlow WRITE setGrantFlow NOTIFY grantFlowChanged)
+    GrantFlow grantFlow();
+    void setGrantFlow(GrantFlow value);
+
+    /// Resource owner username.
+    /// O2 instances with the same (username, password) share the same "linked" and "token" properties.
+    Q_PROPERTY(QString username READ username WRITE setUsername NOTIFY usernameChanged)
+    QString username();
+    void setUsername(const QString &value);
+
+    /// Resource owner password.
+    /// O2 instances with the same (username, password) share the same "linked" and "token" properties.
+    Q_PROPERTY(QString password READ password WRITE setPassword NOTIFY passwordChanged)
+    QString password();
+    void setPassword(const QString &value);
+
+    /// Scope of authentication.
+    Q_PROPERTY(QString scope READ scope WRITE setScope NOTIFY scopeChanged)
+    QString scope();
+    void setScope(const QString &value);
+
+    /// Localhost policy. By default it's value is http://127.0.0.1:%1/, however some services may
+    /// require the use of http://localhost:%1/ or any other value.
+    Q_PROPERTY(QString localhostPolicy READ localhostPolicy WRITE setLocalhostPolicy)
+    QString localhostPolicy() const;
+    void setLocalhostPolicy(const QString &value);
+
+    /// API key.
+    Q_PROPERTY(QString apiKey READ apiKey WRITE setApiKey)
+    QString apiKey();
+    void setApiKey(const QString &value);
+
+    /// Page content on local host after successful oauth.
+    /// Provide it in case you do not want to close the browser, but display something
+    Q_PROPERTY(QByteArray replyContent READ replyContent WRITE setReplyContent)
+    QByteArray replyContent();
+    void setReplyContent(const QByteArray &value);
+
+    /// Allow ignoring SSL errors?
+    /// E.g. SurveyMonkey fails on Mac due to SSL error. Ignoring the error circumvents the problem
+    Q_PROPERTY(bool ignoreSslErrors READ ignoreSslErrors WRITE setIgnoreSslErrors)
+    bool ignoreSslErrors();
+    void setIgnoreSslErrors(bool ignoreSslErrors);
+
+    /// Request URL.
+    Q_PROPERTY(QString requestUrl READ requestUrl WRITE setRequestUrl NOTIFY requestUrlChanged)
+    QString requestUrl();
+    void setRequestUrl(const QString &value);
+
+    /// Token request URL.
+    Q_PROPERTY(QString tokenUrl READ tokenUrl WRITE setTokenUrl NOTIFY tokenUrlChanged)
+    QString tokenUrl();
+    void setTokenUrl(const QString &value);
+
+    /// Token refresh URL.
+    Q_PROPERTY(QString refreshTokenUrl READ refreshTokenUrl WRITE setRefreshTokenUrl NOTIFY refreshTokenUrlChanged)
+    QString refreshTokenUrl();
+    void setRefreshTokenUrl(const QString &value);
+
+public:
+    /// Constructor.
+    /// @param  parent  Parent object.
+    explicit O2(QObject *parent = 0);
+
+    /// Get authentication code.
+    QString code();
+
+    /// Get refresh token.
+    QString refreshToken();
+
+    /// Get token expiration time (seconds from Epoch).
+    int expires();
+
+public Q_SLOTS:
+    /// Authenticate.
+    Q_INVOKABLE virtual void link();
+
+    /// De-authenticate.
+    Q_INVOKABLE virtual void unlink();
+
+    /// Refresh token.
+    Q_INVOKABLE void refresh();
+
+Q_SIGNALS:
+    /// Emitted when a token refresh has been completed or failed.
+    void refreshFinished(QNetworkReply::NetworkError error);
+
+    // Property change signals
+    void grantFlowChanged();
+    void scopeChanged();
+    void usernameChanged();
+    void passwordChanged();
+    void requestUrlChanged();
+    void refreshTokenUrlChanged();
+    void tokenUrlChanged();
+
+protected Q_SLOTS:
+    /// Handle verification response.
+    virtual void onVerificationReceived(QMap<QString, QString>);
+
+    /// Handle completion of a token request.
+    virtual void onTokenReplyFinished();
+
+    /// Handle failure of a token request.
+    virtual void onTokenReplyError(QNetworkReply::NetworkError error);
+
+    /// Handle completion of a refresh request.
+    virtual void onRefreshFinished();
+
+    /// Handle failure of a refresh request.
+    virtual void onRefreshError(QNetworkReply::NetworkError error);
+
+protected:
+    /// Build HTTP request body.
+    QByteArray buildRequestBody(const QMap<QString, QString> &parameters);
+
+    /// Set authentication code.
+    void setCode(const QString &v);
+
+    /// Set refresh token.
+    void setRefreshToken(const QString &v);
+
+    /// Set token expiration time.
+    void setExpires(int v);
+
+protected:
+    QString username_;
+    QString password_;
+    QUrl requestUrl_;
+    QUrl tokenUrl_;
+    QUrl refreshTokenUrl_;
+    QString scope_;
+    QString code_;
+    QString localhostPolicy_;
+    QString apiKey_;
+    QNetworkAccessManager *manager_;
+    O2ReplyServer *replyServer_;
+    O2ReplyList timedReplies_;
+    GrantFlow grantFlow_;
+};
+
+#endif // O2_H
diff --git a/common/libkipiplugins/o2/src/o2facebook.cpp b/common/libkipiplugins/o2/src/o2facebook.cpp
new file mode 100644
index 0000000..158be4b
--- /dev/null
+++ b/common/libkipiplugins/o2/src/o2facebook.cpp
@@ -0,0 +1,90 @@
+#include <QDebug>
+#include <QMap>
+#include <QNetworkReply>
+#include <QString>
+#include <QStringList>
+#include <QUrl>
+#if QT_VERSION >= 0x050000
+#include <QUrlQuery>
+#endif
+
+#include "o2facebook.h"
+#include "o0globals.h"
+
+static const char *FbEndpoint = "https://graph.facebook.com/oauth/authorize?display=touch";
+static const char *FbTokenUrl = "https://graph.facebook.com/oauth/access_token";
+static const char *FbExpiresKey = "expires";
+
+O2Facebook::O2Facebook(QObject *parent): O2(parent) {
+    setRequestUrl(FbEndpoint);
+    setTokenUrl(FbTokenUrl);
+}
+
+void O2Facebook::onVerificationReceived(const QMap<QString, QString> response) {
+    qDebug() << "O2Facebook::onVerificationReceived: Emitting closeBrowser()";
+    Q_EMIT closeBrowser();
+
+    if (response.contains("error")) {
+        qWarning() << "O2Facebook::onVerificationReceived: Verification failed";
+        foreach (QString key, response.keys()) {
+            qWarning() << "O2Facebook::onVerificationReceived:" << key << response.value(key);
+        }
+        Q_EMIT linkingFailed();
+        return;
+    }
+
+    // Save access code
+    setCode(response.value(O2_OAUTH2_GRANT_TYPE_CODE));
+
+    // Exchange access code for access/refresh tokens
+    QUrl url(tokenUrl_);
+#if QT_VERSION < 0x050000
+    url.addQueryItem(O2_OAUTH2_CLIENT_ID, clientId_);
+    url.addQueryItem(O2_OAUTH2_CLIENT_SECRET, clientSecret_);
+    url.addQueryItem(O2_OAUTH2_SCOPE, scope_);
+    url.addQueryItem(O2_OAUTH2_CODE, code());
+    url.addQueryItem(O2_OAUTH2_REDIRECT_URI, redirectUri_);
+#else
+    QUrlQuery query(url);
+    query.addQueryItem(O2_OAUTH2_CLIENT_ID, clientId_);
+    query.addQueryItem(O2_OAUTH2_CLIENT_SECRET, clientSecret_);
+    query.addQueryItem(O2_OAUTH2_SCOPE, scope_);
+    query.addQueryItem(O2_OAUTH2_GRANT_TYPE_CODE, code());
+    query.addQueryItem(O2_OAUTH2_REDIRECT_URI, redirectUri_);
+    url.setQuery(query);
+#endif
+
+    QNetworkRequest tokenRequest(url);
+    QNetworkReply *tokenReply = manager_->get(tokenRequest);
+    timedReplies_.add(tokenReply);
+    connect(tokenReply, SIGNAL(finished()), this, SLOT(onTokenReplyFinished()), Qt::QueuedConnection);
+    connect(tokenReply, SIGNAL(error(QNetworkReply::NetworkError)), this, SLOT(onTokenReplyError(QNetworkReply::NetworkError)), Qt::QueuedConnection);
+}
+
+void O2Facebook::onTokenReplyFinished() {
+    qDebug() << "O2Facebook::onTokenReplyFinished";
+
+    QNetworkReply *tokenReply = qobject_cast<QNetworkReply *>(sender());
+    if (tokenReply->error() == QNetworkReply::NoError) {
+        // Process reply
+        QByteArray replyData = tokenReply->readAll();
+        QVariantMap reply;
+        foreach (QString pair, QString(replyData).split("&")) {
+            QStringList kv = pair.split("=");
+            if (kv.length() == 2) {
+                reply.insert(kv[0], kv[1]);
+            }
+        }
+
+        // Interpret reply
+        setToken(reply.value(O2_OAUTH2_ACCESS_TOKEN, QString()).toString());
+        setExpires(reply.value(FbExpiresKey).toInt());
+        setRefreshToken(reply.value(O2_OAUTH2_REFRESH_TOKEN, QString()).toString());
+        setExtraTokens(reply);
+        timedReplies_.remove(tokenReply);
+        setLinked(true);
+        Q_EMIT linkingSucceeded();
+    } else {
+        qWarning() << "O2Facebook::onTokenReplyFinished:" << tokenReply->errorString();
+    }
+}
diff --git a/common/libkipiplugins/o2/src/o2facebook.h b/common/libkipiplugins/o2/src/o2facebook.h
new file mode 100644
index 0000000..160e39e
--- /dev/null
+++ b/common/libkipiplugins/o2/src/o2facebook.h
@@ -0,0 +1,18 @@
+#ifndef O2FACEBOOK_H
+#define O2FACEBOOK_H
+
+#include "o2.h"
+
+/// Facebook's dialect of OAuth 2.0
+class O2Facebook: public O2 {
+    Q_OBJECT
+
+public:
+    explicit O2Facebook(QObject *parent = 0);
+
+protected Q_SLOTS:
+    void onVerificationReceived(QMap<QString, QString>);
+    virtual void onTokenReplyFinished();
+};
+
+#endif // O2FACEBOOK_H
diff --git a/common/libkipiplugins/o2/src/o2gft.cpp b/common/libkipiplugins/o2/src/o2gft.cpp
new file mode 100644
index 0000000..ce1b7db
--- /dev/null
+++ b/common/libkipiplugins/o2/src/o2gft.cpp
@@ -0,0 +1,13 @@
+#include "o2gft.h"
+
+static const char *GftScope = "https://www.googleapis.com/auth/fusiontables";
+static const char *GftEndpoint = "https://accounts.google.com/o/oauth2/auth";
+static const char *GftTokenUrl = "https://accounts.google.com/o/oauth2/token";
+static const char *GftRefreshUrl = "https://accounts.google.com/o/oauth2/token";
+
+O2Gft::O2Gft(QObject *parent): O2(parent) {
+    setRequestUrl(GftEndpoint);
+    setTokenUrl(GftTokenUrl);
+    setRefreshTokenUrl(GftRefreshUrl);
+    setScope(GftScope);
+}
diff --git a/common/libkipiplugins/o2/src/o2gft.h b/common/libkipiplugins/o2/src/o2gft.h
new file mode 100644
index 0000000..fa6dc41
--- /dev/null
+++ b/common/libkipiplugins/o2/src/o2gft.h
@@ -0,0 +1,14 @@
+#ifndef O2GFT_H
+#define O2GFT_H
+
+#include "o2.h"
+
+/// Google Fusion Tables' dialect of OAuth 2.0
+class O2Gft: public O2 {
+    Q_OBJECT
+
+public:
+    explicit O2Gft(QObject *parent = 0);
+};
+
+#endif // O2GFT_H
diff --git a/common/libkipiplugins/o2/src/o2hubic.cpp b/common/libkipiplugins/o2/src/o2hubic.cpp
new file mode 100644
index 0000000..5671cb9
--- /dev/null
+++ b/common/libkipiplugins/o2/src/o2hubic.cpp
@@ -0,0 +1,17 @@
+#include "o2hubic.h"
+#include "o2globals.h"
+#include "o2replyserver.h"
+#include <QHostAddress>
+
+static const char *HubicScope = "usage.r,account.r,getAllLinks.r,credentials.r,activate.w,links.drw";
+static const char *HubicEndpoint = "https://api.hubic.com/oauth/auth/";
+static const char *HubicTokenUrl = "https://api.hubic.com/oauth/token/";
+static const char *HubicRefreshUrl = "https://api.hubic.com/oauth/token/";
+
+O2Hubic::O2Hubic(QObject *parent): O2(parent) {
+    setRequestUrl(HubicEndpoint);
+    setTokenUrl(HubicTokenUrl);
+    setRefreshTokenUrl(HubicRefreshUrl);
+    setScope(HubicScope);
+    setLocalhostPolicy("http://localhost:%1/");
+}
diff --git a/common/libkipiplugins/o2/src/o2hubic.h b/common/libkipiplugins/o2/src/o2hubic.h
new file mode 100644
index 0000000..33de56f
--- /dev/null
+++ b/common/libkipiplugins/o2/src/o2hubic.h
@@ -0,0 +1,17 @@
+#ifndef O2HUBIC_H
+#define O2HUBIC_H
+
+#include "o2.h"
+
+/// Hubic's dialect of OAuth 2.0
+class O2Hubic: public O2 {
+    Q_OBJECT
+
+public:
+    /// Constructor.
+    /// @param  parent  Parent object.
+    explicit O2Hubic(QObject *parent = 0);
+
+};
+
+#endif // O2_HUBIC
diff --git a/common/libkipiplugins/o2/src/o2reply.cpp b/common/libkipiplugins/o2/src/o2reply.cpp
new file mode 100644
index 0000000..4e03172
--- /dev/null
+++ b/common/libkipiplugins/o2/src/o2reply.cpp
@@ -0,0 +1,58 @@
+#include <QTimer>
+#include <QNetworkReply>
+
+#include "o2reply.h"
+
+O2Reply::O2Reply(QNetworkReply *r, int timeOut, QObject *parent): QTimer(parent), reply(r) {
+    setSingleShot(true);
+    connect(this, SIGNAL(error(QNetworkReply::NetworkError)), reply, SIGNAL(error(QNetworkReply::NetworkError)), Qt::QueuedConnection);
+    connect(this, SIGNAL(timeout()), this, SLOT(onTimeOut()), Qt::QueuedConnection);
+    start(timeOut);
+}
+
+void O2Reply::onTimeOut() {
+    Q_EMIT error(QNetworkReply::TimeoutError);
+}
+
+O2ReplyList::~O2ReplyList() {
+    foreach (O2Reply *timedReply, replies_) {
+        delete timedReply;
+    }
+}
+
+void O2ReplyList::add(QNetworkReply *reply) {
+    if (reply && ignoreSslErrors())
+            reply->ignoreSslErrors();
+    add(new O2Reply(reply));
+}
+
+void O2ReplyList::add(O2Reply *reply) {
+    replies_.append(reply);
+}
+
+void O2ReplyList::remove(QNetworkReply *reply) {
+    O2Reply *o2Reply = find(reply);
+    if (o2Reply) {
+        o2Reply->stop();
+        (void)replies_.removeOne(o2Reply);
+    }
+}
+
+O2Reply *O2ReplyList::find(QNetworkReply *reply) {
+    foreach (O2Reply *timedReply, replies_) {
+        if (timedReply->reply == reply) {
+            return timedReply;
+        }
+    }
+    return 0;
+}
+
+bool O2ReplyList::ignoreSslErrors()
+{
+    return ignoreSslErrors_;
+}
+
+void O2ReplyList::setIgnoreSslErrors(bool ignoreSslErrors)
+{
+    ignoreSslErrors_ = ignoreSslErrors;
+}
diff --git a/common/libkipiplugins/o2/src/o2reply.h b/common/libkipiplugins/o2/src/o2reply.h
new file mode 100644
index 0000000..15f1571
--- /dev/null
+++ b/common/libkipiplugins/o2/src/o2reply.h
@@ -0,0 +1,59 @@
+#ifndef O2TIMEDREPLYLIST_H
+#define O2TIMEDREPLYLIST_H
+
+#include <QList>
+#include <QTimer>
+#include <QNetworkRequest>
+#include <QNetworkReply>
+#include <QNetworkAccessManager>
+#include <QByteArray>
+
+/// A network request/reply pair that can time out.
+class O2Reply: public QTimer {
+    Q_OBJECT
+
+public:
+    O2Reply(QNetworkReply *reply, int timeOut = 60 * 1000, QObject *parent = 0);
+
+Q_SIGNALS:
+    void error(QNetworkReply::NetworkError);
+
+public Q_SLOTS:
+    /// When time out occurs, the QNetworkReply's error() signal is triggered.
+    void onTimeOut();
+
+public:
+    QNetworkReply *reply;
+};
+
+/// List of O2Replies.
+class O2ReplyList {
+public:
+    O2ReplyList() { ignoreSslErrors_ = false; }
+
+    /// Destructor.
+    /// Deletes all O2Reply instances in the list.
+    virtual ~O2ReplyList();
+
+    /// Create a new O2Reply from a QNetworkReply, and add it to this list.
+    void add(QNetworkReply *reply);
+
+    /// Add an O2Reply to the list, while taking ownership of it.
+    void add(O2Reply *reply);
+
+    /// Remove item from the list that corresponds to a QNetworkReply.
+    void remove(QNetworkReply *reply);
+
+    /// Find an O2Reply in the list, corresponding to a QNetworkReply.
+    /// @return Matching O2Reply or NULL.
+    O2Reply *find(QNetworkReply *reply);
+
+    bool ignoreSslErrors();
+    void setIgnoreSslErrors(bool ignoreSslErrors);
+
+protected:
+    QList<O2Reply *> replies_;
+    bool ignoreSslErrors_;
+};
+
+#endif // O2TIMEDREPLYLIST_H
diff --git a/common/libkipiplugins/o2/src/o2replyserver.cpp b/common/libkipiplugins/o2/src/o2replyserver.cpp
new file mode 100644
index 0000000..00dad96
--- /dev/null
+++ b/common/libkipiplugins/o2/src/o2replyserver.cpp
@@ -0,0 +1,81 @@
+#include <QTcpServer>
+#include <QTcpSocket>
+#include <QByteArray>
+#include <QString>
+#include <QMap>
+#include <QPair>
+#include <QStringList>
+#include <QUrl>
+#include <QDebug>
+#if QT_VERSION >= 0x050000
+#include <QUrlQuery>
+#endif
+
+#include "o2replyserver.h"
+
+O2ReplyServer::O2ReplyServer(QObject *parent): QTcpServer(parent) {
+    connect(this, SIGNAL(newConnection()), this, SLOT(onIncomingConnection()));
+    replyContent_ = "<HTML></HTML>";
+}
+
+void O2ReplyServer::onIncomingConnection() {
+    QTcpSocket *socket = nextPendingConnection();
+    connect(socket, SIGNAL(readyRead()), this, SLOT(onBytesReady()), Qt::UniqueConnection);
+    connect(socket, SIGNAL(disconnected()), socket, SLOT(deleteLater()));
+}
+
+void O2ReplyServer::onBytesReady() {
+    qDebug() << "O2ReplyServer::onBytesReady";
+    QTcpSocket *socket = qobject_cast<QTcpSocket *>(sender());
+    if (!socket) {
+        return;
+    }
+    QByteArray reply;
+    reply.append("HTTP/1.0 200 OK \r\n");
+    reply.append("Content-Type: text/html; charset=\"utf-8\"\r\n");
+    reply.append(QString("Content-Length: %1\r\n\r\n").arg(replyContent_.size()));
+    reply.append(replyContent_);
+    socket->write(reply);
+
+    QByteArray data = socket->readAll();
+    QMap<QString, QString> queryParams = parseQueryParams(&data);
+    socket->disconnectFromHost();
+    close();
+    Q_EMIT verificationReceived(queryParams);
+}
+
+QMap<QString, QString> O2ReplyServer::parseQueryParams(QByteArray *data) {
+    qDebug() << "O2ReplyServer::parseQueryParams";
+
+    QString splitGetLine = QString(*data).split("\r\n").first();
+    splitGetLine.remove("GET ");
+    splitGetLine.remove("HTTP/1.1");
+    splitGetLine.remove("\r\n");
+    splitGetLine.prepend("http://localhost");
+    QUrl getTokenUrl(splitGetLine);
+
+    QList< QPair<QString, QString> > tokens;
+#if QT_VERSION < 0x050000
+    tokens = getTokenUrl.queryItems();
+#else
+    QUrlQuery query(getTokenUrl);
+    tokens = query.queryItems();
+#endif
+    QMultiMap<QString, QString> queryParams;
+    QPair<QString, QString> tokenPair;
+    foreach (tokenPair, tokens) {
+        // FIXME: We are decoding key and value again. This helps with Google OAuth, but is it mandated by the standard?
+        QString key = QUrl::fromPercentEncoding(QByteArray().append(tokenPair.first.trimmed()));
+        QString value = QUrl::fromPercentEncoding(QByteArray().append(tokenPair.second.trimmed()));
+        queryParams.insert(key, value);
+    }
+    return queryParams;
+}
+
+QByteArray O2ReplyServer::replyContent() {
+    return replyContent_;
+}
+
+void O2ReplyServer::setReplyContent(const QByteArray &value) {
+    replyContent_ = value;
+}
diff --git a/common/libkipiplugins/o2/src/o2replyserver.h b/common/libkipiplugins/o2/src/o2replyserver.h
new file mode 100644
index 0000000..5a9d2f2
--- /dev/null
+++ b/common/libkipiplugins/o2/src/o2replyserver.h
@@ -0,0 +1,33 @@
+#ifndef O2REPLYSERVER_H
+#define O2REPLYSERVER_H
+
+#include <QTcpServer>
+#include <QMap>
+#include <QByteArray>
+#include <QString>
+
+/// HTTP server to process authentication response.
+class O2ReplyServer: public QTcpServer {
+    Q_OBJECT
+
+public:
+    explicit O2ReplyServer(QObject *parent = 0);
+
+    /// Page content on local host after successful oauth - in case you do not want to close the browser, but display something
+    Q_PROPERTY(QByteArray replyContent READ replyContent WRITE setReplyContent)
+    QByteArray replyContent();
+    void setReplyContent(const QByteArray &value);
+
+Q_SIGNALS:
+    void verificationReceived(QMap<QString, QString>);
+
+public Q_SLOTS:
+    void onIncomingConnection();
+    void onBytesReady();
+    QMap<QString, QString> parseQueryParams(QByteArray *data);
+
+protected:
+    QByteArray replyContent_;
+};
+
+#endif // O2REPLYSERVER_H
diff --git a/common/libkipiplugins/o2/src/o2requestor.cpp b/common/libkipiplugins/o2/src/o2requestor.cpp
new file mode 100644
index 0000000..d737d35
--- /dev/null
+++ b/common/libkipiplugins/o2/src/o2requestor.cpp
@@ -0,0 +1,193 @@
+#include <QDebug>
+#include <QTimer>
+#if QT_VERSION >= 0x050000
+#include <QUrlQuery>
+#endif
+
+#include "o2requestor.h"
+#include "o2.h"
+#include "o0globals.h"
+
+O2Requestor::O2Requestor(QNetworkAccessManager *manager, O2 *authenticator, QObject *parent): QObject(parent), reply_(NULL), status_(Idle) {
+    manager_ = manager;
+    authenticator_ = authenticator;
+    if (authenticator) {
+        timedReplies_.setIgnoreSslErrors(authenticator->ignoreSslErrors());
+    }
+    qRegisterMetaType<QNetworkReply::NetworkError>("QNetworkReply::NetworkError");
+    connect(authenticator, SIGNAL(refreshFinished(QNetworkReply::NetworkError)), this, SLOT(onRefreshFinished(QNetworkReply::NetworkError)), Qt::QueuedConnection);
+}
+
+O2Requestor::~O2Requestor() {
+}
+
+int O2Requestor::get(const QNetworkRequest &req) {
+    if (-1 == setup(req, QNetworkAccessManager::GetOperation)) {
+        return -1;
+    }
+    reply_ = manager_->get(request_);
+    timedReplies_.add(reply_);
+    connect(reply_, SIGNAL(error(QNetworkReply::NetworkError)), this, SLOT(onRequestError(QNetworkReply::NetworkError)), Qt::QueuedConnection);
+    connect(reply_, SIGNAL(finished()), this, SLOT(onRequestFinished()), Qt::QueuedConnection);
+    return id_;
+}
+
+int O2Requestor::post(const QNetworkRequest &req, const QByteArray &data) {
+    if (-1 == setup(req, QNetworkAccessManager::PostOperation)) {
+        return -1;
+    }
+    data_ = data;
+    reply_ = manager_->post(request_, data_);
+    timedReplies_.add(reply_);
+    connect(reply_, SIGNAL(error(QNetworkReply::NetworkError)), this, SLOT(onRequestError(QNetworkReply::NetworkError)), Qt::QueuedConnection);
+    connect(reply_, SIGNAL(finished()), this, SLOT(onRequestFinished()), Qt::QueuedConnection);
+    connect(reply_, SIGNAL(uploadProgress(qint64,qint64)), this, SLOT(onUploadProgress(qint64,qint64)));
+    return id_;
+}
+
+int O2Requestor::put(const QNetworkRequest &req, const QByteArray &data) {
+    if (-1 == setup(req, QNetworkAccessManager::PutOperation)) {
+        return -1;
+    }
+    data_ = data;
+    reply_ = manager_->put(request_, data_);
+    timedReplies_.add(reply_);
+    connect(reply_, SIGNAL(error(QNetworkReply::NetworkError)), this, SLOT(onRequestError(QNetworkReply::NetworkError)), Qt::QueuedConnection);
+    connect(reply_, SIGNAL(finished()), this, SLOT(onRequestFinished()), Qt::QueuedConnection);
+    connect(reply_, SIGNAL(uploadProgress(qint64,qint64)), this, SLOT(onUploadProgress(qint64,qint64)));
+    return id_;
+}
+
+void O2Requestor::onRefreshFinished(QNetworkReply::NetworkError error) {
+    if (status_ != Requesting) {
+        qWarning() << "O2Requestor::onRefreshFinished: No pending request";
+        return;
+    }
+    if (QNetworkReply::NoError == error) {
+        QTimer::singleShot(100, this, SLOT(retry()));
+    } else {
+        error_ = error;
+        QTimer::singleShot(10, this, SLOT(finish()));
+    }
+}
+
+void O2Requestor::onRequestFinished() {
+    QNetworkReply *senderReply = qobject_cast<QNetworkReply *>(sender());
+    QNetworkReply::NetworkError error = senderReply->error();
+    if (status_ == Idle) {
+        return;
+    }
+    if (reply_ != senderReply) {
+        return;
+    }
+    if (error == QNetworkReply::NoError) {
+        QTimer::singleShot(10, this, SLOT(finish()));
+    }
+}
+
+void O2Requestor::onRequestError(QNetworkReply::NetworkError error) {
+    qWarning() << "O2Requestor::onRequestError: Error" << (int)error;
+    if (status_ == Idle) {
+        return;
+    }
+    if (reply_ != qobject_cast<QNetworkReply *>(sender())) {
+        return;
+    }
+    int httpStatus = reply_->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt();
+    qWarning() << "O2Requestor::onRequestError: HTTP status" << httpStatus << reply_->attribute(QNetworkRequest::HttpReasonPhraseAttribute).toString();
+    qDebug() << reply_->readAll();
+    if ((status_ == Requesting) && (httpStatus == 401)) {
+        // Call O2::refresh. Note the O2 instance might live in a different thread
+        if (QMetaObject::invokeMethod(authenticator_, "refresh")) {
+            return;
+        }
+        qCritical() << "O2Requestor::onRequestError: Invoking remote refresh failed";
+    }
+    error_ = error;
+    QTimer::singleShot(10, this, SLOT(finish()));
+}
+
+void O2Requestor::onUploadProgress(qint64 uploaded, qint64 total) {
+    if (status_ == Idle) {
+        qWarning() << "O2Requestor::onUploadProgress: No pending request";
+        return;
+    }
+    if (reply_ != qobject_cast<QNetworkReply *>(sender())) {
+        return;
+    }
+    Q_EMIT uploadProgress(id_, uploaded, total);
+}
+
+int O2Requestor::setup(const QNetworkRequest &req, QNetworkAccessManager::Operation operation) {
+    static int currentId;
+    QUrl url;
+
+    if (status_ != Idle) {
+        qWarning() << "O2Requestor::setup: Another request pending";
+        return -1;
+    }
+
+    request_ = req;
+    operation_ = operation;
+    id_ = currentId++;
+    url_ = url = req.url();
+#if QT_VERSION < 0x050000
+    url.addQueryItem(O2_OAUTH2_ACCESS_TOKEN, authenticator_->token());
+#else
+    QUrlQuery query(url);
+    query.addQueryItem(O2_OAUTH2_ACCESS_TOKEN, authenticator_->token());
+    url.setQuery(query);
+#endif
+    request_.setUrl(url);
+    status_ = Requesting;
+    error_ = QNetworkReply::NoError;
+    return id_;
+}
+
+void O2Requestor::finish() {
+    QByteArray data;
+    if (status_ == Idle) {
+        qWarning() << "O2Requestor::finish: No pending request";
+        return;
+    }
+    data = reply_->readAll();
+    status_ = Idle;
+    timedReplies_.remove(reply_);
+    reply_->disconnect(this);
+    reply_->deleteLater();
+    Q_EMIT finished(id_, error_, data);
+}
+
+void O2Requestor::retry() {
+    if (status_ != Requesting) {
+        qWarning() << "O2Requestor::retry: No pending request";
+        return;
+    }
+    timedReplies_.remove(reply_);
+    reply_->disconnect(this);
+    reply_->deleteLater();
+    QUrl url = url_;
+#if QT_VERSION < 0x050000
+    url.addQueryItem(O2_OAUTH2_ACCESS_TOKEN, authenticator_->token());
+#else
+    QUrlQuery query(url);
+    query.addQueryItem(O2_OAUTH2_ACCESS_TOKEN, authenticator_->token());
+    url.setQuery(query);
+#endif
+    request_.setUrl(url);
+    status_ = ReRequesting;
+    switch (operation_) {
+    case QNetworkAccessManager::GetOperation:
+        reply_ = manager_->get(request_);
+        break;
+    case QNetworkAccessManager::PostOperation:
+        reply_ = manager_->post(request_, data_);
+        break;
+    default:
+        reply_ = manager_->put(request_, data_);
+    }
+    timedReplies_.add(reply_);
+    connect(reply_, SIGNAL(error(QNetworkReply::NetworkError)), this, SLOT(onRequestError(QNetworkReply::NetworkError)), Qt::QueuedConnection);
+    connect(reply_, SIGNAL(finished()), this, SLOT(onRequestFinished()), Qt::QueuedConnection);
+    connect(reply_, SIGNAL(uploadProgress(qint64,qint64)), this, SLOT(onUploadProgress(qint64,qint64)));
+}
diff --git a/common/libkipiplugins/o2/src/o2requestor.h b/common/libkipiplugins/o2/src/o2requestor.h
new file mode 100644
index 0000000..939e598
--- /dev/null
+++ b/common/libkipiplugins/o2/src/o2requestor.h
@@ -0,0 +1,82 @@
+#ifndef O2REQUESTOR_H
+#define O2REQUESTOR_H
+
+#include <QObject>
+#include <QNetworkRequest>
+#include <QNetworkReply>
+#include <QNetworkAccessManager>
+#include <QUrl>
+#include <QByteArray>
+
+#include "o2reply.h"
+
+class O2;
+
+/// Makes authenticated requests.
+class O2Requestor: public QObject {
+    Q_OBJECT
+
+public:
+    explicit O2Requestor(QNetworkAccessManager *manager, O2 *authenticator, QObject *parent = 0);
+    ~O2Requestor();
+
+public Q_SLOTS:
+    /// Make a GET request.
+    /// @return Request ID or -1 if there are too many requests in the queue.
+    int get(const QNetworkRequest &req);
+
+    /// Make a POST request.
+    /// @return Request ID or -1 if there are too many requests in the queue.
+    int post(const QNetworkRequest &req, const QByteArray &data);
+
+    /// Make a PUT request.
+    /// @return Request ID or -1 if there are too many requests in the queue.
+    int put(const QNetworkRequest &req, const QByteArray &data);
+
+Q_SIGNALS:
+    /// Emitted when a request has been completed or failed.
+    void finished(int id, QNetworkReply::NetworkError error, QByteArray data);
+
+    /// Emitted when an upload has progressed.
+    void uploadProgress(int id, qint64 bytesSent, qint64 bytesTotal);
+
+protected Q_SLOTS:
+    /// Handle refresh completion.
+    void onRefreshFinished(QNetworkReply::NetworkError error);
+
+    /// Handle request finished.
+    void onRequestFinished();
+
+    /// Handle request error.
+    void onRequestError(QNetworkReply::NetworkError error);
+
+    /// Re-try request (after successful token refresh).
+    void retry();
+
+    /// Finish the request, Q_EMIT finished() signal.
+    void finish();
+
+    /// Handle upload progress.
+    void onUploadProgress(qint64 uploaded, qint64 total);
+
+protected:
+    int setup(const QNetworkRequest &request, QNetworkAccessManager::Operation operation);
+
+    enum Status {
+        Idle, Requesting, ReRequesting
+    };
+
+    QNetworkAccessManager *manager_;
+    O2 *authenticator_;
+    QNetworkRequest request_;
+    QByteArray data_;
+    QNetworkReply *reply_;
+    Status status_;
+    int id_;
+    QNetworkAccessManager::Operation operation_;
+    QUrl url_;
+    O2ReplyList timedReplies_;
+    QNetworkReply::NetworkError error_;
+};
+
+#endif // O2REQUESTOR_H
diff --git a/common/libkipiplugins/o2/src/o2simplecrypt.cpp b/common/libkipiplugins/o2/src/o2simplecrypt.cpp
new file mode 100644
index 0000000..210ae12
--- /dev/null
+++ b/common/libkipiplugins/o2/src/o2simplecrypt.cpp
@@ -0,0 +1,254 @@
+/*
+Copyright (c) 2011, Andre Somers
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of the Rathenau Instituut, Andre Somers nor the
+      names of its contributors may be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL ANDRE SOMERS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#include "o0simplecrypt.h"
+#include <QByteArray>
+#include <QtDebug>
+#include <QtGlobal>
+#include <QDateTime>
+#include <QCryptographicHash>
+#include <QDataStream>
+
+O0SimpleCrypt::O0SimpleCrypt():
+    m_key(0),
+    m_compressionMode(CompressionAuto),
+    m_protectionMode(ProtectionChecksum),
+    m_lastError(ErrorNoError)
+{
+    qsrand(uint(QDateTime::currentMSecsSinceEpoch() & 0xFFFF));
+}
+
+O0SimpleCrypt::O0SimpleCrypt(quint64 key):
+    m_key(key),
+    m_compressionMode(CompressionAuto),
+    m_protectionMode(ProtectionChecksum),
+    m_lastError(ErrorNoError)
+{
+    qsrand(uint(QDateTime::currentMSecsSinceEpoch() & 0xFFFF));
+    splitKey();
+}
+
+void O0SimpleCrypt::setKey(quint64 key)
+{
+    m_key = key;
+    splitKey();
+}
+
+void O0SimpleCrypt::splitKey()
+{
+    m_keyParts.clear();
+    m_keyParts.resize(8);
+    for (int i=0;i<8;i++) {
+        quint64 part = m_key;
+        for (int j=i; j>0; j--)
+            part = part >> 8;
+        part = part & 0xff;
+        m_keyParts[i] = static_cast<char>(part);
+    }
+}
+
+QByteArray O0SimpleCrypt::encryptToByteArray(const QString& plaintext)
+{
+    QByteArray plaintextArray = plaintext.toUtf8();
+    return encryptToByteArray(plaintextArray);
+}
+
+QByteArray O0SimpleCrypt::encryptToByteArray(QByteArray plaintext)
+{
+    if (m_keyParts.isEmpty()) {
+        qWarning() << "No key set.";
+        m_lastError = ErrorNoKeySet;
+        return QByteArray();
+    }
+
+
+    QByteArray ba = plaintext;
+
+    CryptoFlags flags = CryptoFlagNone;
+    if (m_compressionMode == CompressionAlways) {
+        ba = qCompress(ba, 9); //maximum compression
+        flags |= CryptoFlagCompression;
+    } else if (m_compressionMode == CompressionAuto) {
+        QByteArray compressed = qCompress(ba, 9);
+        if (compressed.count() < ba.count()) {
+            ba = compressed;
+            flags |= CryptoFlagCompression;
+        }
+    }
+
+    QByteArray integrityProtection;
+    if (m_protectionMode == ProtectionChecksum) {
+        flags |= CryptoFlagChecksum;
+        QDataStream s(&integrityProtection, QIODevice::WriteOnly);
+        s << qChecksum(ba.constData(), ba.length());
+    } else if (m_protectionMode == ProtectionHash) {
+        flags |= CryptoFlagHash;
+        QCryptographicHash hash(QCryptographicHash::Sha1);
+        hash.addData(ba);
+
+        integrityProtection += hash.result();
+    }
+
+    //prepend a random char to the string
+    char randomChar = char(qrand() & 0xFF);
+    ba = randomChar + integrityProtection + ba;
+
+    int pos(0);
+    char lastChar(0);
+
+    int cnt = ba.count();
+
+    while (pos < cnt) {
+        ba[pos] = ba.at(pos) ^ m_keyParts.at(pos % 8) ^ lastChar;
+        lastChar = ba.at(pos);
+        ++pos;
+    }
+
+    QByteArray resultArray;
+    resultArray.append(char(0x03));  //version for future updates to algorithm
+    resultArray.append(char(flags)); //encryption flags
+    resultArray.append(ba);
+
+    m_lastError = ErrorNoError;
+    return resultArray;
+}
+
+QString O0SimpleCrypt::encryptToString(const QString& plaintext)
+{
+    QByteArray plaintextArray = plaintext.toUtf8();
+    QByteArray cypher = encryptToByteArray(plaintextArray);
+    QString cypherString = QString::fromLatin1(cypher.toBase64());
+    return cypherString;
+}
+
+QString O0SimpleCrypt::encryptToString(QByteArray plaintext)
+{
+    QByteArray cypher = encryptToByteArray(plaintext);
+    QString cypherString = QString::fromLatin1(cypher.toBase64());
+    return cypherString;
+}
+
+QString O0SimpleCrypt::decryptToString(const QString &cyphertext)
+{
+    QByteArray cyphertextArray = QByteArray::fromBase64(cyphertext.toLatin1());
+    QByteArray plaintextArray = decryptToByteArray(cyphertextArray);
+    QString plaintext = QString::fromUtf8(plaintextArray, plaintextArray.size());
+
+    return plaintext;
+}
+
+QString O0SimpleCrypt::decryptToString(QByteArray cypher)
+{
+    QByteArray ba = decryptToByteArray(cypher);
+    QString plaintext = QString::fromUtf8(ba, ba.size());
+
+    return plaintext;
+}
+
+QByteArray O0SimpleCrypt::decryptToByteArray(const QString& cyphertext)
+{
+    QByteArray cyphertextArray = QByteArray::fromBase64(cyphertext.toLatin1());
+    QByteArray ba = decryptToByteArray(cyphertextArray);
+
+    return ba;
+}
+
+QByteArray O0SimpleCrypt::decryptToByteArray(QByteArray cypher)
+{
+    if (m_keyParts.isEmpty()) {
+        qWarning() << "No key set.";
+        m_lastError = ErrorNoKeySet;
+        return QByteArray();
+    }
+
+    if (!cypher.length()) {
+        m_lastError = ErrorUnknownVersion;
+        return QByteArray();
+    }
+
+    QByteArray ba = cypher;
+
+    char version = ba.at(0);
+
+    if (version !=3) {  //we only work with version 3
+        m_lastError = ErrorUnknownVersion;
+        qWarning() << "Invalid version or not a cyphertext.";
+        return QByteArray();
+    }
+
+    CryptoFlags flags = CryptoFlags(ba.at(1));
+
+    ba = ba.mid(2);
+    int pos(0);
+    int cnt(ba.count());
+    char lastChar = 0;
+
+    while (pos < cnt) {
+        char currentChar = ba[pos];
+        ba[pos] = ba.at(pos) ^ lastChar ^ m_keyParts.at(pos % 8);
+        lastChar = currentChar;
+        ++pos;
+    }
+
+    ba = ba.mid(1); //chop off the random number at the start
+
+    bool integrityOk(true);
+    if (flags.testFlag(CryptoFlagChecksum)) {
+        if (ba.length() < 2) {
+            m_lastError = ErrorIntegrityFailed;
+            return QByteArray();
+        }
+        quint16 storedChecksum;
+        {
+            QDataStream s(&ba, QIODevice::ReadOnly);
+            s >> storedChecksum;
+        }
+        ba = ba.mid(2);
+        quint16 checksum = qChecksum(ba.constData(), ba.length());
+        integrityOk = (checksum == storedChecksum);
+    } else if (flags.testFlag(CryptoFlagHash)) {
+        if (ba.length() < 20) {
+            m_lastError = ErrorIntegrityFailed;
+            return QByteArray();
+        }
+        QByteArray storedHash = ba.left(20);
+        ba = ba.mid(20);
+        QCryptographicHash hash(QCryptographicHash::Sha1);
+        hash.addData(ba);
+        integrityOk = (hash.result() == storedHash);
+    }
+
+    if (!integrityOk) {
+        m_lastError = ErrorIntegrityFailed;
+        return QByteArray();
+    }
+
+    if (flags.testFlag(CryptoFlagCompression))
+        ba = qUncompress(ba);
+
+    m_lastError = ErrorNoError;
+    return ba;
+}
diff --git a/common/libkipiplugins/o2/src/o2skydrive.cpp b/common/libkipiplugins/o2/src/o2skydrive.cpp
new file mode 100644
index 0000000..a18cb68
--- /dev/null
+++ b/common/libkipiplugins/o2/src/o2skydrive.cpp
@@ -0,0 +1,125 @@
+#include <QDebug>
+#include <QDateTime>
+#include <QMap>
+#include <QString>
+#include <QStringList>
+#if QT_VERSION >= 0x050000
+#include <QUrlQuery>
+#endif
+
+#include "o2skydrive.h"
+#include "o0globals.h"
+
+O2Skydrive::O2Skydrive(QObject *parent): O2(parent) {
+    setRequestUrl("https://login.live.com/oauth20_authorize.srf");
+    setTokenUrl("https://login.live.com/oauth20_token.srf");
+    setRefreshTokenUrl("https://login.live.com/oauth20_token.srf");
+}
+
+void O2Skydrive::link() {
+    qDebug() << "O2Skydrive::link";
+    if (linked()) {
+        qDebug() << "O2kydrive::link: Linked already";
+        return;
+    }
+
+    setLinked(false);
+    setToken("");
+    setTokenSecret("");
+    setExtraTokens(QVariantMap());
+    setRefreshToken(QString());
+    setExpires(0);
+
+    redirectUri_ = QString("https://login.live.com/oauth20_desktop.srf");
+
+    // Assemble intial authentication URL
+    QList<QPair<QString, QString> > parameters;
+    parameters.append(qMakePair(QString(O2_OAUTH2_RESPONSE_TYPE), (grantFlow_ == GrantFlowAuthorizationCode) ? QString(O2_OAUTH2_GRANT_TYPE_CODE) : QString(O2_OAUTH2_GRANT_TYPE_TOKEN)));
+    parameters.append(qMakePair(QString(O2_OAUTH2_CLIENT_ID), clientId_));
+    parameters.append(qMakePair(QString(O2_OAUTH2_REDIRECT_URI), redirectUri_));
+    parameters.append(qMakePair(QString(O2_OAUTH2_SCOPE), scope_));
+
+    // Show authentication URL with a web browser
+    QUrl url(requestUrl_);
+#if QT_VERSION < 0x050000
+    url.setQueryItems(parameters);
+#else
+    QUrlQuery query(url);
+    query.setQueryItems(parameters);
+    url.setQuery(query);
+#endif
+    Q_EMIT openBrowser(url);
+}
+
+void O2Skydrive::redirected(const QUrl &url) {
+    qDebug() << "O2Skydrive::redirected" << url;
+
+    Q_EMIT closeBrowser();
+
+    if (grantFlow_ == GrantFlowAuthorizationCode) {
+        // Get access code
+        QString urlCode;
+#if QT_VERSION < 0x050000
+        urlCode = url.queryItemValue(O2_OAUTH2_CODE);
+#else
+        QUrlQuery query(url);
+        urlCode = query.queryItemValue(O2_OAUTH2_GRANT_TYPE_CODE);
+#endif
+        if (urlCode.isEmpty()) {
+            qDebug() << "O2Skydrive::redirected: Code not received";
+            Q_EMIT linkingFailed();
+            return;
+        }
+        setCode(urlCode);
+
+        // Exchange access code for access/refresh tokens
+        QNetworkRequest tokenRequest(tokenUrl_);
+        tokenRequest.setHeader(QNetworkRequest::ContentTypeHeader, "application/x-www-form-urlencoded");
+        QMap<QString, QString> parameters;
+        parameters.insert(O2_OAUTH2_GRANT_TYPE_CODE, code());
+        parameters.insert(O2_OAUTH2_CLIENT_ID, clientId_);
+        parameters.insert(O2_OAUTH2_CLIENT_SECRET, clientSecret_);
+        parameters.insert(O2_OAUTH2_REDIRECT_URI, redirectUri_);
+        parameters.insert(O2_OAUTH2_GRANT_TYPE, O2_AUTHORIZATION_CODE);
+        QByteArray data = buildRequestBody(parameters);
+        QNetworkReply *tokenReply = manager_->post(tokenRequest, data);
+        timedReplies_.add(tokenReply);
+        connect(tokenReply, SIGNAL(finished()), this, SLOT(onTokenReplyFinished()), Qt::QueuedConnection);
+        connect(tokenReply, SIGNAL(error(QNetworkReply::NetworkError)), this, SLOT(onTokenReplyError(QNetworkReply::NetworkError)), Qt::QueuedConnection);
+    } else {
+        // Get access token
+        QString urlToken = "";
+        QString urlRefreshToken = "";
+        int urlExpiresIn = 0;
+
+        QStringList parts = url.toString().split("#");
+        if (parts.length() > 1) {
+            foreach (QString item, parts[1].split("&")) {
+                int index = item.indexOf("=");
+                if (index == -1) {
+                    continue;
+                }
+                QString key = item.left(index);
+                QString value = item.mid(index + 1);
+                qDebug() << "O2Skydrive::redirected: Got" << key;
+                if (key == O2_OAUTH2_ACCESS_TOKEN) {
+                    urlToken = value;
+                } else if (key == O2_OAUTH2_EXPIRES_IN) {
+                    urlExpiresIn = value.toInt();
+                } else if (key == O2_OAUTH2_REFRESH_TOKEN) {
+                    urlRefreshToken = value;
+                }
+            }
+        }
+
+        setToken(urlToken);
+        setRefreshToken(urlRefreshToken);
+        setExpires(QDateTime::currentMSecsSinceEpoch() / 1000 + urlExpiresIn);
+        if (urlToken.isEmpty()) {
+            Q_EMIT linkingFailed();
+        } else {
+            setLinked(true);
+            Q_EMIT linkingSucceeded();
+        }
+    }
+}
diff --git a/common/libkipiplugins/o2/src/o2skydrive.h b/common/libkipiplugins/o2/src/o2skydrive.h
new file mode 100644
index 0000000..2fc8110
--- /dev/null
+++ b/common/libkipiplugins/o2/src/o2skydrive.h
@@ -0,0 +1,18 @@
+#ifndef O2SKYDRIVE_H
+#define O2SKYDRIVE_H
+
+#include "o2.h"
+
+/// Skydrive's dialect of OAuth 2.0
+class O2Skydrive: public O2 {
+    Q_OBJECT
+
+public:
+    explicit O2Skydrive(QObject *parent = 0);
+
+public Q_SLOTS:
+    Q_INVOKABLE void link();
+    Q_INVOKABLE virtual void redirected(const QUrl &url);
+};
+
+#endif // O2SKYDRIVE_H
diff --git a/common/libkipiplugins/o2/src/o2surveymonkey.cpp b/common/libkipiplugins/o2/src/o2surveymonkey.cpp
new file mode 100644
index 0000000..8eb3613
--- /dev/null
+++ b/common/libkipiplugins/o2/src/o2surveymonkey.cpp
@@ -0,0 +1,21 @@
+#include <QDebug>
+#include <QMap>
+#include <QString>
+#include <QStringList>
+#if QT_VERSION >= 0x050000
+#include <QUrlQuery>
+#endif
+
+#include "o2surveymonkey.h"
+#include "o2globals.h"
+
+static const char *SMEndpoint = "https://api.surveymonkey.net/oauth/authorize";
+static const char *SMTokenUrl = "https://api.surveymonkey.net/oauth/token";
+static const quint16 SMLocalPort = 8000;
+
+O2SurveyMonkey::O2SurveyMonkey(QObject *parent): O2(parent) {
+    setRequestUrl(SMEndpoint);
+    setTokenUrl(SMTokenUrl);
+    setLocalPort(SMLocalPort);
+    setIgnoreSslErrors(true); //needed on Mac
+}
diff --git a/common/libkipiplugins/o2/src/o2surveymonkey.h b/common/libkipiplugins/o2/src/o2surveymonkey.h
new file mode 100644
index 0000000..de732c2
--- /dev/null
+++ b/common/libkipiplugins/o2/src/o2surveymonkey.h
@@ -0,0 +1,14 @@
+#ifndef O2SURVEYMONKEY_H
+#define O2SURVEYMONKEY_H
+
+#include "o2.h"
+
+/// SurveyMonkey's dialect of OAuth 2.0
+class O2SurveyMonkey: public O2 {
+    Q_OBJECT
+
+public:
+    explicit O2SurveyMonkey(QObject *parent = 0);
+};
+
+#endif // O2SURVEYMONKEY_H
diff --git a/common/libkipiplugins/o2/src/oxtwitter.cpp b/common/libkipiplugins/o2/src/oxtwitter.cpp
new file mode 100644
index 0000000..777dc5e
--- /dev/null
+++ b/common/libkipiplugins/o2/src/oxtwitter.cpp
@@ -0,0 +1,69 @@
+#include <QDateTime>
+#include <QDebug>
+
+#include "oxtwitter.h"
+#include "o0globals.h"
+
+const char XAUTH_USERNAME[] = "x_auth_username";
+const char XAUTH_PASSWORD[] = "x_auth_password";
+const char XAUTH_MODE[] = "x_auth_mode";
+const char XAUTH_MODE_VALUE[] = "client_auth";
+
+OXTwitter::OXTwitter(QObject *parent): O1Twitter(parent) {
+}
+
+QString OXTwitter::username() {
+    return username_;
+}
+
+void OXTwitter::setUsername(const QString &username) {
+    username_ = username;
+    Q_EMIT usernameChanged();
+}
+
+QString OXTwitter::password() {
+    return password_;
+}
+
+void OXTwitter::setPassword(const QString &password) {
+    password_ = password;
+    Q_EMIT passwordChanged();
+}
+
+void OXTwitter::link() {
+    qDebug() << "OXTwitter::link";
+    if (linked()) {
+        qDebug() << "Linked already";
+        return;
+    }
+
+    if (username_.isEmpty() || password_.isEmpty()) {
+        qWarning() << "Error: XAuth parameters not set. Aborting!";
+        return;
+    }
+
+    // prepare XAuth parameters
+    xAuthParams_.append(O0RequestParameter(QByteArray(XAUTH_USERNAME), username_.toLatin1()));
+    xAuthParams_.append(O0RequestParameter(QByteArray(XAUTH_PASSWORD), password_.toLatin1()));
+    xAuthParams_.append(O0RequestParameter(QByteArray(XAUTH_MODE), QByteArray(XAUTH_MODE_VALUE)));
+
+    QList<O0RequestParameter> oauthParams;
+    oauthParams.append(O0RequestParameter(O2_OAUTH_SIGNATURE_METHOD, O2_SIGNATURE_TYPE_HMAC_SHA1));
+    oauthParams.append(O0RequestParameter(O2_OAUTH_CONSUMER_KEY, clientId().toLatin1()));
+    oauthParams.append(O0RequestParameter(O2_OAUTH_VERSION, "1.0"));
+    oauthParams.append(O0RequestParameter(O2_OAUTH_TIMESTAMP, QString::number(QDateTime::currentDateTimeUtc().toTime_t()).toLatin1()));
+    oauthParams.append(O0RequestParameter(O2_OAUTH_NONCE, nonce()));
+    oauthParams.append(O0RequestParameter(O2_OAUTH_TOKEN, QByteArray("")));
+    oauthParams.append(O0RequestParameter(O2_OAUTH_VERFIER, QByteArray("")));
+
+    QByteArray signature = sign(oauthParams, xAuthParams_, accessTokenUrl(), QNetworkAccessManager::PostOperation, clientSecret(), "");
+    oauthParams.append(O0RequestParameter(O2_OAUTH_SIGNATURE, signature));
+
+    // Post request
+    QNetworkRequest request(accessTokenUrl());
+    request.setRawHeader(O2_HTTP_AUTHORIZATION_HEADER, buildAuthorizationHeader(oauthParams));
+    request.setHeader(QNetworkRequest::ContentTypeHeader, O2_MIME_TYPE_XFORM);
+    QNetworkReply *reply = manager_->post(request, createQueryParameters(xAuthParams_));
+    connect(reply, SIGNAL(error(QNetworkReply::NetworkError)), this, SLOT(onTokenExchangeError(QNetworkReply::NetworkError)));
+    connect(reply, SIGNAL(finished()), this, SLOT(onTokenExchangeFinished()));
+}
diff --git a/common/libkipiplugins/o2/src/oxtwitter.h b/common/libkipiplugins/o2/src/oxtwitter.h
new file mode 100644
index 0000000..03f0a6e
--- /dev/null
+++ b/common/libkipiplugins/o2/src/oxtwitter.h
@@ -0,0 +1,37 @@
+#ifndef OXTWITTER_H
+#define OXTWITTER_H
+
+#include "o1twitter.h"
+
+/// Twitter authenticator using Twitter XAuth
+class OXTwitter: public O1Twitter {
+    Q_OBJECT
+
+public:
+    explicit OXTwitter(QObject *parent = 0);
+
+    /// XAuth Username
+    Q_PROPERTY(QString username READ username WRITE setUsername NOTIFY usernameChanged)
+    QString username();
+    void setUsername(const QString &username);
+
+    /// XAuth Password
+    Q_PROPERTY(QString password READ password WRITE setPassword NOTIFY passwordChanged)
+    QString password();
+    void setPassword(const QString &password);
+
+public Q_SLOTS:
+    /// Authenticate.
+    Q_INVOKABLE virtual void link();
+
+Q_SIGNALS:
+    void usernameChanged();
+    void passwordChanged();
+
+private:
+    QList<O0RequestParameter> xAuthParams_;
+    QString username_;
+    QString password_;
+};
+
+#endif // OXTWITTER_H
-- 
2.8.4
From c7749c1cec81f0335a3e7c9f74e431560b8d16ef Mon Sep 17 00:00:00 2001
From: Fabian Vogt <fabian@ritter-vogt.de>
Date: Wed, 6 Jul 2016 18:32:17 +0200
Subject: [PATCH 2/3] Fix o2 to be compatible with imgur

Signed-off-by: Fabian Vogt <fabian@ritter-vogt.de>
---
 common/libkipiplugins/o2/src/o2.cpp | 8 ++++++--
 1 file changed, 6 insertions(+), 2 deletions(-)

diff --git a/common/libkipiplugins/o2/src/o2.cpp b/common/libkipiplugins/o2/src/o2.cpp
index e8108da..c7558a3 100644
--- a/common/libkipiplugins/o2/src/o2.cpp
+++ b/common/libkipiplugins/o2/src/o2.cpp
@@ -167,8 +167,12 @@ void O2::link() {
         parameters.append(qMakePair(QString(O2_OAUTH2_RESPONSE_TYPE), (grantFlow_ == GrantFlowAuthorizationCode)? QString(O2_OAUTH2_GRANT_TYPE_CODE): QString(O2_OAUTH2_GRANT_TYPE_TOKEN)));
         parameters.append(qMakePair(QString(O2_OAUTH2_CLIENT_ID), clientId_));
         parameters.append(qMakePair(QString(O2_OAUTH2_REDIRECT_URI), redirectUri_));
-        parameters.append(qMakePair(QString(O2_OAUTH2_SCOPE), scope_));
-        parameters.append(qMakePair(QString(O2_OAUTH2_API_KEY), apiKey_));
+
+        // Some services show an error if those are empty
+        if(!scope_.isEmpty())
+            parameters.append(qMakePair(QString(O2_OAUTH2_SCOPE), scope_));
+        if(!apiKey().isEmpty())
+            parameters.append(qMakePair(QString(O2_OAUTH2_API_KEY), apiKey_));
 
         // Show authentication URL with a web browser
         QUrl url(requestUrl_);
-- 
2.8.4
From febf1e52ecf26fd388f6e7439b4a4fddf678602f Mon Sep 17 00:00:00 2001
From: Fabian Vogt <fvogt@suse.com>
Date: Fri, 10 Jun 2016 13:42:46 +0200
Subject: [PATCH 3/3] Rewrite imgur plugin to work with OAuth2

Signed-off-by: Fabian Vogt <fabian@ritter-vogt.de>
---
 imgur/CMakeLists.txt       |  23 +--
 imgur/imgurapi3.cpp        | 312 +++++++++++++++++++++++++++++++++
 imgur/imgurapi3.h          | 169 ++++++++++++++++++
 imgur/imgurimageslist.cpp  | 172 ++++++++----------
 imgur/imgurimageslist.h    |  51 ++----
 imgur/imgurresponses.json  |  57 ------
 imgur/imgurtalker.cpp      | 425 ---------------------------------------------
 imgur/imgurtalker.h        | 111 ------------
 imgur/imgurtalker_common.h | 158 -----------------
 imgur/imgurtalkerauth.cpp  | 289 ------------------------------
 imgur/imgurtalkerauth.h    | 112 ------------
 imgur/imgurwidget.cpp      | 322 ----------------------------------
 imgur/imgurwidget.h        |  92 ----------
 imgur/imgurwindow.cpp      | 370 ++++++++++++++++++---------------------
 imgur/imgurwindow.h        |  58 +++----
 imgur/mpform.cpp           | 166 ------------------
 imgur/mpform.h             |  62 -------
 17 files changed, 771 insertions(+), 2178 deletions(-)
 create mode 100644 imgur/imgurapi3.cpp
 create mode 100644 imgur/imgurapi3.h
 delete mode 100644 imgur/imgurresponses.json
 delete mode 100644 imgur/imgurtalker.cpp
 delete mode 100644 imgur/imgurtalker.h
 delete mode 100644 imgur/imgurtalker_common.h
 delete mode 100644 imgur/imgurtalkerauth.cpp
 delete mode 100644 imgur/imgurtalkerauth.h
 delete mode 100644 imgur/imgurwidget.cpp
 delete mode 100644 imgur/imgurwidget.h
 delete mode 100644 imgur/mpform.cpp
 delete mode 100644 imgur/mpform.h

diff --git a/imgur/CMakeLists.txt b/imgur/CMakeLists.txt
index ac03ed1..a4e7524 100644
--- a/imgur/CMakeLists.txt
+++ b/imgur/CMakeLists.txt
@@ -10,24 +10,11 @@ add_definitions(-DTRANSLATION_DOMAIN=\"kipiplugin_imgur\")
 
 set(kipiplugin_imgur_PART_SRCS
     plugin_imgur.cpp
-    imgurtalker.cpp
-    imgurwidget.cpp
+    imgurapi3.cpp
     imgurwindow.cpp
     imgurimageslist.cpp
-    mpform.cpp
    )
 
-if(QTKOAUTH_FOUND)
-
-    # QTKOAUTH is not yet a pure Qt5 library
-    remove_definitions(-DQT_NO_CAST_FROM_ASCII -DQT_NO_CAST_TO_ASCII)
-
-    include_directories(${QTKOAUTH_INCLUDE_DIR})
-    add_definitions(-DOAUTH_ENABLED ${QTKOAUTH_DEFINITIONS})
-    set(kipiplugin_imgur_PART_SRCS ${kipiplugin_imgur_PART_SRCS} imgurtalkerauth.cpp)
-
-endif()
-
 add_library(kipiplugin_imgur MODULE ${kipiplugin_imgur_PART_SRCS})
 
 target_link_libraries(kipiplugin_imgur
@@ -40,14 +27,6 @@ target_link_libraries(kipiplugin_imgur
                       KF5kipiplugins
 )
 
-if(QTKOAUTH_FOUND)
-
-    target_link_libraries(kipiplugin_imgur
-                          Qt5::Network
-                          ${QTKOAUTH_LIBRARIES})
-
-endif()
-
 configure_file(kipiplugin_imgur.desktop.cmake ${CMAKE_CURRENT_BINARY_DIR}/kipiplugin_imgur.desktop)
 
 install(FILES   ${CMAKE_CURRENT_BINARY_DIR}/kipiplugin_imgur.desktop DESTINATION ${SERVICES_INSTALL_DIR})
diff --git a/imgur/imgurapi3.cpp b/imgur/imgurapi3.cpp
new file mode 100644
index 0000000..33f508e
--- /dev/null
+++ b/imgur/imgurapi3.cpp
@@ -0,0 +1,312 @@
+#include <klocalizedstring.h>
+
+#include <QDebug>
+#include <QFileInfo>
+#include <QHttpMultiPart>
+#include <QJsonDocument>
+#include <QJsonObject>
+#include <QTimerEvent>
+#include <QUrlQuery>
+
+#include "imgurapi3.h"
+
+static const QString imgur_auth_url = QLatin1String("https://api.imgur.com/oauth2/authorize"),
+imgur_token_url = QLatin1String("https://api.imgur.com/oauth2/token");
+static const uint16_t imgur_redirect_port = 8000; // Redirect URI is http://127.0.0.1:8000
+
+ImgurAPI3::ImgurAPI3(const QString &client_id, const QString &client_secret, QObject *parent)
+    : QObject(parent)
+{
+    m_auth.setClientId(client_id);
+    m_auth.setClientSecret(client_secret);
+    m_auth.setRequestUrl(imgur_auth_url);
+    m_auth.setTokenUrl(imgur_token_url);
+    m_auth.setRefreshTokenUrl(imgur_token_url);
+    m_auth.setLocalPort(imgur_redirect_port);
+
+    connect(&m_auth, &O2::linkedChanged, this, &ImgurAPI3::oauthAuthorized);
+    connect(&m_auth, &O2::openBrowser, this, &ImgurAPI3::oauthRequestPin);
+    connect(&m_auth, &O2::linkingFailed, this, &ImgurAPI3::oauthFailed);
+}
+
+ImgurAPI3::~ImgurAPI3()
+{
+    /* Disconnect all signals as cancelAllWork may emit */
+    disconnect(this, 0, 0, 0);
+    cancelAllWork();
+}
+
+O2 &ImgurAPI3::getAuth()
+{
+    return m_auth;
+}
+
+unsigned int ImgurAPI3::workQueueLength()
+{
+    return m_work_queue.size();
+}
+
+void ImgurAPI3::queueWork(const ImgurAPI3Action &action)
+{
+    m_work_queue.push(action);
+    startWorkTimer();
+}
+
+void ImgurAPI3::cancelAllWork()
+{
+    stopWorkTimer();
+    
+    if(m_reply)
+        m_reply->abort();
+    
+    /* Should error be emitted for those actions? */
+    while(!m_work_queue.empty())
+        m_work_queue.pop();
+}
+
+QUrl ImgurAPI3::urlForDeletehash(const QString &deletehash)
+{
+    return QUrl{QLatin1String("https://imgur.com/delete/") + deletehash};
+}
+
+void ImgurAPI3::oauthAuthorized()
+{
+    bool success = m_auth.linked();
+    if(success)
+        startWorkTimer();
+    else
+        emit busy(false);
+
+    emit authorized(success, m_auth.extraTokens()[QLatin1String("account_username")].toString());
+}
+
+void ImgurAPI3::oauthRequestPin(const QUrl &url)
+{
+    emit busy(false);
+    emit requestPin(url);
+}
+
+void ImgurAPI3::oauthFailed()
+{
+    emit authError(i18n("Could not authorize"));
+}
+
+void ImgurAPI3::uploadProgress(qint64 sent, qint64 total)
+{
+    if(total > 0) /* Don't divide by 0 */
+        emit progress((sent * 100) / total, m_work_queue.front());
+}
+
+void ImgurAPI3::replyFinished()
+{
+    auto *reply = m_reply;
+    reply->deleteLater();
+    m_reply = nullptr;
+    
+    if(this->m_image)
+    {
+        delete this->m_image;
+        this->m_image = nullptr;
+    }
+
+    if(m_work_queue.empty())
+    {
+        qDebug() << "Received result without request";
+        return;
+    }
+
+    /* toInt() returns 0 if conversion fails. That fits nicely already. */
+    int code = reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt();
+    auto response = QJsonDocument::fromJson(reply->readAll());
+    
+    if(code == 200 && !response.isEmpty())
+    {
+        /* Success! */
+        ImgurAPI3Result result;
+        result.action = &m_work_queue.front();
+        auto data = response.object()[QLatin1String("data")].toObject();
+        
+        switch(result.action->type)
+        {
+        case ImgurAPI3ActionType::IMG_UPLOAD:
+        case ImgurAPI3ActionType::ANON_IMG_UPLOAD:
+            result.image.animated = data[QLatin1String("animated")].toBool();
+            result.image.bandwidth = data[QLatin1String("bandwidth")].toInt();
+            result.image.datetime = data[QLatin1String("datetime")].toInt();
+            result.image.deletehash = data[QLatin1String("deletehash")].toString();
+            result.image.description = data[QLatin1String("description")].toString();
+            result.image.height = data[QLatin1String("height")].toInt();
+            result.image.hash = data[QLatin1String("id")].toString();
+            result.image.name = data[QLatin1String("name")].toString();
+            result.image.size = data[QLatin1String("size")].toInt();
+            result.image.title = data[QLatin1String("title")].toString();
+            result.image.type = data[QLatin1String("type")].toString();
+            result.image.url = data[QLatin1String("link")].toString();
+            result.image.views = data[QLatin1String("views")].toInt();
+            result.image.width = data[QLatin1String("width")].toInt();
+            break;
+        case ImgurAPI3ActionType::ACCT_INFO:
+            result.account.username = data[QLatin1String("url")].toString();
+            /* TODO: Other fields */
+            break;
+        default:
+            qWarning() << "Unexpected action";
+            qDebug() << response.toJson();
+            break;
+        }
+        
+        emit success(result);
+    }
+    else
+    {
+        if(code == 403)
+        {
+            /* HTTP 403 Forbidden -> Invalid token? 
+             * That needs to be handled internally, so don't emit progress
+             * and keep the action in the queue for later retries. */
+
+            m_auth.refresh();
+            return;
+        }
+        else
+        {
+            /* Failed. */
+            auto msg = response.object()[QLatin1String("data")]
+                    .toObject()[QLatin1String("error")]
+                    .toString(QLatin1String("Could not read response."));
+
+            emit error(msg, m_work_queue.front());
+        }
+    }
+    
+    /* Next work item. */
+    m_work_queue.pop();
+    startWorkTimer();
+}
+
+void ImgurAPI3::timerEvent(QTimerEvent *event)
+{
+    if(event->timerId() != m_work_timer)
+        return QObject::timerEvent(event);
+
+    event->accept();
+
+    /* One-shot only. */
+    QObject::killTimer(event->timerId());
+    m_work_timer = 0;
+
+    doWork();
+}
+
+void ImgurAPI3::startWorkTimer()
+{
+    if(!m_work_queue.empty() && m_work_timer == 0)
+    {
+        m_work_timer = QObject::startTimer(0);
+        emit busy(true);
+    }
+    else
+        emit busy(false);
+}
+
+void ImgurAPI3::stopWorkTimer()
+{
+    if(m_work_timer != 0)
+    {
+        QObject::killTimer(m_work_timer);
+        m_work_timer = 0;
+    }
+}
+
+void ImgurAPI3::addAuthToken(QNetworkRequest *request)
+{
+    request->setRawHeader(QByteArray("Authorization"),
+                          QString::fromLatin1("Bearer %1").arg(m_auth.token()).toUtf8());
+}
+
+void ImgurAPI3::addAnonToken(QNetworkRequest *request)
+{
+    request->setRawHeader(QByteArray("Authorization"),
+                          QString::fromLatin1("Client-ID %1").arg(m_auth.clientId()).toUtf8());
+}
+
+void ImgurAPI3::doWork()
+{
+    if(m_work_queue.empty() || m_reply != nullptr)
+        return;
+    
+    auto &work = m_work_queue.front();
+    
+    if(work.type != ImgurAPI3ActionType::ANON_IMG_UPLOAD && !m_auth.linked())
+    {
+        m_auth.link();
+        return; /* Wait for the authorized() signal. */
+    }
+
+    switch(work.type)
+    {
+    case ImgurAPI3ActionType::ACCT_INFO:
+    {
+        QNetworkRequest request(QUrl(QString::fromLatin1("https://api.imgur.com/3/account/%1")
+                                     .arg(QLatin1String(work.account.username.toUtf8().toPercentEncoding()))));
+        addAuthToken(&request);
+        
+        this->m_reply = m_net.get(request);
+        break;
+    }
+    case ImgurAPI3ActionType::ANON_IMG_UPLOAD:
+    case ImgurAPI3ActionType::IMG_UPLOAD:
+    {
+        this->m_image = new QFile(work.upload.imgpath);
+        if(!m_image->open(QIODevice::ReadOnly))
+        {
+            delete this->m_image;
+            this->m_image = nullptr;
+
+            /* Failed. */
+            emit error(i18n("Could not open file"), m_work_queue.front());
+
+            m_work_queue.pop();
+            return doWork();
+        }
+
+        /* Set ownership to m_image to delete that as well. */
+        auto *multipart = new QHttpMultiPart(QHttpMultiPart::FormDataType, m_image);
+        QHttpPart title;
+        title.setHeader(QNetworkRequest::ContentDispositionHeader,
+                        QLatin1String("form-data; name=\"title\""));
+        title.setBody(work.upload.title.toUtf8().toPercentEncoding());
+        multipart->append(title);
+        
+        QHttpPart description;
+        description.setHeader(QNetworkRequest::ContentDispositionHeader,
+                              QLatin1String("form-data; name=\"description\""));
+        description.setBody(work.upload.description.toUtf8().toPercentEncoding());
+        multipart->append(description);
+        
+        QHttpPart image;
+        image.setHeader(QNetworkRequest::ContentDispositionHeader,
+                        QVariant(QString::fromLatin1("form-data; name=\"image\"; filename=\"%1\"")
+                                 .arg(QLatin1String(QFileInfo(work.upload.imgpath).fileName().toUtf8().toPercentEncoding()))));
+        image.setHeader(QNetworkRequest::ContentTypeHeader, QLatin1String("application/octet-stream"));
+        image.setBodyDevice(this->m_image);
+        multipart->append(image);
+        
+        QNetworkRequest request(QUrl(QLatin1String("https://api.imgur.com/3/image")));
+        if(work.type == ImgurAPI3ActionType::IMG_UPLOAD)
+            addAuthToken(&request);
+        else
+            addAnonToken(&request);
+
+        this->m_reply = this->m_net.post(request, multipart);
+
+        break;
+    }
+    }
+    
+    if(this->m_reply)
+    {
+        connect(m_reply, &QNetworkReply::uploadProgress, this, &ImgurAPI3::uploadProgress);
+        connect(m_reply, &QNetworkReply::finished, this, &ImgurAPI3::replyFinished);
+    }
+}
diff --git a/imgur/imgurapi3.h b/imgur/imgurapi3.h
new file mode 100644
index 0000000..4762944
--- /dev/null
+++ b/imgur/imgurapi3.h
@@ -0,0 +1,169 @@
+/* ============================================================
+ *
+ * This file is a part of kipi-plugins project
+ * http://www.digikam.org
+ *
+ * Date        : 2016-05-27
+ * Description : Implementation of v3 of the Imgur API
+ *
+ * Copyright (C) 2016 by Fabian Vogt <fabian at ritter dash vogt dot de>
+ *
+ * This program is free software; you can redistribute it
+ * and/or modify it under the terms of the GNU General
+ * Public License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * ============================================================ */
+
+#ifndef IMGURAPI3_H
+#define IMGURAPI3_H
+
+#include <atomic>
+#include <queue>
+
+#include <QFile>
+#include <QNetworkAccessManager>
+#include <QString>
+#include <QUrl>
+
+#include "o2.h"
+
+enum class ImgurAPI3ActionType
+{
+    ACCT_INFO, /* Action: account Result: account */
+    IMG_UPLOAD, /* Action: upload Result: image */
+    ANON_IMG_UPLOAD, /* Action: upload Result: image */
+};
+
+struct ImgurAPI3Action
+{
+    ImgurAPI3ActionType type;
+    struct
+    {
+        QString imgpath;
+        QString title;
+        QString description;
+    } upload;
+
+    struct
+    {
+        QString username;
+    } account;
+};
+
+struct ImgurAPI3Result
+{
+    const ImgurAPI3Action *action;
+    
+    struct ImgurImage
+    {
+        QString    name;
+        QString    title;
+        QString    hash;
+        QString    deletehash;
+        QString    url;
+        QString    description;
+        qulonglong datetime;
+        QString    type;
+        bool       animated;
+        uint       width;
+        uint       height;
+        uint       size;
+        uint       views;
+        qulonglong bandwidth;
+    } image;
+    
+    struct ImgurAccount
+    {
+        QString username;
+    } account;
+};
+
+/* Main class, handles the client side of the Imgur API v3. */
+class ImgurAPI3 : public QObject
+{
+Q_OBJECT
+
+public:
+    ImgurAPI3(const QString &client_id, const QString &client_secret, QObject *parent=nullptr);
+    ~ImgurAPI3();
+
+    /* Use this to read/write the access and refresh tokens. */
+    O2 &getAuth();
+
+    unsigned int workQueueLength();
+    void queueWork(const ImgurAPI3Action &action);
+    void cancelAllWork();
+    
+    static QUrl urlForDeletehash(const QString &deletehash);
+
+Q_SIGNALS:
+    /* Called if authentication state changes. */
+    void authorized(bool success, const QString &username);
+    void authError(const QString &msg);
+    
+    /* Open url in a browser and let the user copy the pin.
+     * Call setPin(pin) to authorize. */
+    void requestPin(const QUrl &url);
+    
+    /* Emitted on progress changes. */
+    void progress(unsigned int percent, const ImgurAPI3Action &action);
+    void success(const ImgurAPI3Result &result);
+    void error(const QString &msg, const ImgurAPI3Action &action);
+
+    /* Emitted when the status changes. */
+    void busy(bool b);
+    
+public Q_SLOTS:
+    /* Connected to m_auth.linkedChanged(). */
+    void oauthAuthorized();
+    /* Connected to m_auth.openBrowser(QUrl). */
+    void oauthRequestPin(const QUrl &url);
+    /* Connected to m_auth.linkingFailed(). */
+    void oauthFailed();
+
+    /* Connected to the current QNetworkReply. */
+    void uploadProgress(qint64 sent, qint64 total);
+    void replyFinished();
+
+protected:
+    void timerEvent(QTimerEvent *event) override;
+
+private:
+    /* Starts m_work_timer if m_work_queue not empty. */
+    void startWorkTimer();
+    /* Stops m_work_timer if running. */
+    void stopWorkTimer();
+    /* Adds the user authorization info to the request. */
+    void addAuthToken(QNetworkRequest *request);
+    /* Adds the client authorization info to the request. */
+    void addAnonToken(QNetworkRequest *request);
+    
+    /* Start working on the first item of m_work_queue
+     * by sending a request. */
+    void doWork();
+    
+    /* Handler for OAuth 2 related requests. */
+    O2 m_auth;
+    
+    /* Work queue. */
+    std::queue<ImgurAPI3Action> m_work_queue;
+    /* ID of timer triggering on idle (0ms). */
+    int m_work_timer = 0;
+    
+    /* Current QNetworkReply */
+    QNetworkReply *m_reply = nullptr;
+    
+    /* Current image being uploaded */
+    QFile *m_image = nullptr;
+    
+    /* The QNetworkAccessManager used for connections */
+    QNetworkAccessManager m_net;
+};
+
+#endif // IMGURAPI3_H
diff --git a/imgur/imgurimageslist.cpp b/imgur/imgurimageslist.cpp
index 5869b47..b3a08a4 100644
--- a/imgur/imgurimageslist.cpp
+++ b/imgur/imgurimageslist.cpp
@@ -22,6 +22,8 @@
 
 #include "imgurimageslist.h"
 
+#include <memory>
+
 // Qt includes
 
 #include <QLabel>
@@ -32,6 +34,10 @@
 
 #include <klocalizedstring.h>
 
+// Libkipi includes
+
+#include <KIPI/Interface>
+
 // Local includes
 
 #include "kipiplugins_debug.h"
@@ -46,33 +52,38 @@ ImgurImagesList::ImgurImagesList(QWidget* const parent)
     setAllowDuplicate(false);
     setAllowRAW(false);
 
-    listView()->setColumnLabel(KPImagesListView::Thumbnail, i18n("Thumbnail"));
+    auto *list = listView();
 
-    //listView()->setColumnLabel(KPImagesListView::Filename, i18n("File name"));
+    list->setColumnLabel(KPImagesListView::Thumbnail, i18n("Thumbnail"));
 
-    listView()->setColumnLabel(static_cast<KIPIPlugins::KPImagesListView::ColumnType>(ImgurImagesList::Title),
-                               i18n("Submission title"));
+    list->setColumnLabel(static_cast<KIPIPlugins::KPImagesListView::ColumnType>(ImgurImagesList::Title),
+                         i18n("Submission title"));
 
-    listView()->setColumnLabel(static_cast<KIPIPlugins::KPImagesListView::ColumnType>(ImgurImagesList::Description),
-                               i18n("Submission description"));
+    list->setColumnLabel(static_cast<KIPIPlugins::KPImagesListView::ColumnType>(ImgurImagesList::Description),
+                         i18n("Submission description"));
 
-    listView()->setColumn(static_cast<KIPIPlugins::KPImagesListView::ColumnType>(ImgurImagesList::URL),
-                          i18n("Imgur URL"), true);
+    list->setColumn(static_cast<KIPIPlugins::KPImagesListView::ColumnType>(ImgurImagesList::URL),
+                    i18n("Imgur URL"), true);
 
-    listView()->setColumn(static_cast<KIPIPlugins::KPImagesListView::ColumnType>(ImgurImagesList::DeleteURL),
-                          i18n("Imgur Delete URL"), true);
+    list->setColumn(static_cast<KIPIPlugins::KPImagesListView::ColumnType>(ImgurImagesList::DeleteURL),
+                    i18n("Imgur Delete URL"), true);
 
-    connect(listView(), SIGNAL(itemDoubleClicked(QTreeWidgetItem*,int)),
-            this, SLOT(slotDoubleClick(QTreeWidgetItem*,int)));
+    connect(list, &KPImagesListView::itemDoubleClicked,
+            this, &ImgurImagesList::slotDoubleClick);
 }
 
-ImgurImagesList::~ImgurImagesList()
+QList<const ImgurImageListViewItem *> ImgurImagesList::getPendingItems()
 {
-}
+    QList<const ImgurImageListViewItem *> ret;
 
-void ImgurImagesList::updateItemWidgets()
-{
-    qCDebug(KIPIPLUGINS_LOG) << "update";
+    for(unsigned int i = listView()->topLevelItemCount(); i--;)
+    {
+        const auto *item = dynamic_cast<const ImgurImageListViewItem*>(listView()->topLevelItem(i));
+        if(item && item->ImgurUrl().isEmpty())
+            ret << item;
+    }
+    
+    return ret;
 }
 
 void ImgurImagesList::slotAddImages(const QList<QUrl>& list)
@@ -80,92 +91,69 @@ void ImgurImagesList::slotAddImages(const QList<QUrl>& list)
     /* Replaces the KPImagesList::slotAddImages method, so that
      * ImgurImageListViewItems can be added instead of ImagesListViewItems */
 
-    // Figure out which of the supplied URL's should actually be added and which
-    // of them already exist.
-    bool found;
+    std::unique_ptr<MetadataProcessor> meta;
+    if(iface())
+        meta = std::unique_ptr<MetadataProcessor>(iface()->createMetadataProcessor());
 
     for (QList<QUrl>::ConstIterator it = list.constBegin(); it != list.constEnd(); ++it)
     {
-        QUrl imageUrl = *it;
-        found         = false;
-
-        if (iface())
+        // Already in the list?
+        if (listView()->findItem(*it) == nullptr)
         {
-            for (int i = 0; i < listView()->topLevelItemCount(); ++i)
-            {
-                ImgurImageListViewItem* const currItem = dynamic_cast<ImgurImageListViewItem*>(listView()->topLevelItem(i));
-
-                if (currItem && currItem->url() == imageUrl)
-                {
-                    found = true;
-                    break;
-                }
-            }
-
-            QPointer<MetadataProcessor> meta = iface()->createMetadataProcessor();
+            auto *item = new ImgurImageListViewItem(listView(), *it);
 
-            if (!found && meta && meta->load(imageUrl))
+            // Load URLs from meta data, if possible
+            if(meta && meta->load(*it))
             {
-                ImgurImageListViewItem* const currItem = new ImgurImageListViewItem(listView(), imageUrl);
-
-                const QString sUrl       = meta->getXmpTagString(QLatin1String("Xmp.kipi.ImgurId"));
-                const QString sDeleteUrl = meta->getXmpTagString(QLatin1String("Xmp.kipi.ImgurDeleteHash"));
-
-                if (!sUrl.isEmpty())
-                {
-                    currItem->setUrl(QLatin1String(ImgurConnection::pageURL(sUrl).toEncoded()));
-                }
-
-                if (!sDeleteUrl.isEmpty())
-                {
-                    currItem->setDeleteUrl(QLatin1String(ImgurConnection::deleteURL(sDeleteUrl).toEncoded()));
-                }
+                item->setImgurUrl(meta->getXmpTagString(QLatin1String("Xmp.kipi.ImgurId")));
+                item->setImgurDeleteUrl(meta->getXmpTagString(QLatin1String("Xmp.kipi.ImgurDeleteHash")));
             }
         }
     }
 
-    // Duplicate the signalImageListChanged of the ImageWindow, to enable the
-    // upload button again.
     emit signalImageListChanged();
     emit signalAddItems(list);
 }
 
-void ImgurImagesList::slotUploadError(const QUrl& /*localFile*/, const ImgurError& /*error*/)
+void ImgurImagesList::slotSuccess(const ImgurAPI3Result &result)
 {
-    // TODO
-}
+    QUrl imgurl = QUrl::fromLocalFile(result.action->upload.imgpath);
 
-void ImgurImagesList::slotUploadSuccess(const QUrl& localFile, const ImgurSuccess& success)
-{
-    for (int i = 0; i < listView()->topLevelItemCount(); ++i)
+    processed(imgurl, true);
+    
+    Interface *intf = iface();
+    if(intf)
     {
-        ImgurImageListViewItem* const currItem = dynamic_cast<ImgurImageListViewItem*>(listView()->topLevelItem(i));
+        QPointer<MetadataProcessor> meta = intf->createMetadataProcessor();
 
-        if (currItem && currItem->url() == localFile)
+        // Save URLs to meta data, if possible
+        if (meta && meta->load(imgurl))
         {
-            if (!success.image.id.isEmpty())
-            {
-                const QString sUrl = QLatin1String(ImgurConnection::pageURL(success.image.id).toEncoded());
-                currItem->setUrl(sUrl);
-            }
-
-            if (!success.image.deletehash.isEmpty())
-            {
-                const QString sDeleteUrl = QLatin1String(ImgurConnection::deleteURL(success.image.deletehash).toEncoded());
-                currItem->setDeleteUrl(sDeleteUrl);
-            }
-
-            break;
+            meta->setXmpTagString(QLatin1String("Xmp.kipi.ImgurId"),         result.image.url);
+            meta->setXmpTagString(QLatin1String("Xmp.kipi.ImgurDeleteHash"), ImgurAPI3::urlForDeletehash(result.image.deletehash).toString());
+            bool saved = meta->applyChanges();
+            qCDebug(KIPIPLUGINS_LOG) << "Metadata" << (saved ? "Saved" : "Not Saved") << "to" << imgurl;
         }
     }
+
+    ImgurImageListViewItem* const currItem = dynamic_cast<ImgurImageListViewItem*>(listView()->findItem(imgurl));
+
+    if(!currItem)
+        return;
+
+    if (!result.image.url.isEmpty())
+        currItem->setImgurUrl(result.image.url);
+
+    if (!result.image.deletehash.isEmpty())
+        currItem->setImgurDeleteUrl(ImgurAPI3::urlForDeletehash(result.image.deletehash).toString());
 }
 
 void ImgurImagesList::slotDoubleClick(QTreeWidgetItem* element, int i)
 {
-    if (i == 3 || i == 4)
+    if (i == URL || i == DeleteURL)
     {
-        const QUrl url = QUrl (element->text(i));
-        // need to check for delete url click - and ask user if he wants to remove the tags also
+        const QUrl url = QUrl(element->text(i));
+        // The delete page asks for confirmation, so we don't need to do that here
         QDesktopServices::openUrl(url);
     }
 }
@@ -175,58 +163,50 @@ void ImgurImagesList::slotDoubleClick(QTreeWidgetItem* element, int i)
 ImgurImageListViewItem::ImgurImageListViewItem(KPImagesListView* const view, const QUrl& url)
     : KPImagesListViewItem(view, url)
 {
-    const QColor blue = QColor (50, 50, 255);
+    const QColor blue(50, 50, 255);
 
-    setTextColor(3, blue);
-    setTextColor(4, blue);
-}
-
-ImgurImageListViewItem::~ImgurImageListViewItem()
-{
+    setTextColor(ImgurImagesList::URL, blue);
+    setTextColor(ImgurImagesList::DeleteURL, blue);
 }
 
 void ImgurImageListViewItem::setTitle(const QString& str)
 {
     setText(ImgurImagesList::Title, str);
-    m_Title = str;
 }
 
 QString ImgurImageListViewItem::Title() const
 {
-    return m_Title;
+    return text(ImgurImagesList::Title);
 }
 
 void ImgurImageListViewItem::setDescription(const QString& str)
 {
     setText(ImgurImagesList::Description, str);
-    m_Description = str;
 }
 
 QString ImgurImageListViewItem::Description() const
 {
-    return m_Description;
+    return text(ImgurImagesList::Description);
 }
 
-void ImgurImageListViewItem::setUrl(const QString& str)
+void ImgurImageListViewItem::setImgurUrl(const QString& str)
 {
     setText(ImgurImagesList::URL, str);
-    m_Url = str;
 }
 
-QString ImgurImageListViewItem::Url() const
+QString ImgurImageListViewItem::ImgurUrl() const
 {
-    return m_Url;
+    return text(ImgurImagesList::URL);
 }
 
-void ImgurImageListViewItem::setDeleteUrl(const QString& str)
+void ImgurImageListViewItem::setImgurDeleteUrl(const QString& str)
 {
     setText(ImgurImagesList::DeleteURL, str);
-    m_deleteUrl = str;
 }
 
-QString ImgurImageListViewItem::deleteUrl() const
+QString ImgurImageListViewItem::ImgurDeleteUrl() const
 {
-    return m_deleteUrl;
+    return text(ImgurImagesList::DeleteURL);
 }
 
 } // namespace KIPIImgurPlugin
diff --git a/imgur/imgurimageslist.h b/imgur/imgurimageslist.h
index fcdd973..a6a26bd 100644
--- a/imgur/imgurimageslist.h
+++ b/imgur/imgurimageslist.h
@@ -30,7 +30,7 @@
 // Local includes
 
 #include "kpimageslist.h"
-#include "imgurtalker.h"
+#include "imgurapi3.h"
 
 using namespace KIPI;
 using namespace KIPIPlugins;
@@ -38,35 +38,30 @@ using namespace KIPIPlugins;
 namespace KIPIImgurPlugin
 {
 
+class ImgurImageListViewItem;
+
 class ImgurImagesList : public KPImagesList
 {
     Q_OBJECT
 
 public:
-
     /* The different columns in a list. */
     enum FieldType
     {
-        Title           = KPImagesListView::Filename,
-        Description     = KPImagesListView::User1,
-        URL             = KPImagesListView::User2,
-        DeleteURL       = KPImagesListView::User3
+        Title           = KPImagesListView::User1,
+        Description     = KPImagesListView::User2,
+        URL             = KPImagesListView::User3,
+        DeleteURL       = KPImagesListView::User4
     };
 
     ImgurImagesList(QWidget* const parent = 0);
-    ~ImgurImagesList();
-
-public:
-
-    // implement this, if you have special item widgets, e.g. an edit line
-    // they will be set automatically when adding items, changing order, etc.
-    virtual void updateItemWidgets();
+    ~ImgurImagesList() override {}
+    
+    QList<const ImgurImageListViewItem *> getPendingItems();
 
 public Q_SLOTS:
-
-    void slotAddImages(const QList<QUrl>& list);
-    void slotUploadSuccess(const QUrl& imageUrl, const ImgurSuccess& success);
-    void slotUploadError(const QUrl& imageUrl, const ImgurError& error);
+    void slotAddImages(const QList<QUrl>& list) override;
+    void slotSuccess(const ImgurAPI3Result &result);
     void slotDoubleClick(QTreeWidgetItem* element, int i);
 };
 
@@ -75,9 +70,8 @@ public Q_SLOTS:
 class ImgurImageListViewItem : public KPImagesListViewItem
 {
 public:
-
     ImgurImageListViewItem(KPImagesListView* const view, const QUrl& url);
-    virtual ~ImgurImageListViewItem();
+    ~ImgurImageListViewItem() override {}
 
     void setTitle(const QString& str);
     QString Title() const;
@@ -85,22 +79,13 @@ public:
     void setDescription(const QString& str);
     QString Description() const;
 
-    void setUrl(const QString& str);
-    QString Url() const;
-
-    void setDeleteUrl(const QString& str);
-    QString deleteUrl() const;
-
-    //QString destPath() const;
-
-private:
+    void setImgurUrl(const QString& str);
+    QString ImgurUrl() const;
 
-    QString m_Title;
-    QString m_Description;
-    QString m_Url;
-    QString m_deleteUrl;
+    void setImgurDeleteUrl(const QString& str);
+    QString ImgurDeleteUrl() const;
 };
 
-} // namespace KIPIImgurTalkerPlugin
+} // namespace KIPIImgurPlugin
 
 #endif // IMGURIMAGESLIST_H
diff --git a/imgur/imgurresponses.json b/imgur/imgurresponses.json
deleted file mode 100644
index 4d2b367..0000000
--- a/imgur/imgurresponses.json
+++ /dev/null
@@ -1,57 +0,0 @@
-{
-	"error": {
-		"message":"Invalid API Key",
-		"request":"/2/upload.json",
-		"method":"post",
-		"format":"json",
-		"parameters":"key = 2da1cc4923f33dc72885aa32adede5c3asd"
-	 },
-	"upload": {
-		"image": {
-			"name":null,
-			"title":"TEST Kipi Imgur uploader",
-			"caption":null,
-			"hash":"yVOGu",
-			"deletehash":"JPTKJ3FPSsk10G4",
-			"datetime":"2012-02-11 11:10:53",
-			"type":"image/png",
-			"animated":"false",
-			"width":480,
-			"height":852,
-			"size":262377,
-			"views":0,
-			"bandwidth":0
-		 },
-		 "links": {
-			"original":"http://i.imgur.com/yVOGu.png",
-			"imgur_page":"http://imgur.com/yVOGu",
-			"delete_page":"http://imgur.com/delete/JPTKJ3FPSsk10G4",
-			"small_square":"http://i.imgur.com/yVOGus.jpg",
-			"large_thumbnail":"http://i.imgur.com/yVOGul.jpg"
-		}
-	},
-	"upload": {
-		"image": { 
-			"name":null,
-			"title":"TEST Kipi Imgur uploader",
-			"caption":null,
-			"hash":"ljhyl",
-			"deletehash":"hXx7s7vdsuqyB1k",
-			"datetime":"2012-02-11 11:56:09",
-			"type":"image/png",
-			"animated":"false",
-			"width":480,
-			"height":852,
-			"size":279347,
-			"views":0,
-			"bandwidth":0
-		},
-		"links": {
-			"original":"http://i.imgur.com/ljhyl.png",
-			"imgur_page":"http://imgur.com/ljhyl",
-			"delete_page":"http://imgur.com/delete/hXx7s7vdsuqyB1k",
-			"small_square":"http://i.imgur.com/ljhyls.jpg",
-			"large_thumbnail":"http://i.imgur.com/ljhyll.jpg"
-		}
-	}
-}
\ No newline at end of file
diff --git a/imgur/imgurtalker.cpp b/imgur/imgurtalker.cpp
deleted file mode 100644
index 2e8e2f1..0000000
--- a/imgur/imgurtalker.cpp
+++ /dev/null
@@ -1,425 +0,0 @@
-/* ============================================================
- *
- * This file is a part of kipi-plugins project
- * http://www.kipi-plugins.org
- *
- * Date        : 2010-02-04
- * Description : a tool to export images to imgur.com
- *
- * Copyright (C) 2010-2012 by Marius Orcsik <marius at habarnam dot ro>
- *
- * This program is free software; you can redistribute it
- * and/or modify it under the terms of the GNU General
- * Public License as published by the Free Software Foundation;
- * either version 2, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * ============================================================ */
-
-#include "imgurtalker.h"
-
-// Qt includes
-
-#include <QVariant>
-#include <QJsonDocument>
-#include <QJsonParseError>
-#include <QJsonObject>
-#include <QJsonValue>
-#include <QJsonArray>
-#include <QUrlQuery>
-#include <QNetworkAccessManager>
-
-// KDE includes
-
-#include <klocalizedstring.h>
-
-// Libkipi includes
-
-#include <KIPI/ImageCollection>
-
-// Local includes
-
-#include "kipiplugins_debug.h"
-#include "mpform.h"
-#include "kpversion.h"
-#include "plugin_imgur.h"
-
-namespace KIPIImgurPlugin
-{
-typedef QMultiMap<QString, QString> KQOAuthParameters;
-
-class ImgurTalker::Private
-{
-public:
-
-    Private()
-    {
-        parent                      = 0;
-        interface                   = 0;
-        netMngr                     = 0;
-        reply                       = 0;
-        continueUpload              = true;
-        userAgent                   = QLatin1String("KIPI-Plugins-ImgurExport") + QLatin1String("/") + kipipluginsVersion();
-        const char _imgurClientId[] = _IMGUR_API_ANONYMOUS_CLIENT_ID;
-        anonymousClientId           = QByteArray(_imgurClientId);
-    }
-
-    bool                   continueUpload;
-    QString                userAgent;
-
-    QByteArray             anonymousClientId;
-
-    QWidget*               parent;
-    Interface*             interface;
-    QNetworkAccessManager* netMngr;
-    QNetworkReply*         reply;
-};
-
-ImgurTalker::ImgurTalker(Interface* const interface, QWidget* const parent)
-    : d(new Private)
-{
-    d->parent    = parent;
-    d->interface = interface;
-    d->reply     = 0;
-    m_queue      = new QList<QUrl>();
-    m_state      = IR_LOGOUT;
-
-    d->netMngr   = new QNetworkAccessManager(this);
-
-    connect(d->netMngr, SIGNAL(finished(QNetworkReply*)),
-            this, SLOT(slotFinished(QNetworkReply*)));
-
-    connect(this, SIGNAL(signalUploadDone(QUrl)),
-            this, SLOT(slotUploadDone(QUrl)));
-
-    // -------------------------------------------------------------------------
-
-    ImageCollection images = interface->currentSelection();
-
-    if (images.isValid())
-    {
-        slotAddItems(images.images());
-    }
-}
-
-ImgurTalker::~ImgurTalker()
-{
-    if (d->reply)
-    {
-        d->reply->abort();
-    }
-
-    delete d;
-}
-
-void ImgurTalker::parseResponse(const QByteArray& buffer)
-{
-    bool parseOk = false;
-    emit signalUploadDone(m_currentUrl);
-
-    switch(m_state)
-    {
-        case IE_REMOVEPHOTO:
-            parseOk = parseResponseImageRemove(buffer);
-            break;
-        case IE_ADDPHOTO:
-            parseOk = parseResponseImageUpload(buffer);
-            break;
-        default:
-            break;
-    }
-
-    if (!parseOk)
-    {
-        ImgurError error;
-        error.message = i18n("Unexpected response from the web service");
-        emit signalError(m_currentUrl, error);
-
-        // received something unexpected
-        qCDebug(KIPIPLUGINS_LOG) << error.message;
-    }
-
-    emit signalBusy(false);
-}
-
-void ImgurTalker::slotFinished(QNetworkReply* reply)
-{
-    if (reply != d->reply)
-    {
-        return;
-    }
-
-    d->reply = 0;
-
-    if (reply->error() != QNetworkReply::NoError)
-    {
-        ImgurError err;
-        err.message = i18n("Upload failed");
-        emit signalError(m_currentUrl, err); //reply->errorString()
-        qCDebug(KIPIPLUGINS_LOG) << "Error :" << reply->errorString();
-    }
-
-    parseResponse(reply->readAll());
-
-    reply->deleteLater();
-    return;
-}
-
-void ImgurTalker::slotUploadDone(const QUrl& currentFile)
-{
-    // removing the top of the queue
-    if (!m_queue->isEmpty())
-    {
-        m_queue->removeFirst();
-        emit signalQueueChanged();
-    }
-
-    qCDebug(KIPIPLUGINS_LOG) << "Upload done for" << currentFile << "Queue has" << m_queue->length() << "items";
-}
-
-void ImgurTalker::slotContinueUpload(bool yes)
-{
-    d->continueUpload = yes;
-
-    if (yes && !m_queue->isEmpty())
-    {
-        // the top of the queue was already removed - first() is a new image
-        imageUpload(m_queue->first());
-    }
-
-    return;
-}
-
-bool ImgurTalker::parseResponseImageRemove(const QByteArray& data)
-{
-    if (data.isEmpty())
-    {
-        // TODO
-    }
-
-    return false;
-}
-
-bool ImgurTalker::parseResponseImageUpload(const QByteArray& data)
-{
-    qCDebug(KIPIPLUGINS_LOG) << "Upload Image data is " << data;
-
-    if (data.isEmpty())
-        return false;
-
-    QJsonParseError err;
-    QJsonDocument doc = QJsonDocument::fromJson(data, &err);
-    bool ok           = (err.error == QJsonParseError::NoError);
-
-    if (ok)
-    {
-        QJsonObject jsonObject = doc.object();
-
-        if (jsonObject.contains(QString::fromLatin1("data")))
-        {
-            ImgurSuccess success;
-            QJsonObject obj1          = jsonObject[QString::fromLatin1("data")].toObject();
-
-            success.image.id          = obj1[QString::fromLatin1("id")].toString();
-
-            success.image.type        = obj1[QString::fromLatin1("type")].toString();
-
-            success.image.name        = obj1[QString::fromLatin1("name")].toString();
-            qCDebug(KIPIPLUGINS_LOG) << "Name is " << success.image.name;
-
-            success.image.title       = obj1[QString::fromLatin1("title")].toString();
-
-            success.image.description = obj1[QString::fromLatin1("description")].toString();
-
-            success.image.deletehash  = obj1[QString::fromLatin1("deletehash")].toString();
-
-            success.image.animated    = (obj1[QString::fromLatin1("animated")].toString() == QString::fromLatin1("true"));
-
-            success.image.width       = obj1[QString::fromLatin1("width")].toString().toInt();
-
-            success.image.height      = obj1[QString::fromLatin1("height")].toString().toInt();
-
-            success.image.size        = obj1[QString::fromLatin1("size")].toString().toInt();
-
-            success.image.views       = obj1[QString::fromLatin1("views")].toString().toInt();
-
-            success.image.bandwidth   = obj1[QString::fromLatin1("bandwidth")].toString().toLongLong();
-
-            success.image.link        = QUrl(obj1[QString::fromLatin1("link")].toString());
-            qCDebug(KIPIPLUGINS_LOG) << "Link original is " << success.image.link;
-
-            emit signalSuccess(m_currentUrl, success);
-        }
-
-        if (jsonObject.contains(QString::fromLatin1("error")))
-        {
-            ImgurError error;
-            QJsonObject obj  = jsonObject[QString::fromLatin1("error")].toObject();
-
-            error.message    = obj[QString::fromLatin1("message")].toString();
-
-            error.request    = obj[QString::fromLatin1("request")].toString();
-
-            error.parameters = obj[QString::fromLatin1("parameters")].toString();
-
-            if (QString::compare(obj[QString::fromLatin1("method")].toString(),
-                                 QString::fromLatin1("get"), Qt::CaseInsensitive) == 0)
-            {
-                error.method = ImgurError::GET;
-            }
-            else if (QString::compare(obj[QString::fromLatin1("method")].toString(),
-                                QString::fromLatin1("post"), Qt::CaseInsensitive) == 0)
-            {
-                error.method = ImgurError::POST;
-            }
-            else if (QString::compare(obj[QString::fromLatin1("format")].toString(),
-                                 QString::fromLatin1("json"), Qt::CaseInsensitive) == 0)
-            {
-                error.format = ImgurError::JSON;
-            }
-            else if (QString::compare(obj[QString::fromLatin1("format")].toString(),
-                                 QString::fromLatin1("xml"), Qt::CaseInsensitive) == 0)
-            {
-                error.format = ImgurError::XML;
-            }
-
-            emit signalError(m_currentUrl, error);
-            qCDebug(KIPIPLUGINS_LOG) << "Imgur Error:" << error.message;
-        }
-    }
-    else
-    {
-        ImgurError error;
-        error.message = i18n("Parse error");
-        emit signalError (m_currentUrl, error);
-        qCDebug(KIPIPLUGINS_LOG) << "Parse Error";
-    }
-
-    return ok;
-}
-
-void ImgurTalker::imageUpload (const QUrl& filePath)
-{
-    m_state = IE_ADDPHOTO;
-
-    setCurrentUrl(filePath);
-
-    qCDebug(KIPIPLUGINS_LOG) << "Anonymous upload of " << filePath;
-
-    emit signalUploadStart(filePath);
-    emit signalBusy(true);
-
-    MPForm form;
-
-    QUrl exportUrl = QUrl(ImgurConnection::APIuploadURL());
-    QUrlQuery q(exportUrl);
-    q.addQueryItem(QString::fromLatin1("name"), filePath.fileName());
-
-    // This should be replaced with something the user submits
-    q.addQueryItem(QString::fromLatin1("title"), filePath.fileName());
-
-    // This should be replaced with something the user submits
-    //q.addQueryItem("caption", "");
-
-    q.addQueryItem(QString::fromLatin1("type"), QString::fromLatin1("file"));
-    exportUrl.setQuery(q);
-
-    form.addFile(QString::fromLatin1("image"), filePath.toLocalFile());
-    form.finish();
-
-    QNetworkRequest netRequest(exportUrl);
-    netRequest.setHeader(QNetworkRequest::ContentTypeHeader, form.contentType());
-    netRequest.setRawHeader("Authorization", "Client-ID " + d->anonymousClientId);
-    netRequest.setHeader(QNetworkRequest::UserAgentHeader, d->userAgent);
-
-    d->reply = d->netMngr->post(netRequest, form.formData());
-}
-
-bool ImgurTalker::imageRemove(const QString& delete_hash)
-{
-    // @TODO : make sure it works
-    MPForm form;
-
-    QUrl removeUrl = QUrl(ImgurConnection::APIdeleteURL());
-    removeUrl.setPath(removeUrl.path() + QLatin1Char('/') + delete_hash + QString::fromLatin1(".json"));
-
-    form.finish();
-
-    QNetworkRequest netRequest(removeUrl);
-    netRequest.setHeader(QNetworkRequest::ContentTypeHeader, form.contentType());
-    netRequest.setHeader(QNetworkRequest::UserAgentHeader, d->userAgent);
-
-    d->reply = d->netMngr->post(netRequest, form.formData());
-
-    m_state = IE_REMOVEPHOTO;
-
-    emit signalBusy(true);
-    emit signalQueueChanged();
-
-    return true;
-}
-
-void ImgurTalker::cancel()
-{
-    if (d->reply)
-    {
-        d->reply->abort();
-        d->reply = 0;
-    }
-
-    emit signalBusy(false);
-}
-
-void ImgurTalker::slotAddItems(const QList<QUrl>& list)
-{
-    if (list.isEmpty())
-    {
-        return;
-    }
-
-    for( QList<QUrl>::ConstIterator it = list.begin(); it != list.end(); ++it )
-    {
-        if (!m_queue->contains(*it))
-        {
-            m_queue->append(*it);
-        }
-    }
-
-    emit signalQueueChanged();
-}
-
-void ImgurTalker::slotRemoveItems(const QList<QUrl> &list)
-{
-    if (list.isEmpty())
-    {
-        return;
-    }
-
-    for( QList<QUrl>::ConstIterator it = list.begin(); it != list.end(); ++it )
-    {
-        m_queue->removeAll(*it);
-    }
-
-    emit signalQueueChanged();
-}
-
-void ImgurTalker::setCurrentUrl(const QUrl& url)
-{
-    m_currentUrl = url;
-}
-
-QList<QUrl>* ImgurTalker::imageQueue() const
-{
-    return m_queue;
-}
-
-QUrl ImgurTalker::currentUrl() const
-{
-    return m_currentUrl;
-}
-
-} // namespace KIPIImgurPlugin
diff --git a/imgur/imgurtalker.h b/imgur/imgurtalker.h
deleted file mode 100644
index e4bea33..0000000
--- a/imgur/imgurtalker.h
+++ /dev/null
@@ -1,111 +0,0 @@
-/* ============================================================
- *
- * This file is a part of kipi-plugins project
- * http://www.kipi-plugins.org
- *
- * Date        : 2010-02-04
- * Description : a tool to export images to imgur.com
- *
- * Copyright (C) 2010-2012 by Marius Orcsik <marius at habarnam dot ro>
- *
- * This program is free software; you can redistribute it
- * and/or modify it under the terms of the GNU General
- * Public License as published by the Free Software Foundation;
- * either version 2, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * ============================================================ */
-
-#ifndef IMGURTALKER_H
-#define IMGURTALKER_H
-
-// Qt includes
-
-#include <QWidget>
-#include <QObject>
-#include <QFileInfo>
-#include <QSettings>
-#include <QUrl>
-#include <QNetworkReply>
-
-// Libkipi includes
-
-#include <KIPI/Interface>
-
-// Local includes
-
-#include "imgurtalker_common.h"
-
-using namespace KIPI;
-
-namespace KIPIImgurPlugin
-{
-
-class ImgurTalker : public QWidget
-{
-    Q_OBJECT
-
-public:
-
-    enum State
-    {
-        IE_ADDPHOTO = 1,
-        IE_REMOVEPHOTO,
-        IE_LOGIN,
-        IR_LOGOUT
-    };
-
-public:
-
-    ImgurTalker(Interface* const iface, QWidget* const parent = 0);
-    ~ImgurTalker();
-
-    QUrl         currentUrl() const;
-    void         setCurrentUrl(const QUrl& u);
-    void         cancel();
-    bool         imageRemove(const QString& hash);
-    QList<QUrl>* imageQueue() const;
-    void         imageUpload(const QUrl& filePath);
-    void         parseResponse(const QByteArray& result);
-
-Q_SIGNALS:
-
-    void signalBusy(bool busy);
-    void signalUploadStart(const QUrl& currentFile);
-    void signalUploadDone(const QUrl& currentFile);
-    void signalError(const QUrl& currentFile, const ImgurError& err);
-    void signalSuccess(const QUrl& currentFile, const ImgurSuccess& success);
-    void signalQueueChanged();
-
-private:
-
-    bool parseResponseImageUpload(const QByteArray& data);
-    bool parseResponseImageRemove(const QByteArray& data);
-
-protected Q_SLOTS:
-
-    void slotFinished(QNetworkReply* reply);
-    void slotAddItems(const QList<QUrl>& list);
-    void slotRemoveItems(const QList<QUrl>& list);
-    void slotUploadDone(const QUrl& currentFile);
-    void slotContinueUpload(bool yes);
-
-protected:
-
-    QList<QUrl>* m_queue;
-    QUrl         m_currentUrl;
-    State        m_state;
-
-private:
-
-    class Private;
-    Private* const d;
-};
-
-} // namespace KIPIImgurPlugin
-
-#endif // IMGURTALKER_H
diff --git a/imgur/imgurtalker_common.h b/imgur/imgurtalker_common.h
deleted file mode 100644
index 02ecb8d..0000000
--- a/imgur/imgurtalker_common.h
+++ /dev/null
@@ -1,158 +0,0 @@
-/* ============================================================
- *
- * This file is a part of kipi-plugins project
- * http://www.kipi-plugins.org
- *
- * Date        : 2010-02-04
- * Description : a tool to export images to imgur.com
- *
- * Copyright (C) 2010-2012 by Marius Orcsik <marius at habarnam dot ro>
- *
- * This program is free software; you can redistribute it
- * and/or modify it under the terms of the GNU General
- * Public License as published by the Free Software Foundation;
- * either version 2, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * ============================================================ */
-
-#ifndef IMGURTALKER_COMMON_H
-#define IMGURTALKER_COMMON_H
-
-// API key from imgur
-#define _IMGUR_API_ANONYMOUS_CLIENT_ID "048d0b40574528c";
-
-#ifdef OAUTH_ENABLED
-#   define _IMGUR_API_CONSUMER_KEY "9ad9d48124b7137d9cc9e0397219f52004fcba12a";
-#   define _IMGUR_API_CONSUMER_SECRET "26b83f19f6d045006d769869b9c623e0";
-#endif //OAUTH_ENABLED
-
-// Qt includes
-
-#include <QDateTime>
-#include <QString>
-#include <QUrl>
-
-namespace KIPIImgurPlugin
-{
-
-class ImgurConnection
-{
-public:
-
-    static QString APIuploadURL()
-    {
-        return QLatin1String("https://api.imgur.com/3/image.json");
-    }
-
-    static QString APIdeleteURL()
-    {
-        return QLatin1String("https://api.imgur.com/3/delete.json");
-    }
-
-    static QString OAuthTokenEndPoint()
-    {
-        return QLatin1String("https://api.imgur.com/oauth/request_token");
-    }
-
-    static QString OAuthAccessEndPoint()
-    {
-        return QLatin1String("https://api.imgur.com/oauth/access_token");
-    }
-
-    static QString OAuthAuthorizationEndPoint()
-    {
-        return QLatin1String("https://api.imgur.com/oauth/authorize");
-    }
-
-    static QUrl originalURL(QString imageHash)
-    {
-        return QUrl(QLatin1String("http://i.imgur.com/") + imageHash + QLatin1String(".jpg"));
-    } // this is wrong
-
-    static QUrl pageURL(QString imageId)
-    {
-        return QUrl(QLatin1String("http://imgur.com/") + imageId);
-    }
-
-    static QUrl deleteURL(QString deleteHash)
-    {
-        return QUrl(QLatin1String("http://imgur.com/delete/") + deleteHash);
-    }
-};
-
-/*
-QString ImgurConnection::uploadURL = QLatin1String("https://api.imgur.com/2/upload.json");
-QString ImgurConnection::deleteURL = QLatin1String("https://api.imgur.com/2/delete.json");
-QString ImgurConnection::OAuthTokenEndPoint = QLatin1String("https://api.imgur.com/oauth/request_token");
-QString ImgurConnection::OAuthAccessEndPoint = QLatin1String("https://api.imgur.com/oauth/access_token");
-QString ImgurConnection::OAuthAuthorizationEndPoint = QLatin1String("https://api.imgur.com/oauth/authorize");
-*/
-
-struct ImgurError
-{
-    enum ImgurMethod
-    {
-        POST = 0,
-        GET,
-        HEAD
-    };
-
-    enum ImgurFormat
-    {
-        XML = 0,
-        JSON
-    };
-
-    ImgurError()
-    {
-        method = POST;
-        format = XML;
-    }
-
-    ImgurMethod method;
-    ImgurFormat format;
-    QString     message;
-    QString     request;
-    QVariant    parameters;
-};
-
-// -----------------------------------------------------------------------------
-
-struct ImgurUploadData
-{
-    QString title;
-    QString caption;
-    QUrl    fileUrl;
-};
-
-// -----------------------------------------------------------------------------
-
-struct ImgurSuccess
-{
-    struct ImgurImage
-    {
-        QString    id;
-        QString    type;       // maybe enum
-        QString    name;
-        QString    title;
-        QString    description;
-        QString    deletehash;
-        QDateTime  datetime;
-        bool       animated;
-        uint       width;
-        uint       height;
-        uint       size;
-        uint       views;
-        qulonglong bandwidth;
-        QUrl       link;
-    } image;
-};
-
-} // namespace KIPIImgurPlugin
-
-#endif // IMGURTALKER_COMMON_H
diff --git a/imgur/imgurtalkerauth.cpp b/imgur/imgurtalkerauth.cpp
deleted file mode 100644
index f4d2fe1..0000000
--- a/imgur/imgurtalkerauth.cpp
+++ /dev/null
@@ -1,289 +0,0 @@
-/* ============================================================
- *
- * This file is a part of kipi-plugins project
- * http://www.kipi-plugins.org
- *
- * Date        : 2010-02-04
- * Description : a tool to export images to imgur.com
- *
- * Copyright (C) 2010-2012 by Marius Orcsik <marius at habarnam dot ro>
- *
- * This program is free software; you can redistribute it
- * and/or modify it under the terms of the GNU General
- * Public License as published by the Free Software Foundation;
- * either version 2, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * ============================================================ */
-
-#include "imgurtalkerauth.h"
-
-// Qt includes
-
-#include <QImageReader>
-
-// Local includes
-
-#include "kipiplugins_debug.h"
-#include "kpversion.h"
-#include "plugin_imgur.h"
-
-namespace KIPIImgurPlugin
-{
-
-class ImgurTalkerAuth::Private
-{
-public:
-
-    Private()
-    {
-        userAgent                            = QLatin1String("KIPI-Plugins-ImgurExport") + QLatin1String("/") + kipipluginsVersion();
-        const char _imgurApiConsumerKey[]    = _IMGUR_API_CONSUMER_KEY;
-        consumerKey                          = QByteArray( _imgurApiConsumerKey );
-        const char _imgurApiConsumerSecret[] = _IMGUR_API_CONSUMER_SECRET;
-        consumerSecret                       = QByteArray( _imgurApiConsumerSecret );
-        continueUpload                       = true;
-        OAuthService                         = 0;
-        OAuthRequest                         = 0;
-    }
-
-    QString         userAgent;
-
-    KQOAuthManager* OAuthService;
-    KQOAuthRequest* OAuthRequest;
-
-    QByteArray      consumerKey;
-    QByteArray      consumerSecret;
-    QByteArray      oauthToken;
-    QByteArray      oauthTokenSecret;
-
-    bool            continueUpload;
-};
-
-ImgurTalkerAuth::ImgurTalkerAuth (Interface* const interface, QWidget* const parent)
-    : ImgurTalker(interface, parent),
-      d(new Private)
-{
-    d->OAuthRequest = new KQOAuthRequest();
-    d->OAuthService = new KQOAuthManager(this);
-}
-
-ImgurTalkerAuth::~ImgurTalkerAuth()
-{
-    delete d;
-}
-
-const char* ImgurTalkerAuth::getAuthError(KQOAuthManager::KQOAuthError error)
-{
-    switch (error)
-    {
-        case KQOAuthManager::NetworkError:               // Network error: timeout, cannot connect.
-            return I18N_NOOP("Network error: timeout, cannot connect.");
-            break;
-        case KQOAuthManager::RequestEndpointError:       // Request endpoint is not valid.
-            return I18N_NOOP("Request endpoint is not valid.");
-            break;
-        case KQOAuthManager::RequestValidationError:     // Request is not valid: some parameter missing?
-            return I18N_NOOP("Request is not valid: some parameter missing?");
-            break;
-        case KQOAuthManager::RequestUnauthorized:        // Authorization error: trying to access a resource without tokens.
-            return I18N_NOOP("Authorization error: trying to access a resource without tokens.");
-            break;
-        case KQOAuthManager::RequestError:               // The given request to KQOAuthManager is invalid: NULL?,
-            return I18N_NOOP("The given request is invalid.");
-            break;
-        case KQOAuthManager::ManagerError:                // Manager error, cannot use for sending requests.
-            return I18N_NOOP("Manager error, cannot use for sending requests.");
-            break;
-        case KQOAuthManager::NoError:                    // No error
-        default:
-            return I18N_NOOP("No error");
-            break;
-    }
-}
-
-void ImgurTalkerAuth::cancel()
-{
-    if (d->OAuthRequest)
-    {
-        d->OAuthRequest->clearRequest();
-    }
-
-    emit signalBusy(false);
-}
-
-void ImgurTalkerAuth::imageUpload (const QUrl& filePath)
-{
-    qCDebug(KIPIPLUGINS_LOG) << "Authenticated" << (d->OAuthService->isAuthorized() ? "Yes" : "No");
-    setCurrentUrl(filePath);
-
-    qCDebug(KIPIPLUGINS_LOG) << "Authenticated upload of" << currentUrl();
-
-    m_state = IE_ADDPHOTO;
-
-    emit signalUploadStart(filePath);
-    emit signalBusy(true);
-
-    QByteArray contentType = QImageReader::imageFormat(filePath.toLocalFile());
-
-    QFile imageFile(filePath.toLocalFile());
-
-    if (!imageFile.open(QIODevice::ReadOnly))
-    {
-        return;
-    }
-
-    QByteArray imageData   = imageFile.readAll();
-
-    d->OAuthRequest->setEnableDebugOutput (false);
-    d->OAuthRequest->initRequest(KQOAuthRequest::AuthorizedRequest, QUrl(ImgurConnection::APIuploadURL()));
-    d->OAuthRequest->setConsumerKey(d->consumerKey.data() );
-    d->OAuthRequest->setConsumerSecretKey(d->consumerSecret.data() );
-    d->OAuthRequest->setToken( d->oauthToken.data() );
-    d->OAuthRequest->setTokenSecret( d->oauthTokenSecret.data() );
-
-    KQOAuthParameters params;
-    params.insert(QLatin1String("name"),           filePath.fileName());
-    params.insert(QLatin1String("title"),          filePath.fileName());
-    params.insert(QLatin1String("content-type"),   contentType.data());
-    params.insert(QLatin1String("content-length"), QString::fromUtf8("Content-Length: %1").arg(imageData.toBase64().length()));
-    params.insert(QLatin1String("UserAgent"),      d->userAgent);
-    params.insert(QLatin1String("image"),          imageData.toBase64());
-
-    d->OAuthRequest->setAdditionalParameters(params);
-    d->OAuthService->executeRequest(d->OAuthRequest);
-/*
-   connect(d->OAuthService, SIGNAL(requestReady(QByteArray)),
-           this, SLOT(slotRequestReady(QByteArray)));
-
-   connect(d->OAuthService, SIGNAL(authorizedRequestDone()),
-           this, SLOT(slotAuthorizedRequestDone()));
-*/
-}
-
-void ImgurTalkerAuth::slotOAuthLogin()
-{
-    m_state = IE_LOGIN;
-
-    d->OAuthRequest->initRequest(KQOAuthRequest::TemporaryCredentials, QUrl(ImgurConnection::OAuthTokenEndPoint()));
-    d->OAuthRequest->setConsumerKey(d->consumerKey.data());
-    d->OAuthRequest->setConsumerSecretKey(d->consumerSecret.data());
-
-    d->OAuthRequest->setEnableDebugOutput(true);
-
-    connect(d->OAuthService, SIGNAL(temporaryTokenReceived(QString,QString)),
-            this, SLOT(slotTemporaryTokenReceived(QString,QString)));
-
-    connect(d->OAuthService, SIGNAL(authorizationReceived(QString,QString)),
-            this, SLOT(slotAuthorizationReceived(QString,QString)));
-
-    connect(d->OAuthService, SIGNAL(accessTokenReceived(QString,QString)),
-            this, SLOT(slotAccessTokenReceived(QString,QString)));
-
-    connect(d->OAuthService, SIGNAL(requestReady(QByteArray)),
-            this, SLOT(slotRequestReady(QByteArray)));
-
-    d->OAuthService->setHandleUserAuthorization(true);
-    d->OAuthService->executeRequest(d->OAuthRequest);
-
-    emit signalBusy(true);
-}
-
-void ImgurTalkerAuth::slotTemporaryTokenReceived(const QString& token, const QString& tokenSecret)
-{
-    qCDebug(KIPIPLUGINS_LOG) << "Temporary token received: " << token << tokenSecret;
-
-    if( d->OAuthService->lastError() == KQOAuthManager::NoError)
-    {
-        qCDebug(KIPIPLUGINS_LOG) << "Asking for user's permission to access protected resources. Opening URL: " << ImgurConnection::OAuthAuthorizationEndPoint();
-        d->OAuthService->getUserAuthorization(QUrl(ImgurConnection::OAuthAuthorizationEndPoint()));
-    }
-
-    if (d->OAuthService->lastError() != KQOAuthManager::NoError)
-    {
-        //emit signalAuthenticated(false, getAuthError(d->OAuthService->lastError()));
-        //emit signalBusy(false);
-        qCDebug(KIPIPLUGINS_LOG) << "Error :" << getAuthError(d->OAuthService->lastError());
-    }
-}
-
-void ImgurTalkerAuth::slotAuthorizationReceived(const QString& token, const QString& verifier)
-{
-    qCDebug(KIPIPLUGINS_LOG) << "User authorization received: " << token << verifier;
-
-    if (d->OAuthService->lastError() == KQOAuthManager::NoError)
-    {
-        d->OAuthService->getUserAccessTokens(QUrl(ImgurConnection::OAuthAccessEndPoint()));
-    }
-
-    if( d->OAuthService->lastError() != KQOAuthManager::NoError)
-    {
-        emit signalAuthenticated(false, i18n(getAuthError(d->OAuthService->lastError())));
-        emit signalBusy(false);
-
-        d->OAuthRequest->clearRequest();
-        qCDebug(KIPIPLUGINS_LOG) << "Auth error :" << getAuthError(d->OAuthService->lastError());
-    }
-}
-
-void ImgurTalkerAuth::slotAccessTokenReceived(const QString& token, const QString& tokenSecret)
-{
-    qCDebug(KIPIPLUGINS_LOG) << "Access token received: " << token << tokenSecret;
-
-    d->oauthToken       = token.toLatin1();
-    d->oauthTokenSecret = tokenSecret.toLatin1();
-
-    emit signalAuthenticated(true, i18n("OK"));
-    emit signalBusy(false);
-
-    qCDebug(KIPIPLUGINS_LOG) << "Access tokens now stored";
-}
-
-void ImgurTalkerAuth::slotAuthorizedRequestDone()
-{
-    qCDebug(KIPIPLUGINS_LOG) << "Request received from Imgur!";
-}
-
-void ImgurTalkerAuth::slotRequestReady(const QByteArray& response)
-{
-    //qCDebug(KIPIPLUGINS_LOG) << "Authorized: " << d->OAuthService->isAuthorized();
-    //qCDebug(KIPIPLUGINS_LOG) << "Verified: " << d->OAuthService->isAuthorized();
-    //qCDebug(KIPIPLUGINS_LOG) << "End point: " << d->OAuthRequest->requestEndpoint();
-    //qCDebug(KIPIPLUGINS_LOG) << "Response from the service: " << response;
-
-    if (d->OAuthService->isAuthorized() && d->OAuthService->isVerified() &&
-        d->OAuthRequest->requestEndpoint() == QUrl(ImgurConnection::APIuploadURL())
-       )
-    {
-        ImgurTalker::parseResponse (response);
-    }
-
-    return;
-}
-
-void ImgurTalkerAuth::slotContinueUpload(bool yes)
-{
-    d->continueUpload = yes;
-
-    if (yes && !m_queue->isEmpty())
-    {
-        if (!d->OAuthService->isAuthorized())
-        {
-            // not authenticated, we upload anonymously
-            ImgurTalker::imageUpload (m_queue->first());
-        }
-        else
-        {
-            // the top of the queue was already removed - first() is a new image
-            imageUpload (m_queue->first());
-        }
-    }
-
-    return;
-}
-
-} // namespace KIPIImgurPlugin
diff --git a/imgur/imgurtalkerauth.h b/imgur/imgurtalkerauth.h
deleted file mode 100644
index c231d45..0000000
--- a/imgur/imgurtalkerauth.h
+++ /dev/null
@@ -1,112 +0,0 @@
-/* ============================================================
- *
- * This file is a part of kipi-plugins project
- * http://www.kipi-plugins.org
- *
- * Date        : 2010-02-04
- * Description : a tool to export images to imgur.com
- *
- * Copyright (C) 2010-2012 by Marius Orcsik <marius at habarnam dot ro>
- *
- * This program is free software; you can redistribute it
- * and/or modify it under the terms of the GNU General
- * Public License as published by the Free Software Foundation;
- * either version 2, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * ============================================================ */
-
-#ifndef IMGURTALKERAUTH_H
-#define IMGURTALKERAUTH_H
-
-// Qt includes
-
-#include <QWidget>
-#include <QObject>
-#include <QFileInfo>
-#include <QDateTime>
-#include <QSettings>
-#include <QUrl>
-
-// QtKOAuth includes
-
-// Pragma directives to reduce warnings from QtKOAuth header files.
-#if not defined(__APPLE__) && defined(__GNUC__)
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wpedantic"
-#endif
-
-#if defined(__APPLE__) && defined(__clang__)
-#pragma clang diagnostic push
-#pragma clang diagnostic ignored "-Wpedantic"
-#endif
-
-#include <QtKOAuth>
-
-// Restore warnings
-#if not defined(__APPLE__) && defined(__GNUC__)
-#pragma GCC diagnostic pop
-#endif
-
-#if defined(__APPLE__) && defined(__clang__)
-#pragma clang diagnostic pop
-#endif
-
-// Libkipi includes
-
-#include <KIPI/Interface>
-
-// Local includes
-
-#include "imgurtalker_common.h"
-#include "imgurtalker.h"
-
-using namespace KIPI;
-
-namespace KIPIImgurPlugin
-{
-
-class ImgurTalkerAuth : public ImgurTalker
-{
-    Q_OBJECT
-
-public:
-
-    ImgurTalkerAuth(Interface* const iface, QWidget* const parent = 0);
-    ~ImgurTalkerAuth();
-
-    void imageUpload(const QUrl& filePath);
-    void cancel();
-
-Q_SIGNALS:
-
-    void signalAuthenticated(bool authenticated, const QString& message = QString());
-
-private:
-
-    bool               parseLoginResponse(const QByteArray& data);
-    static const char* getAuthError(KQOAuthManager::KQOAuthError error);
-
-private Q_SLOTS:
-
-    void slotOAuthLogin();
-    void slotTemporaryTokenReceived(const QString& temporaryToken, const QString& temporaryTokenSecret);
-    void slotAuthorizationReceived(const QString& token, const QString& verifier);
-    void slotAccessTokenReceived(const QString& token, const QString& tokenSecret);
-    void slotAuthorizedRequestDone();
-    void slotRequestReady(const QByteArray&);
-    void slotContinueUpload(bool yes);
-
-private:
-
-    class Private;
-    Private* const d;
-};
-
-} // namespace KIPIImgurPlugin
-
-#endif // IMGURTALKERAUTH_H
diff --git a/imgur/imgurwidget.cpp b/imgur/imgurwidget.cpp
deleted file mode 100644
index 248d224..0000000
--- a/imgur/imgurwidget.cpp
+++ /dev/null
@@ -1,322 +0,0 @@
-/* ============================================================
- *
- * This file is a part of kipi-plugins project
- * http://www.digikam.org
- *
- * Date        : 2012-02-12
- * Description : a kipi plugin to export images to the Imgur web service
- *
- * Copyright (C) 2010-2012 by Marius Orcsik <marius at habarnam dot ro>
- *
- * This program is free software; you can redistribute it
- * and/or modify it under the terms of the GNU General
- * Public License as published by the Free Software Foundation;
- * either version 2, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * ============================================================ */
-
-#include "imgurwidget.h"
-
-// Qt includes
-
-#include <QBoxLayout>
-#include <QGroupBox>
-#include <QApplication>
-#include <QStyle>
-#include <QPointer>
-#include <QPushButton>
-
-// KDE includes
-
-#include <klocalizedstring.h>
-
-// Libkipi includes
-
-#include <KIPI/Interface>
-#include <KIPI/PluginLoader>
-
-// Local includes
-
-#include "kipiplugins_debug.h"
-#include "plugin_imgur.h"
-
-namespace KIPIImgurPlugin
-{
-
-class ImgurWidget::Private
-{
-public:
-
-    Private()
-    {
-        headerLbl      = 0;
-        imagesList     = 0;
-        progressBar    = 0;
-        processedCount = 0;
-        iface          = 0;
-
-        PluginLoader* const pl = PluginLoader::instance();
-
-        if (pl)
-        {
-            iface = pl->interface();
-        }
-
-#ifdef OAUTH_ENABLED
-        changeUserBtn  = 0;
-#endif //OAUTH_ENABLED
-    }
-
-    QLabel*           headerLbl;
-    ImgurImagesList*  imagesList;
-    KPProgressWidget* progressBar;
-    int               processedCount;
-    Interface*        iface;
-
-#ifdef OAUTH_ENABLED
-    QPushButton*      changeUserBtn;
-#endif //OAUTH_ENABLED
-};
-
-ImgurWidget::ImgurWidget(QWidget* const parent)
-    : QWidget(parent),
-      d(new Private)
-{
-    const int spacing = QApplication::style()->pixelMetric(QStyle::PM_DefaultLayoutSpacing);
-
-    QGridLayout* const mainLayout = new QGridLayout(this);
-    d->imagesList                 = new ImgurImagesList(this);
-    d->imagesList->loadImagesFromCurrentSelection();
-
-    QWidget* const settingsBox           = new QWidget(this);
-    QVBoxLayout* const settingsBoxLayout = new QVBoxLayout(settingsBox);
-
-    d->headerLbl = new QLabel(settingsBox);
-    d->headerLbl->setWhatsThis(i18n("This is a clickable link to open the Imgur home page in a web browser"));
-    d->headerLbl->setText(QString::fromLatin1("<h2><a href='http://imgur.com'>imgur.com</a></h2>"));
-    d->headerLbl->setOpenExternalLinks(true);
-    d->headerLbl->setFocusPolicy(Qt::NoFocus);
-
-/*
-    d->textLbl = new QLabel(settingsBox);
-    d->textLbl->setText(i18n("You can retrieve the\nimage URLs from the Xmp tags:\n"
-                             "\"Imgur URL\" and \"Imgur Delete URL\". \n"));
-    d->textLbl->setFocusPolicy(Qt::NoFocus);
-    d->textLbl->setWordWrap(true);
-*/
-
-    d->progressBar = new KPProgressWidget(settingsBox);
-    d->progressBar->setSizePolicy(QSizePolicy::Preferred, QSizePolicy::Fixed);
-    d->progressBar->setVisible(false);
-
-    // ------------------------------------------------------------------------
-
-#ifdef OAUTH_ENABLED
-    //d->dlg = new KPLoginDialog (this, Plugin_ImgurExport::name(), "Imgur authentication");
-
-    QGroupBox* const accountBox         = new QGroupBox(i18n("Imgur authorization"), settingsBox);
-    accountBox->setWhatsThis(i18n("Requesting Imgur for authorization to upload images with the KIPI Imgur Exporter plugin."));
-    QGridLayout* const accountBoxLayout = new QGridLayout(accountBox);
-
-    //QLabel* userNameLbl             = new QLabel(i18nc("imgur account settings", "Name:"), accountBox);
-    //QLabel* userNameDisplayLbl    = new QLabel(d->loggedUser, accountBox);
-
-    d->changeUserBtn = new QPushButton(i18n("Request authorization"), accountBox);
-    d->changeUserBtn->setIcon(QIcon::fromTheme(QString::fromLatin1("system-switch-user")));
-    d->changeUserBtn->setToolTip(i18n("Set permissions for the current application to upload images to Imgur."));
-
-    //accountBoxLayout->addWidget(userNameLbl,            0, 0, 1, 2);
-    //accountBoxLayout->addWidget(userNameDisplayLbl,     0, 2, 1, 2);
-    accountBoxLayout->addWidget(d->changeUserBtn,        2, 0, 1, 2);
-
-    accountBoxLayout->setContentsMargins(spacing, spacing, spacing, spacing);
-    accountBoxLayout->setSpacing(spacing);
-#endif //OAUTH_ENABLED
-
-    // ------------------------------------------------------------------------
-
-    settingsBoxLayout->addWidget(d->headerLbl);
-    //settingsBoxLayout->addWidget(d->textLbl);
-
-#ifdef OAUTH_ENABLED
-    settingsBoxLayout->addWidget(accountBox);
-    settingsBoxLayout->setAlignment(accountBox, Qt::AlignTop);
-#endif //OAUTH_ENABLED
-
-    settingsBoxLayout->addWidget(d->progressBar);
-    settingsBoxLayout->addStretch(10);
-    //settingsBoxLayout->setAlignment(d->textLbl, Qt::AlignTop);
-    settingsBoxLayout->setAlignment(d->progressBar, Qt::AlignBottom);
-    settingsBoxLayout->setContentsMargins(spacing, spacing, spacing, spacing);
-    settingsBoxLayout->setSpacing(spacing);
-
-    // -------------------------------------------------------------------------
-
-    mainLayout->addWidget(d->imagesList, 0, 0, 2, 1);
-    mainLayout->addWidget(settingsBox, 0, 1, Qt::AlignTop);
-    mainLayout->setContentsMargins(QMargins());
-    mainLayout->setSpacing(spacing);
-
-    connect(d->imagesList, SIGNAL(signalAddItems(QList<QUrl>)),
-            this, SLOT(slotAddItems(QList<QUrl>)));
-
-    connect(d->imagesList, SIGNAL(signalRemovedItems(QList<QUrl>)),
-            this, SLOT(slotRemoveItems(QList<QUrl>)));
-
-    connect(d->imagesList, SIGNAL(signalImageListChanged()),
-            this, SLOT(slotImageListChanged()));
-
-    connect(this, SIGNAL(signalImageUploadSuccess(QUrl,ImgurSuccess)),
-            d->imagesList, SLOT(slotUploadSuccess(QUrl,ImgurSuccess)));
-
-    connect(this, SIGNAL(signalImageUploadError(QUrl,ImgurError)),
-            d->imagesList, SLOT(slotUploadError(QUrl,ImgurError)));
-/*
-    connect(this, SIGNAL(signalImageUploadStart(QUrl)),
-            d->imagesList, SLOT(processing(QUrl)));
-*/
-#ifdef OAUTH_ENABLED
-    connect(d->changeUserBtn, SIGNAL(clicked()),
-            this, SLOT(slotClickedChangeUser()));
-/*
-   connect(this, SIGNAL(signalEnableAuthentication(bool)),
-           d->changeUserBtn , SLOT(setEnabled(bool)));
-   connect(d->dlg, SIGNAL(accepted()),
-           this, SLOT(slotCredentialsSet()));
-   connect(d->dlg, SIGNAL(signalLoadedNamePass(QString,QString)),
-           this, SLOT(slotLoadedNamePass(QString,QString)));
-*/
-#endif //OAUTH_ENABLED
-}
-
-ImgurWidget::~ImgurWidget()
-{
-    delete d;
-}
-
-void ImgurWidget::slotAddItems(const QList<QUrl>& list)
-{
-    emit signalAddItems(list);
-}
-
-void ImgurWidget::slotRemoveItems(const QList<QUrl>& list)
-{
-    emit signalRemoveItems(list);
-}
-
-void ImgurWidget::slotImageListChanged()
-{
-    emit signalImageListChanged();
-
-    progressBar()->setMaximum(imagesList()->imageUrls().size());
-}
-
-void ImgurWidget::slotImageUploadStart(const QUrl& imgPath)
-{
-    d->processedCount++;
-    qCDebug(KIPIPLUGINS_LOG) << "Processing" << imgPath;
-    //imagesList()->clearProcessedStatus();
-
-    imagesList()->processing(imgPath);
-
-    if (!progressBar()->isVisible())
-    {
-        progressBar()->setVisible(true);
-    }
-
-    progressBar()->progressStatusChanged(i18n("Processing %1", imgPath.fileName()));
-}
-
-void ImgurWidget::slotImageUploadSuccess(const QUrl& imgPath, const ImgurSuccess& success)
-{
-    // we add tags to the image
-
-    if (d->iface)
-    {
-        QPointer<MetadataProcessor> meta = d->iface->createMetadataProcessor();
-
-        if (meta && meta->load(imgPath))
-        {
-            meta->setXmpTagString(QLatin1String("Xmp.kipi.ImgurId"),         success.image.id);
-            meta->setXmpTagString(QLatin1String("Xmp.kipi.ImgurDeleteHash"), success.image.deletehash);
-            bool saved = meta->applyChanges();
-            qCDebug(KIPIPLUGINS_LOG) << "Metadata" << (saved ? "Saved" : "Not Saved") << "to" << imgPath;
-        }
-    }
-
-    qCDebug(KIPIPLUGINS_LOG) << "URL" << ImgurConnection::pageURL(success.image.id);
-    qCDebug(KIPIPLUGINS_LOG) << "Delete URL" << ImgurConnection::deleteURL(success.image.deletehash);
-
-    imagesList()->processed(imgPath, true);
-
-    progressBar()->setValue(d->processedCount);
-
-    emit signalImageUploadSuccess(imgPath, success);
-}
-
-void ImgurWidget::slotImageUploadError(const QUrl& imgPath, const ImgurError& error)
-{
-    imagesList()->processed(imgPath, false);
-    emit signalImageUploadError(imgPath, error);
-}
-
-ImgurImagesList* ImgurWidget::imagesList() const
-{
-    return d->imagesList;
-}
-
-KPProgressWidget* ImgurWidget::progressBar() const
-{
-    return d->progressBar;
-}
-
-void ImgurWidget::slotAuthenticated(bool authenticated, const QString& message)
-{
-    Q_UNUSED(message);
-
-#ifdef OAUTH_ENABLED
-    //qCDebug(KIPIPLUGINS_LOG) << "Disable the button.";
-    if (authenticated)
-    {
-        d->changeUserBtn->setText(i18n("Authenticated"));
-    }
-
-    d->changeUserBtn->setEnabled(!authenticated);
-    //emit signalEnableAuthentication(!authenticated);
-#else //OAUTH_ENABLED
-    Q_UNUSED(authenticated);
-#endif //OAUTH_ENABLED
-}
-
-void ImgurWidget::slotClickedChangeUser()
-{
-    emit signalClickedChangeUser();
-}
-/*
-void ImgurWidget::slotChangeUserDialog()
-{
-    //d->dlg->show();
-}
-
-void ImgurWidget::slotSetLoggedUser(bool ok)
-{
-    emit signalLoggedUserChanged(d->dlg->username());
-}
-
-void ImgurWidget::slotCredentialsSet()
-{
-//    emit signalCredentialsChanged(d->dlg->username(), d->dlg->password());
-}
-
-void ImgurWidget::slotLoadedNamePass(const QString& name, const QString& pass)
-{
-    emit signalCredentialsChanged(name, pass);
-}
-*/
-
-} // namespace KIPIImgurPlugin
diff --git a/imgur/imgurwidget.h b/imgur/imgurwidget.h
deleted file mode 100644
index d24e9ca..0000000
--- a/imgur/imgurwidget.h
+++ /dev/null
@@ -1,92 +0,0 @@
-/* ============================================================
- *
- * This file is a part of kipi-plugins project
- * http://www.digikam.org
- *
- * Date        : 2012-02-12
- * Description : a kipi plugin to export images to the Imgur web service
- *
- * Copyright (C) 2010-2012 by Marius Orcsik <marius at habarnam dot ro>
- *
- * This program is free software; you can redistribute it
- * and/or modify it under the terms of the GNU General
- * Public License as published by the Free Software Foundation;
- * either version 2, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * ============================================================ */
-
-#ifndef IMGURWIDGET_H
-#define IMGURWIDGET_H
-
-// Qt includes
-
-#include <QWidget>
-#include <QLabel>
-
-// Local includes
-
-#include "imgurtalker.h"
-#include "imgurimageslist.h"
-#include "kpprogresswidget.h"
-
-using namespace KIPIPlugins;
-
-namespace KIPIImgurPlugin
-{
-
-class ImgurWidget : public QWidget
-{
-    Q_OBJECT
-
-public:
-
-    ImgurWidget(QWidget* const parent = 0);
-    ~ImgurWidget();
-
-    ImgurImagesList*  imagesList()  const;
-    KPProgressWidget* progressBar() const;
-
-Q_SIGNALS:
-
-    void signalAddItems(const QList<QUrl>& list);
-    void signalRemoveItems(const QList<QUrl>& list);
-    void signalImageListChanged();
-
-    void signalEnableAuthentication(bool yes);
-    void signalClickedChangeUser();
-    void signalImageUploadSuccess(const QUrl& imgPath, const ImgurSuccess& success);
-    void signalImageUploadError(const QUrl& imgPath, const ImgurError& error);
-//    void signalLoggedUserChanged(QString loggedUser);
-//    void signalCredentialsChanged(QString loggedUser, QString passwd);
-
-public Q_SLOTS:
-
-    void slotAddItems(const QList<QUrl>& list);
-    void slotRemoveItems(const QList<QUrl>& list);
-    void slotImageUploadStart(const QUrl& imgPath);
-    void slotImageUploadSuccess(const QUrl& imgPath, const ImgurSuccess& success);
-    void slotImageUploadError(const QUrl& imgPath, const ImgurError& error);
-    void slotImageListChanged();
-
-
-    void slotAuthenticated (bool authenticated, const QString& message);
-    void slotClickedChangeUser();
-//    void slotChangeUserDialog();
-//    void slotSetLoggedUser(bool ok);
-//    void slotCredentialsSet();
-//    void slotLoadedNamePass(const QString& name, const QString& pass);
-
-private:
-
-    class Private;
-    Private* const d;
-};
-
-} // namespace KIPIImgurPlugin
-
-#endif /* IMGURWIDGET_H */
diff --git a/imgur/imgurwindow.cpp b/imgur/imgurwindow.cpp
index 906518b..4217d9f 100644
--- a/imgur/imgurwindow.cpp
+++ b/imgur/imgurwindow.cpp
@@ -3,10 +3,11 @@
  * This file is a part of kipi-plugins project
  * http://www.digikam.org
  *
- * Date        : 2012-02-12
+ * Date        : 2016-06-06
  * Description : a kipi plugin to export images to the Imgur web service
  *
  * Copyright (C) 2010-2012 by Marius Orcsik <marius at habarnam dot ro>
+ * Copyright (C) 2016 by Fabian Vogt <fabian at ritter dash vogt dot de>
  *
  * This program is free software; you can redistribute it
  * and/or modify it under the terms of the GNU General
@@ -24,8 +25,10 @@
 
 // Qt includes
 
-#include <QWindow>
+#include <QBoxLayout>
 #include <QCloseEvent>
+#include <QDesktopServices>
+#include <QInputDialog>
 #include <QMessageBox>
 
 // KDE includes
@@ -41,53 +44,82 @@
 #include "kpaboutdata.h"
 #include "kpversion.h"
 
-namespace KIPIImgurPlugin
-{
-
-class ImgurWindow::Private
+static const constexpr char *IMGUR_CLIENT_ID("575411e9c939b2b"),
+                            *IMGUR_CLIENT_SECRET("f39bbddf4052062735bdc7168b33aa795cab361f");
 
+namespace KIPIImgurPlugin
 {
-public:
-
-    Private()
-    {
-        webService = 0;
-        widget     = 0;
-    }
-
-#ifdef OAUTH_ENABLED
-    ImgurTalkerAuth* webService;
-#else
-    ImgurTalker*     webService;
-#endif //OAUTH_ENABLED
-
-    ImgurWidget*     widget;
-};
 
 ImgurWindow::ImgurWindow(QWidget* const /*parent*/)
-    : KPToolDialog(0),
-      d(new Private)
+    : KPToolDialog(0)
 {
-    d->widget     = new ImgurWidget(this);
-
-#ifdef OAUTH_ENABLED
-    d->webService = new ImgurTalkerAuth(iface(), this);
-#else
-    d->webService = new ImgurTalker(iface(), this);
-#endif //OAUTH_ENABLED
-
-    setMainWidget(d->widget);
+    api = new ImgurAPI3(QString::fromLatin1(IMGUR_CLIENT_ID),
+                        QString::fromLatin1(IMGUR_CLIENT_SECRET), this);
+    
+    /* Connect API signals */
+    connect(api, &ImgurAPI3::authorized, this, &ImgurWindow::apiAuthorized);
+    connect(api, &ImgurAPI3::authError, this, &ImgurWindow::apiAuthError);
+    connect(api, &ImgurAPI3::progress, this, &ImgurWindow::apiProgress);
+    connect(api, &ImgurAPI3::requestPin, this, &ImgurWindow::apiRequestPin);
+    connect(api, &ImgurAPI3::success, this, &ImgurWindow::apiSuccess);
+    connect(api, &ImgurAPI3::error, this, &ImgurWindow::apiError);
+    connect(api, &ImgurAPI3::busy, this, &ImgurWindow::apiBusy);
+    
+    /* | List | Auth | */
+    auto *mainLayout = new QHBoxLayout;
+    auto *mainWidget = new QWidget(this);
+    mainWidget->setLayout(mainLayout);
+    this->setMainWidget(mainWidget);
+    
+    this->list = new ImgurImagesList;
+    mainLayout->addWidget(list);
+    
+    /* |  Logged in as:  |
+     * | <Not logged in> |
+     * |     Forget      | */
+
+    auto *userLabelLabel = new QLabel(i18n("Logged in as:"));
+    userLabelLabel->setSizePolicy(QSizePolicy::Preferred, QSizePolicy::Fixed);
+    userLabelLabel->setAlignment(Qt::AlignHCenter | Qt::AlignTop);
+    
+    this->userLabel = new QLabel; /* Label set in readSettings() */
+    userLabel->setSizePolicy(QSizePolicy::Preferred, QSizePolicy::Fixed);
+    userLabel->setAlignment(Qt::AlignHCenter | Qt::AlignTop);
+
+    forgetButton = new QPushButton(i18n("Forget"));
+
+    auto *authLayout = new QVBoxLayout;
+    mainLayout->addLayout(authLayout);
+    authLayout->addWidget(userLabelLabel);
+    authLayout->addWidget(userLabel);
+    authLayout->addWidget(forgetButton);
+    authLayout->insertStretch(-1, 1);
+
+    /* Add anonymous upload button */
+    uploadAnonButton = new QPushButton(i18n("Upload Anonymously"));
+    addButton(uploadAnonButton, QDialogButtonBox::ApplyRole);
+    
+    /* Connect UI signals */
+    connect(forgetButton, &QPushButton::clicked,
+            this, &ImgurWindow::forgetButtonClicked);
+    connect(startButton(), &QPushButton::clicked,
+            this, &ImgurWindow::slotUpload);
+    connect(uploadAnonButton, &QPushButton::clicked,
+            this, &ImgurWindow::slotAnonUpload);
+    connect(this, &ImgurWindow::finished,
+            this, &ImgurWindow::slotFinished);
+    connect(this, &ImgurWindow::cancelClicked,
+            this, &ImgurWindow::slotCancel);
+    
     setWindowIcon(QIcon::fromTheme(QString::fromLatin1("kipi-imgur")));
     setWindowTitle(i18n("Export to imgur.com"));
     setModal(false);
 
     startButton()->setText(i18n("Upload"));
     startButton()->setToolTip(i18n("Start upload to Imgur"));
+    startButton()->setEnabled(true);
 
-    startButton()->setEnabled(!d->webService->imageQueue()->isEmpty());
-
-    // ---------------------------------------------------------------
-    // About data and help button.
+    /* Add about data */
 
     KPAboutData* const about = new KPAboutData(ki18n("Imgur Export"),
                                    0,
@@ -103,231 +135,171 @@ ImgurWindow::ImgurWindow(QWidget* const /*parent*/)
                      ki18n("Developer").toString(),
                      QString::fromLatin1("caulier dot gilles at gmail dot com"));
 
+    about->addAuthor(ki18n("Fabian Vogt").toString(),
+                     ki18n("Developer").toString(),
+                     QString::fromLatin1("fabian at ritter dash vogt dot de"));
+
     about->setHandbookEntry(QString::fromLatin1("imgur"));
     setAboutData(about);
 
-    // ------------------------------------------------------------
-
-    connect(startButton(), SIGNAL(clicked()),
-            this, SLOT(slotStartUpload()));
-
-    connect(this, SIGNAL(finished(int)),
-            this, SLOT(slotFinished()));
-
-    connect(this, SIGNAL(cancelClicked()),
-            this, SLOT(slotCancel()));
-
-    connect(d->webService, SIGNAL(signalQueueChanged()),
-            this, SLOT(slotImageQueueChanged()));
-
-    connect(d->webService, SIGNAL(signalBusy(bool)),
-            this, SLOT(slotBusy(bool)));
-
-    connect(d->webService, SIGNAL(signalUploadStart(QUrl)),
-            d->widget, SLOT(slotImageUploadStart(QUrl)));
-
-    connect(d->webService, SIGNAL(signalError(QUrl,ImgurError)),
-            d->widget, SLOT(slotImageUploadError(QUrl,ImgurError)));
-
-    connect(d->webService, SIGNAL(signalSuccess(QUrl,ImgurSuccess)),
-            d->widget, SLOT(slotImageUploadSuccess(QUrl,ImgurSuccess)));
-
-    // this signal/slot controls if the webservice should continue upload or not
-    connect(d->webService, SIGNAL(signalError(QUrl,ImgurError)),
-            this, SLOT(slotAddPhotoError(QUrl,ImgurError)));
-
-    connect(d->webService, SIGNAL(signalSuccess(QUrl,ImgurSuccess)),
-            this, SLOT(slotAddPhotoSuccess(QUrl,ImgurSuccess)));
-
-    connect(this, SIGNAL(signalContinueUpload(bool)),
-            d->webService, SLOT(slotContinueUpload(bool)));
-
-    // adding/removing items from the image list
-    connect(d->widget, SIGNAL(signalAddItems(QList<QUrl>)),
-            d->webService, SLOT(slotAddItems(QList<QUrl>)));
-
-    connect(d->widget, SIGNAL(signalRemoveItems(QList<QUrl>)),
-            d->webService, SLOT(slotRemoveItems(QList<QUrl>)));
-
-   // ---------------------------------------------------------------
-#ifdef OAUTH_ENABLED
-    connect(d->widget, SIGNAL(signalClickedChangeUser()),
-            d->webService, SLOT(slotOAuthLogin()));
-
-    //connect(d->webService, SIGNAL(signalAuthenticated(bool)),
-    //        d->widget, SLOT(slotAuthenticated(bool)));
-
-    connect(d->webService, SIGNAL(signalAuthenticated(bool,QString)),
-            d->widget, SLOT(slotAuthenticated(bool,QString)));
-
-    connect(d->webService, SIGNAL(signalAuthenticated(bool,QString)),
-            this, SLOT(slotAuthenticated(bool,QString)));
-#endif //OAUTH_ENABLED
+    /* Only used if not overwritten by readSettings() */
+    resize(650, 320);
     readSettings();
 }
 
 ImgurWindow::~ImgurWindow()
 {
     saveSettings();
+}
 
-    delete d->webService;
-    delete d;
+void ImgurWindow::reactivate()
+{
+    list->loadImagesFromCurrentSelection();
+    show();
 }
 
-void ImgurWindow::setContinueUpload(bool state)
+void ImgurWindow::forgetButtonClicked()
 {
-    setRejectButtonMode(state ? QDialogButtonBox::Cancel : QDialogButtonBox::Close);
+    api->getAuth().unlink();
 
-    emit signalContinueUpload(state);
+    apiAuthorized(false, {});
 }
 
-void ImgurWindow::slotCancel()
+void ImgurWindow::slotUpload()
+{
+    QList<const ImgurImageListViewItem*> pending = this->list->getPendingItems();
+    for(auto item : pending)
+    {
+        ImgurAPI3Action action;
+        action.type = ImgurAPI3ActionType::IMG_UPLOAD;
+        action.upload.imgpath = item->url().toLocalFile();
+        action.upload.title = item->Title();
+        action.upload.description = item->Description();
+        
+        api->queueWork(action);
+    }
+}
+
+void ImgurWindow::slotAnonUpload()
 {
-    setContinueUpload(false);
-    // Must cancel the transfer
-    d->webService->cancel();
-    d->webService->imageQueue()->clear();
-
-    d->widget->imagesList()->cancelProcess();
-    d->widget->progressBar()->setVisible(false);
-    d->widget->progressBar()->progressCompleted();
+    QList<const ImgurImageListViewItem*> pending = this->list->getPendingItems();
+    for(auto item : pending)
+    {
+        ImgurAPI3Action action;
+        action.type = ImgurAPI3ActionType::ANON_IMG_UPLOAD;
+        action.upload.imgpath = item->url().toLocalFile();
+        action.upload.title = item->Title();
+        action.upload.description = item->Description();
+        
+        api->queueWork(action);
+    }
 }
 
 void ImgurWindow::slotFinished()
 {
-    d->widget->progressBar()->progressCompleted();
-    d->widget->imagesList()->listView()->clear();
-    d->webService->imageQueue()->clear();
     saveSettings();
 }
 
-void ImgurWindow::closeEvent(QCloseEvent* e)
+void ImgurWindow::slotCancel()
 {
-    if (!e)
+    api->cancelAllWork();
+}
+
+void ImgurWindow::apiAuthorized(bool success, const QString &username)
+{
+    if(success)
     {
+        this->username = username;
+        this->userLabel->setText(this->username);
+        this->forgetButton->setEnabled(true);
         return;
     }
-
-    slotFinished();
-    e->accept();
+    
+    this->username = QString();
+    this->userLabel->setText(i18n("<Not logged in>"));
+    this->forgetButton->setEnabled(false);
 }
 
-void ImgurWindow::slotStartUpload()
+void ImgurWindow::apiAuthError(const QString &msg)
 {
-    d->widget->progressBar()->setValue(0);
-    d->widget->progressBar()->setFormat(i18n("%v / %m"));
-    d->widget->progressBar()->progressScheduled(i18n("Export to Imgur"), true, true);
-    d->widget->progressBar()->progressThumbnailChanged(QIcon::fromTheme(QString::fromLatin1("kipi")).pixmap(22, 22));
-
-    setContinueUpload(true);
+    QMessageBox::critical(this,
+                          i18n("Authorization Failed"),
+                          i18n("Failed to log into Imgur: %1\n", msg));
 }
 
-void ImgurWindow::reactivate()
+
+void ImgurWindow::apiProgress(unsigned int /*percent*/, const ImgurAPI3Action &action)
 {
-    d->widget->imagesList()->loadImagesFromCurrentSelection();
-    show();
+    list->processing(QUrl::fromLocalFile(action.upload.imgpath));
 }
 
-void ImgurWindow::slotImageQueueChanged()
+void ImgurWindow::apiRequestPin(const QUrl &url)
 {
-    startButton()->setEnabled(!d->webService->imageQueue()->isEmpty());
+    QDesktopServices::openUrl(url);
 }
 
-void ImgurWindow::slotAddPhotoError(const QUrl& /*currentImage*/, const ImgurError& error)
+void ImgurWindow::apiSuccess(const ImgurAPI3Result &result)
 {
-    if (!d->webService->imageQueue()->isEmpty())
-    {
-        if (QMessageBox::question(this, i18n("Uploading Failed"),
-                                  i18n("Failed to upload photo to Imgur: %1\n"
-                                       "Do you want to continue?", error.message))
-                != QMessageBox::Yes)
-        {
-            setContinueUpload(false);
-        }
-        else
-        {
-            setContinueUpload(true);
-        }
+    list->slotSuccess(result);
+}
 
-    }
-    else
+void ImgurWindow::apiError(const QString &msg, const ImgurAPI3Action &action)
+{
+    list->processed(QUrl::fromLocalFile(action.upload.imgpath), false);
+    
+    /* 1 here because the current item is still in the queue. */
+    if(api->workQueueLength() <= 1)
     {
-        QMessageBox::information(this, QString(), i18n("Failed to upload photo to Imgur: %1\n", error.message));
+        QMessageBox::critical(this,
+                              i18n("Uploading Failed"),
+                              i18n("Failed to upload photo to Imgur: %1\n", msg));
+        return;
     }
 
-    return;
-}
+    QMessageBox::StandardButton cont =
+            QMessageBox::question(this,
+                                  i18n("Uploading Failed"),
+                                  i18n("Failed to upload photo to Imgur: %1\n"
+                                       "Do you want to continue?", msg));
 
-void ImgurWindow::slotAddPhotoSuccess(const QUrl& /*currentImage*/, const ImgurSuccess& /*success*/)
-{
-   setContinueUpload(true);
+    if(cont != QMessageBox::Yes)
+        api->cancelAllWork();
 }
 
-void ImgurWindow::slotAuthenticated(bool yes, const QString& message)
+void ImgurWindow::apiBusy(bool busy)
 {
-    QString err;
-
-    if (!message.isEmpty())
-    {
-        err = i18nc("%1 is the error string",
-                    "Failed to authenticate to Imgur.\n%1\nDo you want to continue?",
-                    message);
-    }
-    else
-    {
-        err = i18n("Failed to authenticate to Imgur.\nDo you want to continue?");
-    }
-
-    if (yes)
-    {
-        startButton()->setEnabled(yes);
-    }
-    else if (QMessageBox::question(this, i18n("Processing Failed"), err)
-             == QMessageBox::Yes)
-    {
-        startButton()->setEnabled(true);
-    }
+    setCursor(busy ? Qt::WaitCursor : Qt::ArrowCursor);
+    startButton()->setEnabled(!busy);
 }
 
-void ImgurWindow::slotBusy(bool val)
+void ImgurWindow::closeEvent(QCloseEvent* e)
 {
-    if (val)
-    {
-        setCursor(Qt::WaitCursor);
-        startButton()->setEnabled(false);
-    }
-    else
-    {
-        setCursor(Qt::ArrowCursor);
-
-        if (d->webService->imageQueue()->isEmpty())
-        {
-            setContinueUpload(false);
-            startButton()->setEnabled(true);
-            d->widget->progressBar()->setVisible(false);
-            d->widget->progressBar()->progressCompleted();
-        }
-    }
+    if (!e)
+        return;
+
+    slotFinished();
+    e->accept();
 }
 
 void ImgurWindow::readSettings()
 {
     KConfig config(QString::fromLatin1("kipirc"));
-    //KConfigGroup group = config.group(QString("Imgur Settings"));
+    KConfigGroup groupAuth = config.group("Imgur Auth");
+    username = groupAuth.readEntry("username", QString());
+    apiAuthorized(!username.isEmpty(), username);
 
-    winId();
-    KConfigGroup group2 = config.group("Imgur Dialog");
-    KWindowConfig::restoreWindowSize(windowHandle(), group2);
-    resize(windowHandle()->size());
+    KConfigGroup groupDialog = config.group("Imgur Dialog");
+    KWindowConfig::restoreWindowSize(windowHandle(), groupDialog);
 }
 
 void ImgurWindow::saveSettings()
 {
     KConfig config(QString::fromLatin1("kipirc"));
-    //KConfigGroup group = config.group(QString("Imgur Settings"));
+    KConfigGroup groupAuth = config.group("Imgur Auth");
+    groupAuth.writeEntry("username", username);
 
-    KConfigGroup group2 = config.group("Imgur Dialog");
-    KWindowConfig::saveWindowSize(windowHandle(), group2);
+    KConfigGroup groupDialog = config.group("Imgur Dialog");
+    KWindowConfig::saveWindowSize(windowHandle(), groupDialog);
     config.sync();
 }
 
diff --git a/imgur/imgurwindow.h b/imgur/imgurwindow.h
index a3d142d..71fe0af 100644
--- a/imgur/imgurwindow.h
+++ b/imgur/imgurwindow.h
@@ -26,6 +26,7 @@
 // Qt includes
 
 #include <QObject>
+#include <QLabel>
 
 // Libkipi includes
 
@@ -33,19 +34,9 @@
 
 // Local includes
 
-#include "kpimageslist.h"
-#include "imgurwidget.h"
+#include "imgurimageslist.h"
 #include "kptooldialog.h"
-#include "imgurtalker.h"
-
-#ifdef OAUTH_ENABLED
-#include "imgurtalkerauth.h"
-#endif //OAUTH_ENABLED
-
-namespace KIPIPlugins
-{
-    class KPImagesList;
-}
+#include "imgurapi3.h"
 
 namespace KIPI
 {
@@ -63,44 +54,43 @@ class ImgurWindow : public KPToolDialog
     Q_OBJECT
 
 public:
-
     ImgurWindow(QWidget* const parent = 0);
     ~ImgurWindow();
 
     void reactivate();
 
 public Q_SLOTS:
-
-    void slotImageQueueChanged();
-    void slotBusy(bool val);
-
-    void slotAddPhotoSuccess(const QUrl& currentImage, const ImgurSuccess& success);
-    void slotAddPhotoError(const QUrl& currentImage, const ImgurError& error);
-//    void slotAuthenticated(bool yes);
-    void slotAuthenticated(bool yes, const QString& message = QLatin1String(""));
-
-    void slotStartUpload();
+    /* UI callbacks */
+    void forgetButtonClicked();
+    void slotUpload();
+    void slotAnonUpload();
     void slotFinished();
     void slotCancel();
-
-Q_SIGNALS:
-
-    void signalImageUploadSuccess(const QUrl&, const ImgurSuccess&);
-    void signalImageUploadError(const QUrl&, const ImgurError&);
-    void signalImageUploadCompleted();
-    void signalContinueUpload(bool yes);
+    
+    /* ImgurAPI3 callbacks */
+    void apiAuthorized(bool success, const QString &username);
+    void apiAuthError(const QString &msg);
+    void apiProgress(unsigned int percent, const ImgurAPI3Action &action);
+    void apiRequestPin(const QUrl &url);
+    void apiSuccess(const ImgurAPI3Result &result);
+    void apiError(const QString &msg, const ImgurAPI3Action &action);
+    void apiBusy(bool busy);
 
 private:
-
     void closeEvent(QCloseEvent* e);
     void setContinueUpload(bool state);
     void readSettings();
     void saveSettings();
 
 private:
-
-    class Private;
-    Private* const d;
+    ImgurImagesList *list = nullptr;
+    ImgurAPI3       *api  = nullptr;
+    QPushButton     *forgetButton = nullptr,
+                    *uploadAnonButton = nullptr;
+    QLabel          *userLabel = nullptr;
+    /* Contains the imgur username if API authorized.
+     * If not, username is null. */
+    QString         username;
 };
 
 } // namespace KIPIImgurPlugin
diff --git a/imgur/mpform.cpp b/imgur/mpform.cpp
deleted file mode 100644
index c02380c..0000000
--- a/imgur/mpform.cpp
+++ /dev/null
@@ -1,166 +0,0 @@
-/* ============================================================
- *
- * This file is a part of kipi-plugins project
- * http://www.kipi-plugins.org
- *
- * Date        : 2005-07-07
- * Description : a tool to export images to imgur.com
- *
- * Copyright (C) 2005-2008 by Vardhman Jain <vardhman at gmail dot com>
- * Copyright (C) 2008-2016 by Gilles Caulier <caulier dot gilles at gmail dot com>
- * Copyright (C) 2010-2012 by Marius Orcsik <marius at habarnam dot ro>
- *
- * This program is free software; you can redistribute it
- * and/or modify it under the terms of the GNU General
- * Public License as published by the Free Software Foundation;
- * either version 2, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * ============================================================ */
-
-#include "mpform.h"
-
-// Qt includes
-
-#include <QFile>
-#include <QApplication>
-#include <QUrl>
-#include <QMimeDatabase>
-#include <QMimeType>
-
-// Local includes
-
-#include "kipiplugins_debug.h"
-#include "kputil.h"
-
-namespace KIPIImgurPlugin
-{
-
-MPForm::MPForm()
-{
-    m_boundary  = "----------";
-    m_boundary += KIPIPlugins::KPRandomGenerator::randomString(42 + 13).toLatin1();
-}
-
-MPForm::~MPForm()
-{
-}
-
-void MPForm::reset()
-{
-    m_buffer.resize(0);
-}
-
-void MPForm::finish()
-{
-    QByteArray str;
-    str += "--";
-    str += m_boundary;
-    str += "--";
-    m_buffer.append(str);
-}
-
-bool MPForm::addPair(const QString& name, const QString& value, const QString& contentType)
-{
-    QByteArray str;
-    QString content_length = QString::number(value.length());
-
-    str += "--";
-    str += m_boundary;
-    str += "\r\n";
-
-    if (!name.isEmpty())
-    {
-        str += "Content-Disposition: form-data; name=\"";
-        str += name.toLatin1();
-        str += "\"\r\n";
-    }
-
-    if (!contentType.isEmpty())
-    {
-        str += "Content-Type: " + QByteArray(contentType.toLatin1());
-        str += "\r\n";
-        str += "Mime-version: 1.0 ";
-        str += "\r\n";
-    }
-
-    str += "Content-Length: ";
-    str += content_length.toLatin1();
-    str += "\r\n\r\n";
-    str += value.toUtf8();
-
-    m_buffer.append(str);
-    m_buffer.append("\r\n");
-
-    return true;
-}
-
-bool MPForm::addFile(const QString& name, const QString& path)
-{
-    QMimeDatabase db;
-    QMimeType ptr = db.mimeTypeForUrl(QUrl::fromLocalFile(path));
-    QString mime  = ptr.name();
-
-    if (mime.isEmpty())
-    {
-        // if we ourselves can't determine the mime of the local file,
-        // very unlikely the remote site will be able to identify it
-        return false;
-    }
-
-    QFile imageFile(path);
-
-    if (!imageFile.open(QIODevice::ReadOnly))
-    {
-        return false;
-    }
-
-    QByteArray imageData = imageFile.readAll();
-
-    QByteArray str;
-    QString file_size = QString::number(imageFile.size());
-    imageFile.close();
-
-    str += "--";
-    str += m_boundary;
-    str += "\r\n";
-    str += "Content-Disposition: form-data; name=\"";
-    str += name.toLatin1();
-    str += "\"; ";
-    str += "filename=\"";
-    str += QFile::encodeName(QUrl::fromLocalFile(path).fileName());
-    str += "\"\r\n";
-    str += "Content-Length: ";
-    str += file_size.toLatin1();
-    str += "\r\n";
-    str += "Content-Type: ";
-    str +=  mime.toLatin1();
-    str += "\r\n\r\n";
-
-    m_buffer.append(str);
-    m_buffer.append(imageData);
-    m_buffer.append("\r\n");
-
-    return true;
-}
-
-QString MPForm::contentType() const
-{
-    return QString::fromLatin1("multipart/form-data; boundary=") + QString::fromLatin1(m_boundary);
-}
-
-QString MPForm::boundary() const
-{
-    return QString::fromLatin1(m_boundary);
-}
-
-QByteArray MPForm::formData() const
-{
-    return m_buffer;
-}
-
-} // namespace KIPIImgurPlugin
diff --git a/imgur/mpform.h b/imgur/mpform.h
deleted file mode 100644
index d540a1b..0000000
--- a/imgur/mpform.h
+++ /dev/null
@@ -1,62 +0,0 @@
-/* ============================================================
- *
- * This file is a part of kipi-plugins project
- * http://www.kipi-plugins.org
- *
- * Date        : 2005-07-07
- * Description : a tool to export images to imgur.com
- *
- * Copyright (C) 2005-2008 by Vardhman Jain <vardhman at gmail dot com>
- * Copyright (C) 2008-2016 by Gilles Caulier <caulier dot gilles at gmail dot com>
- * Copyright (C) 2010-2012 by Marius Orcsik <marius at habarnam dot ro>
- *
- * This program is free software; you can redistribute it
- * and/or modify it under the terms of the GNU General
- * Public License as published by the Free Software Foundation;
- * either version 2, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * ============================================================ */
-
-#ifndef MPFORM_H
-#define MPFORM_H
-
-// Qt includes
-
-#include <QByteArray>
-#include <QString>
-
-namespace KIPIImgurPlugin
-{
-
-class MPForm
-{
-
-public:
-
-    MPForm();
-    ~MPForm();
-
-    void finish();
-    void reset();
-
-    bool addPair(const QString& name, const QString& value, const QString& type);
-    bool addFile(const QString& name, const QString& path);
-
-    QString    contentType() const;
-    QByteArray formData()    const;
-    QString    boundary()    const;
-
-private:
-
-    QByteArray m_buffer;
-    QByteArray m_boundary;
-};
-
-} // namespace KIPIImgurPlugin
-
-#endif /* MPFORM_H */
-- 
2.8.4

